<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="graxybot.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
<style>
:root {
    --background: #ffffff;
    --sidebar-bg: #f9fafb;
    --text-primary: #1a1a1a;
    --text-secondary: #6b7280;
    --primary: #4f46e5;
    --primary-light: #675ef2;
    --border-color: #e5e7eb;
    --input-bg: #f3f4f6;
    --user-message-bg: #eef2ff;
    --bot-message-bg: rgba(255, 255, 255, 0.85); /* Slightly transparent for wallpaper */
    --hover-bg: #f3f4f6;
    --code-bg: #272822;
    --code-header-bg: #3a3b35;
    --toast-bg: #333;
    --toast-text: white;
    --modal-bg: rgba(0, 0, 0, 0.5);
    --sidebar-width: 260px;
}

html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--background);
    color: var(--text-primary);
    display: flex;
    height: 100vh;
}

/* --- Main Layout --- */
.chat-app {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
}

#menu-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.3);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
}
#menu-backdrop.visible {
    opacity: 1;
    visibility: visible;
}


/* --- Sidebar --- */
.sidebar {
    width: var(--sidebar-width);
    background-color: var(--sidebar-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: transform 0.3s ease;
    z-index: 1001;
}
.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
}
.new-chat-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }
.chat-list {
    list-style: none;
    padding: 0;
    margin: 0.5rem;
    overflow-y: auto;
    flex-grow: 1;
}
.chat-list-item {
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 5px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
    position: relative;
    transition: background-color 0.2s ease;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
    background: none; border: none; font-size: 1rem; padding: 5px;
    color: var(--text-secondary); cursor: pointer; display: none;
}
.chat-list-item.active .delete-chat-btn { color: white; }
.chat-list-item:hover .delete-chat-btn { display: block; }
.sidebar-footer {
    padding: 1rem;
    border-top: 1px solid var(--border-color);
}

/* --- Main Content & Wallpaper --- */
.main-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    flex-grow: 1;
    width: calc(100% - var(--sidebar-width));
    box-sizing: border-box;
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    transition: background-image 0.5s ease-in-out;
}
.main-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.5);
    z-index: -1;
}

.chat-messages, .chat-input-container {
    position: relative;
    z-index: 1;
}

.chat-top-bar {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    height: 38px;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(5px);
    position: relative; /* Context for the title's absolute positioning */
    z-index: 10;
}
.menu-toggle {
    display: none;
}

/* --- CORRECTED TITLE ANIMATION --- */
/* --- CORRECTED TITLE ANIMATION --- */
#chat-title {
    position: fixed; /* Position relative to viewport */
    margin: 0;
    padding: 0; /* Remove any default padding */
    font-weight: 700;
    color: var(--primary);
    z-index: 10; /* Ensure above other elements */
    
    /* Default state (top-left within chat-top-bar) */
    top: 1rem;
    left: 4.5rem;
    font-size: 1.2rem;
    transform: none; /* Explicitly reset transform */

    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

#chat-title.title-center {
    /* Centered state (dead center of viewport) */
    top: 100%;
    left: 50%;
    font-size: 3rem;
    transform: translate(-50%, -50%);
    position: fixed;
}

/* Mobile responsive styles */
@media (max-width: 768px) {
    #chat-title {
        left: 4.5rem; /* Align with menu icon */
        top: 1rem;
        font-size: 1.2rem;
        transform: none;
    }
    #chat-title.title-center {
        left: 50%;
        top: 50%;
        font-size: 2.5rem;
        transform: translate(-50%, -50%);
    }
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 15px;
    display: flex;
    flex-direction: column;
}

/* --- Message Bubbles --- */
.message-content-wrapper {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 20px;
    max-width: 95%;
}
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary);
    color: white; display: flex; align-items: center; justify-content: center;
    font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #9ca3af; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; max-width: calc(100% - 40px); }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6;
    background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; border: 1px solid var(--border-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: #fef2f2; color: #991b1b; border-color: #fecaca; }
.message p { margin: 0; }
.generated-image, .sent-image {
    max-width: 100%; max-height: 400px; border-radius: 8px; margin-top: 8px;
    display: block; background-color: var(--input-bg);
}

/* Thinking Indicator & Code Block */
.thinking-indicator .message { padding: 15px 18px; display: flex; align-items: center; gap: 8px; }
.thinking-indicator span {
    display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary);
    border-radius: 50%; animation: typing 1s infinite ease-in-out;
}
.thinking-indicator span:nth-child(1) { animation-delay: 0s; }
.thinking-indicator span:nth-child(2) { animation-delay: 0.1s; }
.thinking-indicator span:nth-child(3) { animation-delay: 0.2s; }
@keyframes typing { 0%, 100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-4px); opacity: 1; } }
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-buttons button { background-color: #4a4b45; border: none; color: #f8f8f2; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; }

/* Chat Input */
.chat-input-container {
    padding: 1rem 1.5rem;
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(5px);
    border-top: 1px solid var(--border-color); flex-shrink: 0;
}
.chat-input-area {
    display: flex; align-items: center; background-color: #f9fafb;
    border: 1px solid var(--border-color); border-radius: 12px;
    padding: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
#message-input {
    flex-grow: 1; border: none; outline: none; background: transparent;
    font-size: 1rem; color: var(--text-primary); padding: 10px;
    resize: none; line-height: 1.5;
}
.input-actions { display: flex; align-items: center; gap: 5px; padding-right: 5px; }
.icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    border-radius: 8px; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0;
    background-color: transparent; color: var(--text-secondary);
    font-size: 1.1rem; transition: all 0.2s ease;
}
.icon-btn:hover { color: var(--primary); background-color: #eef2ff; }
.icon-btn.active { color: var(--primary); background-color: #e0e7ff; box-shadow: 0 0 0 3px #c7d2fe; }
.icon-btn:disabled { color: #d1d5db; background-color: transparent; cursor: not-allowed; }
#send-button { background-color: var(--primary); color: white; }
#send-button:hover { background-color: var(--primary-light); }
#send-button:disabled { background-color: #9ca3af; opacity: 0.7; }
#image-upload-input { display: none; }
#image-preview-area {
    margin-bottom: 10px; position: relative; display: inline-block; max-width: 100px;
}
#image-preview-area img { display: block; max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 6px; }
#remove-image-button {
    position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6);
    color: white; border: none; border-radius: 50%; width: 20px; height: 20px;
    font-size: 0.8rem; line-height: 20px; text-align: center; cursor: pointer;
}

/* Loader, Toast, Modals */
.loader-overlay {
    position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.9);
    display: flex; justify-content: center; align-items: center; z-index: 2002;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease;
}
.loader-overlay.visible { opacity: 1; visibility: visible; }
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
    border-radius: 50%; border-left-color: var(--primary);
    animation: spin 1s ease infinite;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
#toast-container {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 2001; pointer-events: none;
}
.toast-message {
    background-color: var(--toast-bg); color: var(--toast-text);
    padding: 10px 20px; border-radius: 8px; margin-bottom: 10px;
    opacity: 0; transition: all 0.3s ease-in-out; transform: translateY(20px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); font-size: 0.9rem;
    pointer-events: auto;
}
.toast-message.show { opacity: 1; transform: translateY(0); }

/* --- Settings & Wallpaper Modals --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: var(--modal-bg); z-index: 1002;
    display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal-overlay.visible { opacity: 1; visibility: visible; }
.modal-content {
    background: var(--background); padding: 30px; border-radius: 12px;
    max-width: 450px; width: 90%; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    position: relative; transform: scale(0.95); transition: transform 0.3s ease;
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-content h2 { margin-top: 0; font-size: 1.6rem; color: var(--primary); margin-bottom: 20px; }
.modal-content label { display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500; }
.modal-content input, .modal-content textarea {
    width: 100%; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: #f9fafb; color: var(--text-primary);
    font-size: 0.95rem; margin-bottom: 20px; box-sizing: border-box;
}
.modal-content button {
    width: 100%; padding: 12px 20px; background: var(--primary);
    color: white; border: none; border-radius: 8px; cursor: pointer;
    font-size: 1rem; font-weight: 600;
}
.modal-content .close-modal-btn {
    position: absolute; top: 15px; right: 15px; background: none; border: none;
    font-size: 1.5rem; color: var(--text-secondary); cursor: pointer;
}
.modal-content .secondary-btn {
    background-color: var(--input-bg);
    color: var(--text-primary);
    margin-top: 10px;
}
#wallpaper-modal-content .wallpaper-preview {
    margin-top: 15px;
    height: 150px;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--input-bg);
    background-size: cover;
    background-position: center;
    position: relative;
    overflow: hidden;
}
#wallpaper-modal-content .wallpaper-spinner {
    display: none;
}
#wallpaper-modal-content .wallpaper-preview img {
    max-width: 100%; max-height: 100%;
}


/* --- Mobile Responsive Styles --- */
@media (max-width: 768px) {
    .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100%;
        transform: translateX(-100%);
    }
    .sidebar.visible {
        transform: translateX(0);
    }
    .main-content {
        width: 100%;
    }
    .menu-toggle {
        display: block;
    }
    #chat-title {
        left: 4.5rem; /* Readjust for mobile to clear menu icon */
    }
    #chat-title.title-center {
        left: 50%;
        font-size: 2.5rem;
    }
}

/* --- Voice Mode Styles --- */
#voice-mode-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--background);
    z-index: 1002;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease, visibility 0.5s ease;
}
#voice-mode-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#voice-mode-canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.voice-mode-content {
    position: relative;
    z-index: 1;
    text-align: center;
    color: var(--text-primary);
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    width: 100%;
}
#transcribed-text, #bot-response-text {
    font-size: 1.5rem;
    font-weight: 500;
    max-width: 80%;
    margin: 2rem 0;
    transition: opacity 0.3s ease;
    min-height: 2em;
}
#thinking-indicator-voice {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-secondary);
    display: none;
    height: 1.5rem;
}
.voice-mode-controls {
    position: absolute;
    bottom: 5%;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 2rem;
    align-items: center;
}
.voice-mode-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    font-size: 1.5rem;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
}
#voice-mic-btn {
    background-color: var(--primary);
}
#voice-mic-btn.listening {
    animation: pulse 1.5s infinite;
}
#voice-hang-up-btn {
    background-color: #ef4444; /* Red */
}
#voice-hang-up-btn:hover {
    background-color: #dc2626; /* Darker Red */
}
@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.7);
    }
    70% {
        box-shadow: 0 0 0 20px rgba(79, 70, 229, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
    }
}
</style>
</head>
<body>

<div id="loader" class="loader-overlay visible">
    <div class="spinner"></div>
</div>

<div id="toast-container"></div>

<!-- Personality/Settings Modal -->
<div id="personality-overlay" class="modal-overlay">
    <div id="personality-modal-content" class="modal-content">
        <button class="close-modal-btn" id="close-personality-modal-btn">&times;</button>
        <h2>Personalize Graxybot</h2>
        <label for="user-name-input">What should Graxybot call you?</label>
        <input type="text" id="user-name-input" placeholder="e.g., Alex, Boss, Friend">
        <label for="response-style-input">How do you want Graxybot to respond?</label>
        <textarea id="response-style-input" rows="3" placeholder="e.g., Be concise and funny"></textarea>
        <button id="save-personality-btn">Save Settings</button>
        <button id="open-wallpaper-modal-btn" class="secondary-btn">Customize Chat Wallpaper</button>
        <button id="reset-wallpaper-btn" class="secondary-btn">Reset Wallpaper</button>
    </div>
</div>

<!-- Wallpaper Modal -->
<div id="wallpaper-overlay" class="modal-overlay">
    <div id="wallpaper-modal-content" class="modal-content">
        <button class="close-modal-btn" id="close-wallpaper-modal-btn">&times;</button>
        <h2>Chat Wallpaper</h2>
        <label for="wallpaper-prompt-input">Enter a prompt for your wallpaper:</label>
        <input type="text" id="wallpaper-prompt-input" placeholder="e.g., a serene mountain lake at dawn">
        <button id="generate-wallpaper-btn">Generate Image</button>
        
        <div id="wallpaper-preview" class="wallpaper-preview">
            <div class="spinner wallpaper-spinner" id="wallpaper-spinner"></div>
            <img id="wallpaper-image-preview" src="" alt="Wallpaper preview" style="display: none;"/>
        </div>

        <button id="save-wallpaper-btn" style="margin-top: 15px;" disabled>Save Wallpaper</button>
        <button id="remove-wallpaper-btn" class="secondary-btn">Remove Wallpaper</button>
    </div>
</div>


<div class="chat-app" id="chat-app">
     <div id="menu-backdrop"></div>
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="new-chat-btn">
                <i class="fas fa-plus"></i> New Chat
            </button>
        </div>
        <ul class="chat-list" id="chat-list">
        </ul>
        <div class="sidebar-footer">
            <button class="icon-btn" id="settings-button" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </aside>

    <main class="main-content" id="main-content">
        <div class="chat-top-bar">
             <button class="icon-btn menu-toggle" id="menu-toggle">
                <i class="fas fa-bars"></i>
            </button>
            <h1 id="chat-title">Graxybot</h1>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <footer class="chat-input-container">
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <button id="remove-image-button" title="Remove image">&times;</button>
            </div>
            <div class="chat-input-area">
                <input type="text" id="message-input" placeholder="Ask me anything...">
                <div class="input-actions">
                    <button id="image-upload-button" class="icon-btn" title="Attach Image"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="image-upload-input" accept="image/*">
                    <button id="create-image-button" class="icon-btn" title="Create Image"><i class="fas fa-image"></i></button>
                    <button id="mic-button" class="icon-btn" title="Start Speech Input"><i class="fas fa-microphone"></i></button>
                    <button id="send-button" class="icon-btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                </div>
            </div>
        </footer>
    </main>
</div>

<div id="voice-mode-overlay">
    <div id="voice-mode-canvas-container"></div>
    <div class="voice-mode-content">
        <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <p id="transcribed-text"></p>
            <p id="thinking-indicator-voice">Thinking...</p>
            <p id="bot-response-text"></p>
        </div>
        <div class="voice-mode-controls">
            <button class="icon-btn voice-mode-btn" id="voice-mic-btn"><i class="fas fa-microphone"></i></button>
            <button class="icon-btn voice-mode-btn" id="voice-hang-up-btn"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script type="module">
    // --- Configuration ---
    const OPENAI_MODEL = "gpt-4.1-mini";
    const GPT_4_1_MODEL = "gpt-4.1";
    const DEFAULT_STABLE_DIFFUSION_API_URL = "https://mid-zero-unless-hero.trycloudflare.com";
    const OPENAI_PROXY_ENDPOINT = window.location.origin + '/openai/chat';

    // --- UI & Storage Keys ---
    const BOT_ICON_SRC = "graxybot.png";
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_minimalist_chats_v3";
    const CURRENT_CHAT_ID_KEY = "graxybot_minimalist_current_chat_id_v3";
    const PERSONALITY_STORAGE_KEY = "graxybot_minimalist_personality_v3";
    const WALLPAPER_STORAGE_KEY = "graxybot_minimalist_wallpaper_v1";

    // --- DOM Element References ---
    let chatApp, chatMessagesContainer, messageInput, sendButton, createImageButton;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let loader, toastContainer, micButton, speechRecognition, isListening = false;
    let sidebar, newChatBtn, chatList, settingsButton, chatTitle, menuToggle, mainContent, menuBackdrop;
    let personalityOverlay, userNameInput, responseStyleInput, savePersonalityBtn, closePersonalityModalBtn, resetWallpaperBtn;
    let voiceModeOverlay, voiceModeCanvasContainer, voiceMicBtn, voiceHangUpBtn, transcribedText, botResponseText, thinkingIndicatorVoice;
    let openWallpaperModalBtn, wallpaperOverlay, closeWallpaperModalBtn, wallpaperPromptInput, generateWallpaperBtn, wallpaperPreview, wallpaperSpinner, wallpaperImagePreview, saveWallpaperBtn, removeWallpaperBtn;

    // --- Application State ---
    let chats = {};
    let currentChatId = null;
    let isRequestInProgress = false;
    let isImageGenerationModeActive = false;
    let isVoiceModeActive = false;
    let currentThinkingIndicatorElement = null;
    let selectedImageData = null, selectedImageMimeType = null, selectedImagePreviewUrl = null;
    let userPersonality = { name: null, responseStyle: null };
    let currentWallpaper = null;
    let generatedWallpaperData = null;
    
    // --- Voice Mode 3D Scene ---
    let voiceScene, voiceCamera, voiceRenderer, sphereParticles, logoParticles, particleTexture;

    // --- Core Functions ---
    function showToast(message, type = 'info', duration = 3000) {
        if (!toastContainer) return;
        const toast = document.createElement('div');
        toast.className = `toast-message ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('show'));
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, duration);
    }
    function generateChatId() { return `chat_${Date.now()}`; }
    function loadData() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            chats = storedChats ? JSON.parse(storedChats) : {};
            const storedChatId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
            if (storedChatId && chats[storedChatId]) {
                currentChatId = storedChatId;
            } else {
                currentChatId = null;
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
            const storedPersonality = localStorage.getItem(PERSONALITY_STORAGE_KEY);
            if (storedPersonality) userPersonality = JSON.parse(storedPersonality);
            
            const storedWallpaper = localStorage.getItem(WALLPAPER_STORAGE_KEY);
            if (storedWallpaper) {
                currentWallpaper = storedWallpaper;
                applyWallpaper(currentWallpaper);
            }
        } catch (error) {
            console.error("Error loading data:", error);
            chats = {}; currentChatId = null;
        }
    }
    function saveChats() {
        try {
            localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats));
            if (currentChatId) {
                localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId);
            } else {
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
        } catch (e) { console.error("Error saving chats:", e); }
    }
    function savePersonalitySettings() {
        try {
            localStorage.setItem(PERSONALITY_STORAGE_KEY, JSON.stringify(userPersonality));
        } catch (e) { console.error("Error saving personality:", e); }
    }
    function updateActionButtonsState() {
        const isBusy = isRequestInProgress || isListening;
        sendButton.disabled = isBusy || (!messageInput.value.trim() && !selectedImageData);
        imageUploadButton.disabled = isBusy;
        micButton.disabled = isBusy;
        micButton.classList.toggle('active', isListening);
        createImageButton.disabled = isBusy;
        createImageButton.classList.toggle('active', isImageGenerationModeActive);
        settingsButton.disabled = isBusy;
    }
    function getSystemPrompt(currentModelName) {
        let basePrompt = `You are Graxybot, a helpful AI assistant.
You are currently running on the ${currentModelName} model.
Your creator is 'thegraxisreal'.
IMPORTANT: When answering any questions about Global history or geography, or solving social studies homework sheets, all answers should be 1 or 2 words, formatted in all lowercase, with absolutely no restating of the question.
When receiving said social studies sheets, questions 1-5 should be answered in 1 or 2 words in all lowercase, and the ending questions that are longer should be answered in 1 or 2 sentences, all at a 9th-grade level for those problems.
Those restrictions only apply to global history questions. All other questions should be answered in lowercase and at a normal level.
Provide only the final answer, without revealing your internal thought process or reasoning steps unless explicitly asked to explain.
Keep your responses concise, helpful, and slightly informal.
Avoid overly complex language unless necessary.
Refer to yourself as Graxybot.
IMPORTANT: If the user asks you to generate an image or video/animation, let them know they can do that by pressing the buttons at the bottom of the screen.
When asked for code, default to HTML.
When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\``;
        if (userPersonality.name) {
             basePrompt += `\nAddress the user as "${userPersonality.name}".`;
        }
        if(userPersonality.responseStyle){
            basePrompt += `\nFollow these response style instructions: "${userPersonality.responseStyle}"`;
        }
        return basePrompt;
    }
    function addMessageToHistory(role, contentParts, imagePreview = null, generatedMediaSrc = null, mediaPrompt = null) {
       if (!currentChatId) { handleNewChat(false); }
       if (!chats[currentChatId]) return;
       if (role === 'user' && chats[currentChatId].history.length === 0) {
           const firstText = contentParts.find(p => p.text)?.text;
           chats[currentChatId].title = firstText ? firstText.substring(0, 30) : "New Chat";
           renderChatList();
       }
       const messageData = { role, parts: contentParts, timestamp: new Date().toISOString() };
       if (imagePreview) messageData.imagePreview = imagePreview;
       if (generatedMediaSrc) {
           messageData.generatedMediaSrc = generatedMediaSrc;
           messageData.mediaPrompt = mediaPrompt;
       }
       chats[currentChatId].history.push(messageData);
       saveChats();
    }
    function showThinkingIndicator(message = 'Thinking...') {
        removeThinkingIndicator();
        currentThinkingIndicatorElement = displayMessage([], 'bot-thinking', false, null, null, 'fa-brain', message);
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.classList.add('thinking-indicator');
            const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
            if (msgDiv) msgDiv.innerHTML = `<span></span><span></span><span></span> ${message}`;
        }
    }
    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.remove();
            currentThinkingIndicatorElement = null;
        }
    }
    function displayMessage(contentParts, sender, isError = false, imagePreview = null, generatedMediaSrc = null, customIconClass = null, mediaPrompt = null) {
        setChatActiveState(false);
        const wrapper = document.createElement('div');
        wrapper.className = 'message-content-wrapper';
        if (sender === 'user') wrapper.classList.add('user-message');
        const iconDiv = document.createElement('div');
        iconDiv.className = 'message-icon';
        if (sender === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else {
            if (customIconClass) {
                 iconDiv.innerHTML = `<i class="fas ${customIconClass}"></i>`;
            } else {
                const img = document.createElement('img');
                img.src = BOT_ICON_SRC;
                img.alt = "G";
                img.onerror = () => iconDiv.innerHTML = `<i class="fas fa-robot"></i>`;
                iconDiv.appendChild(img);
            }
        }
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        if (isError) messageDiv.classList.add('error-message');
        const paragraph = document.createElement('p');
        paragraph.dataset.streamTarget = "true";
        let textContent = Array.isArray(contentParts) ? (contentParts.find(p => p.text)?.text || '') : '';
        if (generatedMediaSrc) {
            const media = document.createElement('img');
            media.src = generatedMediaSrc; media.className = 'generated-image';
            messageDiv.appendChild(media);
            if (mediaPrompt) paragraph.innerHTML = `<em>Prompt: ${mediaPrompt}</em>`;
        } else if (imagePreview) {
            const img = document.createElement('img');
            img.src = imagePreview; img.className = 'sent-image';
            messageDiv.appendChild(img);
        }
        if (textContent) processAndAppendText(textContent, paragraph);
        if (paragraph.hasChildNodes() || paragraph.textContent || sender === 'bot') {
            messageDiv.appendChild(paragraph);
        }
        bubbleDiv.appendChild(messageDiv);
        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);
        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
        return wrapper;
    }
    function processAndAppendText(text, targetElement) {
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0, match;
        targetElement.innerHTML = '';
        while ((match = codeBlockRegex.exec(text)) !== null) {
            targetElement.innerHTML += text.substring(lastIndex, match.index).replace(/\n/g, '<br>');
            const lang = match[1]?.trim() || 'plaintext';
            const code = match[2].trim();
            const codeContainer = document.createElement('div');
            codeContainer.className = 'code-block-container';
            const header = document.createElement('div');
            header.className = 'code-block-header';
            header.innerHTML = `<span>${lang}</span><button title="Copy code">Copy</button>`;
            header.querySelector('button').onclick = () => handleCopyCode(code, header.querySelector('button'));
            const pre = document.createElement('pre');
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;
            pre.appendChild(codeEl);
            codeContainer.appendChild(header);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            lastIndex = codeBlockRegex.lastIndex;
        }
        targetElement.innerHTML += text.substring(lastIndex).replace(/\n/g, '<br>');
        if (window.Prism) setTimeout(() => Prism.highlightAllUnder(targetElement), 0);
    }
    function handleCopyCode(codeContent, buttonElement) {
        navigator.clipboard.writeText(codeContent).then(() => {
            showToast("Code copied!", 'success');
            buttonElement.textContent = 'Copied!';
            setTimeout(() => { buttonElement.textContent = 'Copy'; }, 2000);
        });
    }
    function renderChatList() {
        chatList.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a,b) => (chats[b].history[0]?.timestamp || 0) - (chats[a].history[0]?.timestamp || 0));
        sortedChatIds.forEach(id => {
            const li = document.createElement('li');
            li.className = 'chat-list-item';
            li.dataset.chatId = id;
            li.textContent = chats[id].title || 'Chat';
            if (id === currentChatId) li.classList.add('active');
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteChat(id); };
            li.appendChild(deleteBtn);
            li.onclick = () => handleSelectChat(id);
            chatList.appendChild(li);
        });
    }
    function loadChat(chatId) {
        if (!chats[chatId]) return;
        currentChatId = chatId;
        saveChats();
        renderChatList();
        chatMessagesContainer.innerHTML = '';
        const hasHistory = chats[chatId].history.length > 0;
        setChatActiveState(!hasHistory);
        if (hasHistory) {
            chats[chatId].history.forEach(msg => {
                displayMessage(msg.parts, msg.role, false, msg.imagePreview, msg.generatedMediaSrc, null, msg.mediaPrompt);
            });
        }
    }
    function handleNewChat(clearUI = true) {
        const newId = generateChatId();
        chats[newId] = { history: [], title: "New Chat" };
        currentChatId = newId;
        saveChats();
        renderChatList();
        if (clearUI) {
            chatMessagesContainer.innerHTML = '';
            setChatActiveState(true);
        }
    }
    function handleSelectChat(id) {
        if (id === currentChatId) return;
        sidebar.classList.remove('visible');
        menuBackdrop.classList.remove('visible');
        loadChat(id);
    }
    function handleDeleteChat(id) {
        if (confirm(`Are you sure you want to delete "${chats[id].title}"?`)) {
            delete chats[id];
            if (currentChatId === id) {
                currentChatId = null;
                chatMessagesContainer.innerHTML = '';
                setChatActiveState(true);
            }
            saveChats();
            renderChatList();
        }
    }
    
    // --- CORRECTED JAVASCRIPT LOGIC FOR ANIMATION ---
    function setChatActiveState(isActive) {
        // This function now correctly targets the title element to toggle the class
        if (isActive) {
            chatTitle.classList.add('title-center');
        } else {
            chatTitle.classList.remove('title-center');
        }
    }

    async function handleImageSelection(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            showToast("Invalid image file type.", 'error'); return;
        }
        try {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                selectedImageData = reader.result.split(',')[1];
                selectedImageMimeType = file.type;
                selectedImagePreviewUrl = URL.createObjectURL(file);
                imagePreview.src = selectedImagePreviewUrl;
                imagePreviewArea.style.display = 'block';
                updateActionButtonsState();
            };
            reader.onerror = () => { throw new Error("File could not be read.");};
        } catch (e) {
            showToast("Error processing image.", 'error');
            removeSelectedImage();
        }
    }
    function removeSelectedImage() {
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) URL.revokeObjectURL(selectedImagePreviewUrl);
        selectedImagePreviewUrl = null;
        imagePreviewArea.style.display = 'none';
        imageUploadInput.value = '';
        updateActionButtonsState();
    }
    async function triggerStableDiffusionGeneration(promptText, isForWallpaper = false) {
        if(!isForWallpaper) showThinkingIndicator(`Generating: "${promptText.substring(0, 50)}..."`);
        isRequestInProgress = true; 
        if(!isForWallpaper) updateActionButtonsState();

        const payload = { prompt: promptText, negative_prompt: "blurry, low quality, deformed", steps: 25 };
        try {
            const response = await fetch(`${DEFAULT_STABLE_DIFFUSION_API_URL}/sdapi/v1/txt2img`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            if(!isForWallpaper) removeThinkingIndicator();
            if (!response.ok) throw new Error(`API error: ${response.statusText}`);
            const data = await response.json();
            if (data.images && data.images.length > 0) {
                const imageSrc = `data:image/png;base64,${data.images[0]}`;
                if (isForWallpaper) {
                    return imageSrc;
                } else {
                    displayMessage([], 'bot', false, null, imageSrc, 'fa-palette', promptText);
                    addMessageToHistory('model', [{text: `Image generated`}], null, imageSrc, promptText);
                }
            } else { throw new Error('No images in API response.'); }
        } catch (error) {
            if(!isForWallpaper) {
                removeThinkingIndicator();
                displayMessage([{ text: `Image Generation Error: ${error.message}` }], 'bot', true);
            }
            throw error;
        } finally {
            isRequestInProgress = false; 
            if(!isForWallpaper) {
                deactivateImageGenerationMode(); 
                updateActionButtonsState();
            }
        }
    }
    async function sendMessageToOpenAI(messages, modelName, isVoiceMode = false) {
        let botMessageElement, paragraph;
        if (isVoiceMode) {
            thinkingIndicatorVoice.style.display = 'block';
        } else {
             botMessageElement = displayMessage([], 'bot');
             paragraph = botMessageElement.querySelector('[data-stream-target="true"]');
        }
        
        let fullResponseText = "";
        try {
            const response = await fetch(OPENAI_PROXY_ENDPOINT, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: modelName, messages })
            });
            if (!response.ok) throw new Error(`Proxy error: ${response.statusText}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                chunk.split('\n').forEach(line => {
                    if (line.startsWith('data: ')) {
                        const data = line.substring(6);
                        if (data === '[DONE]') return;
                        try {
                            const json = JSON.parse(data);
                            const content = json.choices[0]?.delta?.content || '';
                            if (content) {
                                fullResponseText += content;
                                if (!isVoiceMode && paragraph) {
                                   paragraph.innerHTML += content.replace(/\n/g, '<br>');
                                   chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
                                }
                            }
                        } catch (e) { /* ignore */ }
                    }
                });
            }
            if(isVoiceMode) {
                botResponseText.textContent = fullResponseText;
            } else if (paragraph) {
                processAndAppendText(fullResponseText, paragraph);
            }
            return fullResponseText;
        } catch (error) {
            if(isVoiceMode){
                botResponseText.textContent = `Error: ${error.message}`;
            } else if (paragraph) {
                paragraph.textContent = `Error: ${error.message}`;
                paragraph.parentElement.classList.add('error-message');
            }
            throw error;
        } finally {
            if(isVoiceMode) thinkingIndicatorVoice.style.display = 'none';
        }
    }
    async function handleSendMessage(messageTextFromVoice = null) {
        const messageText = messageTextFromVoice ?? messageInput.value.trim();
        if (!messageText && !selectedImageData) return;
        
        setChatActiveState(false);
        const imageWasAttached = !!selectedImageData;
        
        const userMessageParts = [];
        if (messageText) userMessageParts.push({ text: messageText });
        
        addMessageToHistory('user', userMessageParts, selectedImagePreviewUrl);
        
        if (!messageTextFromVoice) {
            displayMessage(userMessageParts, 'user', false, selectedImagePreviewUrl);
        }

        const currentPrompt = messageText;
        messageInput.value = '';
        removeSelectedImage();

        if (isImageGenerationModeActive) {
            isRequestInProgress = true; updateActionButtonsState();
            await triggerStableDiffusionGeneration(currentPrompt, false);
            isRequestInProgress = false; updateActionButtonsState();

        } else {
            isRequestInProgress = true; 
            if(!messageTextFromVoice) updateActionButtonsState();
            
            const modelToUse = currentPrompt.toLowerCase().includes("code") || imageWasAttached ? GPT_4_1_MODEL : OPENAI_MODEL;
            
            const systemPrompt = getSystemPrompt(modelToUse);
            const historyForAPI = (chats[currentChatId]?.history || [])
                .slice(-10).map(msg => ({
                    role: msg.role === 'model' ? 'assistant' : 'user',
                    content: msg.parts.map(p => p.text).join(' ')
                }));
            const messagesForOpenAI = [{ role: "system", content: systemPrompt }, ...historyForAPI];
            
            try {
                const aiResponse = await sendMessageToOpenAI(messagesForOpenAI, modelToUse, !!messageTextFromVoice);
                addMessageToHistory('model', [{ text: aiResponse }]);
                return aiResponse; // Return response for voice mode loop
            } catch (error) {
                return null;
            } finally {
                isRequestInProgress = false;
                if(!messageTextFromVoice) updateActionButtonsState();
            }
        }
    }

    // --- Voice Mode & 3D Scene ---
    function createParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0, 
            canvas.width / 2, canvas.height / 2, canvas.width / 2
        );
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.4, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
        return new THREE.CanvasTexture(canvas);
    }
    
    function initVoiceScene() {
        voiceScene = new THREE.Scene();
        voiceCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        voiceRenderer = new THREE.WebGLRenderer({ alpha: true });
        voiceRenderer.setSize(window.innerWidth, window.innerHeight);
        voiceModeCanvasContainer.appendChild(voiceRenderer.domElement);
        voiceCamera.position.z = 5;

        particleTexture = createParticleTexture();

        const sphereGeometry = new THREE.BufferGeometry();
        const sphereParticlesCount = 3000;
        const posArray = new Float32Array(sphereParticlesCount * 3);
        for(let i = 0; i < sphereParticlesCount * 3; i++) {
            const phi = Math.acos((2 * Math.random()) - 1);
            const theta = Math.random() * 2 * Math.PI;
            const r = 2 + Math.random() * 0.2;
            posArray[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i * 3 + 2] = r * Math.cos(phi);
        }
        sphereGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const sphereMaterial = new THREE.PointsMaterial({ 
            size: 0.05, 
            color: 0x8A2BE2,
            map: particleTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        sphereParticles = new THREE.Points(sphereGeometry, sphereMaterial);
        voiceScene.add(sphereParticles);
        
        window.addEventListener('resize', onVoiceWindowResize, false);
    }
    
    function onVoiceWindowResize() {
        if (!voiceRenderer) return;
        voiceCamera.aspect = window.innerWidth / window.innerHeight;
        voiceCamera.updateProjectionMatrix();
        voiceRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animateVoiceScene() {
        if (!isVoiceModeActive) return;
        requestAnimationFrame(animateVoiceScene);
        
        const time = Date.now() * 0.005;

        if (isListening && sphereParticles) {
            const scale = 1 + 0.05 * Math.sin(time * 2);
            sphereParticles.scale.set(scale, scale, scale);
        } else if (sphereParticles) {
            sphereParticles.scale.set(1, 1, 1);
        }

        if (sphereParticles) sphereParticles.rotation.y += 0.001;
        if (logoParticles) logoParticles.rotation.y -= 0.001;

        voiceRenderer.render(voiceScene, voiceCamera);
    }

    function createLogoParticles() {
        const loader = new THREE.TextureLoader();
        loader.load('graxybot.png', (texture) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = texture.image;
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let y = 0; y < imageData.height; y+=2) {
                for (let x = 0; x < imageData.width; x+=2) {
                    const i = (y * imageData.width + x) * 4;
                    if (imageData.data[i+3] > 128) {
                        const posX = (x - imageData.width / 2) / 50;
                        const posY = (-y + imageData.height / 2) / 50;
                        positions.push(posX, posY, 0);
                    }
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({ 
                size: 0.07, 
                color: 0x4f46e5,
                map: particleTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            logoParticles = new THREE.Points(geometry, material);
            logoParticles.position.z = 2;
            voiceScene.add(logoParticles);
        });
    }

    function enterVoiceMode() {
        isVoiceModeActive = true;
        chatApp.style.transition = 'opacity 0.5s ease';
        chatApp.style.opacity = '0';
        
        voiceModeOverlay.classList.add('visible');
        
        if (!voiceScene) {
            initVoiceScene();
        }
        createLogoParticles();
        animateVoiceScene();

        setTimeout(() => {
            toggleSpeechRecognition();
        }, 500);
    }
    
    function exitVoiceMode() {
        isVoiceModeActive = false;
        chatApp.style.opacity = '1';
        voiceModeOverlay.classList.remove('visible');
        isListening = false;
        if(speechRecognition) speechRecognition.stop();
        if(logoParticles) voiceScene.remove(logoParticles);
        logoParticles = null;
    }

    // --- UI Toggles & Handlers ---
    function initializeSpeechRecognition() {
        const SpeechAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechAPI) { micButton.style.display = 'none'; return; }
        speechRecognition = new SpeechAPI();
        speechRecognition.onstart = () => { 
            isListening = true; 
            if(isVoiceModeActive){
                 botResponseText.textContent = '';
                 transcribedText.textContent = 'Listening...';
                 voiceMicBtn.classList.add('listening');
            } else {
                updateActionButtonsState(); 
                messageInput.placeholder = "Listening...";
            }
        };
        speechRecognition.onresult = (e) => { 
            const transcript = e.results[0][0].transcript;
            if(isVoiceModeActive){
                transcribedText.textContent = transcript;
            } else {
                 messageInput.value = transcript; 
            }
        };
        speechRecognition.onend = () => { 
            isListening = false;
            if (isVoiceModeActive) {
                voiceMicBtn.classList.remove('listening');
                const finalTranscript = transcribedText.textContent;
                if (finalTranscript && finalTranscript !== 'Listening...') {
                    (async () => {
                        await handleSendMessage(finalTranscript);
                        setTimeout(() => {
                            if (isVoiceModeActive) {
                                transcribedText.textContent = '';
                                botResponseText.textContent = '';
                                toggleSpeechRecognition();
                            }
                        }, 3000);
                    })();
                } else if (isVoiceModeActive) {
                    setTimeout(toggleSpeechRecognition, 500);
                }
            } else {
                updateActionButtonsState(); 
                messageInput.placeholder = "Ask me anything..."; 
                if(messageInput.value) handleSendMessage(null); 
            }
        };
        speechRecognition.onerror = (e) => { 
            console.error(e.error); 
            showToast(`Mic error: ${e.error}`, 'error'); 
            isListening = false;
            if (isVoiceModeActive) {
                voiceMicBtn.classList.remove('listening');
            }
            updateActionButtonsState();
        };
    }
    function toggleSpeechRecognition() {
        if(isListening) {
             speechRecognition.stop();
        } else {
             if (!speechRecognition) initializeSpeechRecognition();
             speechRecognition.start();
        }
    }
    function deactivateImageGenerationMode() {
        isImageGenerationModeActive = false;
        messageInput.placeholder = "Ask me anything...";
        updateActionButtonsState();
    }
    function handleCreateImageButtonClick() {
        isImageGenerationModeActive = !isImageGenerationModeActive;
        messageInput.placeholder = isImageGenerationModeActive ? "Enter image prompt..." : "Ask me anything...";
        updateActionButtonsState();
        messageInput.focus();
    }
    function showPersonalityModal() {
        userNameInput.value = userPersonality.name || '';
        responseStyleInput.value = userPersonality.responseStyle || '';
        personalityOverlay.classList.add('visible');
    }
    function hidePersonalityModal() {
        personalityOverlay.classList.remove('visible');
    }
    function handleSavePersonality() {
        userPersonality.name = userNameInput.value.trim() || null;
        userPersonality.responseStyle = responseStyleInput.value.trim() || '';
        savePersonalitySettings();
        showToast("Personality saved!", "success");
        hidePersonalityModal();
    }

    // --- New Wallpaper Functions ---
    function showWallpaperModal() {
        hidePersonalityModal();
        wallpaperOverlay.classList.add('visible');
        wallpaperPromptInput.value = '';
        wallpaperImagePreview.style.display = 'none';
        saveWallpaperBtn.disabled = true;
        generatedWallpaperData = null;
    }

    function hideWallpaperModal() {
        wallpaperOverlay.classList.remove('visible');
    }

    async function handleGenerateWallpaper() {
        const prompt = wallpaperPromptInput.value.trim();
        if (!prompt) {
            showToast("Please enter a prompt for the wallpaper.", "error");
            return;
        }

        wallpaperSpinner.style.display = 'block';
        wallpaperImagePreview.style.display = 'none';
        generateWallpaperBtn.disabled = true;
        saveWallpaperBtn.disabled = true;

        try {
            const imageSrc = await triggerStableDiffusionGeneration(prompt, true);
            if(imageSrc){
                generatedWallpaperData = imageSrc;
                wallpaperImagePreview.src = imageSrc;
                wallpaperImagePreview.style.display = 'block';
                saveWallpaperBtn.disabled = false;
            } else {
                 showToast("Failed to generate wallpaper. Please try again.", "error");
            }
        } catch (error) {
            console.error("Wallpaper generation error:", error);
            showToast(`Error: ${error.message}`, "error");
        } finally {
            wallpaperSpinner.style.display = 'none';
            generateWallpaperBtn.disabled = false;
        }
    }

    function saveWallpaper() {
        if (generatedWallpaperData) {
            currentWallpaper = generatedWallpaperData;
            localStorage.setItem(WALLPAPER_STORAGE_KEY, currentWallpaper);
            applyWallpaper(currentWallpaper);
            showToast("Wallpaper saved!", "success");
            hideWallpaperModal();
        }
    }

    function applyWallpaper(imageDataUrl) {
        if(mainContent && imageDataUrl) {
            mainContent.style.backgroundImage = `url(${imageDataUrl})`;
        }
    }
    
    function handleResetWallpaper() {
        mainContent.style.backgroundImage = '';
        localStorage.removeItem(WALLPAPER_STORAGE_KEY);
        currentWallpaper = null;
        showToast("Wallpaper reset.", "success");
    }


    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        // Assign DOM elements
        loader = document.getElementById('loader');
        toastContainer = document.getElementById('toast-container');
        chatApp = document.getElementById('chat-app');
        sidebar = document.getElementById('sidebar');
        mainContent = document.getElementById('main-content');
        newChatBtn = document.getElementById('new-chat-btn');
        chatList = document.getElementById('chat-list');
        settingsButton = document.getElementById('settings-button');
        chatTitle = document.getElementById('chat-title');
        menuBackdrop = document.getElementById('menu-backdrop');
        chatMessagesContainer = document.getElementById('chat-messages');
        messageInput = document.getElementById('message-input');
        sendButton = document.getElementById('send-button');
        createImageButton = document.getElementById('create-image-button');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        micButton = document.getElementById('mic-button');
        menuToggle = document.getElementById('menu-toggle');
        
        // Personality Modal elements
        personalityOverlay = document.getElementById('personality-overlay');
        userNameInput = document.getElementById('user-name-input');
        responseStyleInput = document.getElementById('response-style-input');
        savePersonalityBtn = document.getElementById('save-personality-btn');
        closePersonalityModalBtn = document.getElementById('close-personality-modal-btn');
        openWallpaperModalBtn = document.getElementById('open-wallpaper-modal-btn');
        resetWallpaperBtn = document.getElementById('reset-wallpaper-btn');

        // Wallpaper Modal elements
        wallpaperOverlay = document.getElementById('wallpaper-overlay');
        closeWallpaperModalBtn = document.getElementById('close-wallpaper-modal-btn');
        wallpaperPromptInput = document.getElementById('wallpaper-prompt-input');
        generateWallpaperBtn = document.getElementById('generate-wallpaper-btn');
        wallpaperPreview = document.getElementById('wallpaper-preview');
        wallpaperSpinner = document.getElementById('wallpaper-spinner');
        wallpaperImagePreview = document.getElementById('wallpaper-image-preview');
        saveWallpaperBtn = document.getElementById('save-wallpaper-btn');
        removeWallpaperBtn = document.getElementById('remove-wallpaper-btn');

        // Voice Mode elements
        voiceModeOverlay = document.getElementById('voice-mode-overlay');
        voiceModeCanvasContainer = document.getElementById('voice-mode-canvas-container');
        voiceMicBtn = document.getElementById('voice-mic-btn');
        voiceHangUpBtn = document.getElementById('voice-hang-up-btn');
        transcribedText = document.getElementById('transcribed-text');
        botResponseText = document.getElementById('bot-response-text');
        thinkingIndicatorVoice = document.getElementById('thinking-indicator-voice');
        
        // Load data and render UI
loadData();
renderChatList();
setChatActiveState(true); // Force centered state initially
if (currentChatId && chats[currentChatId]?.history.length > 0) {
    loadChat(currentChatId); // This will switch to top-left when chat loads
}
updateActionButtonsState();

        // Add Event Listeners
        newChatBtn.addEventListener('click', () => {
            sidebar.classList.remove('visible');
            menuBackdrop.classList.remove('visible');
            handleNewChat(true);
        });
        settingsButton.addEventListener('click', showPersonalityModal);
        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('visible');
            menuBackdrop.classList.toggle('visible');
        });
        menuBackdrop.addEventListener('click', () => {
             sidebar.classList.remove('visible');
            menuBackdrop.classList.remove('visible');
        });
        sendButton.addEventListener('click', ()=> handleSendMessage(null));
        messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { e.preventDefault(); handleSendMessage(null); } });
        messageInput.addEventListener('input', updateActionButtonsState);
        createImageButton.addEventListener('click', handleCreateImageButtonClick);
        imageUploadButton.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageSelection);
        removeImageButton.addEventListener('click', removeSelectedImage);
        micButton.addEventListener('click', enterVoiceMode);
        voiceMicBtn.addEventListener('click', toggleSpeechRecognition);
        voiceHangUpBtn.addEventListener('click', exitVoiceMode);

        // Settings/Personality listeners
        closePersonalityModalBtn.addEventListener('click', hidePersonalityModal);
        savePersonalityBtn.addEventListener('click', handleSavePersonality);
        personalityOverlay.addEventListener('click', (e) => { if(e.target === personalityOverlay) hidePersonalityModal(); });
        openWallpaperModalBtn.addEventListener('click', showWallpaperModal);
        resetWallpaperBtn.addEventListener('click', handleResetWallpaper);

        // Wallpaper listeners
        closeWallpaperModalBtn.addEventListener('click', hideWallpaperModal);
        wallpaperOverlay.addEventListener('click', (e) => { if(e.target === wallpaperOverlay) hideWallpaperModal(); });
        generateWallpaperBtn.addEventListener('click', handleGenerateWallpaper);
        saveWallpaperBtn.addEventListener('click', saveWallpaper);
        removeWallpaperBtn.addEventListener('click', () => {
            handleResetWallpaper();
            hideWallpaperModal();
        });
        
        loader.classList.remove('visible');
        messageInput.focus();
        console.log("Graxybot UI Initialized.");
    });
</script>
</body>
</html>
