<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="graxybot.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
<style>
:root {
    --background: #ffffff;
    --sidebar-bg: #f9fafb;
    --text-primary: #1a1a1a;
    --text-secondary: #6b7280;
    --primary: #4f46e5;
    --primary-light: #675ef2;
    --border-color: #e5e7eb;
    --input-bg: #f3f4f6;
    --user-message-bg: #eef2ff;
    --bot-message-bg: #ffffff;
    --hover-bg: #f3f4f6;
    --code-bg: #272822;
    --code-header-bg: #3a3b35;
    --toast-bg: #333;
    --toast-text: white;
    --modal-bg: rgba(0, 0, 0, 0.5);
}

html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--background);
    color: var(--text-primary);
    display: flex;
    height: 100vh;
}

/* --- Main Layout --- */
.chat-app {
    display: flex;
    height: 100%;
    width: 100%;
}

/* --- Sidebar --- */
.sidebar {
    width: 260px;
    background-color: var(--sidebar-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
}

.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
}

.new-chat-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }

.chat-list {
    list-style: none;
    padding: 0;
    margin: 0.5rem;
    overflow-y: auto;
    flex-grow: 1;
}
.chat-list-item {
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 5px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
    position: relative;
    transition: background-color 0.2s ease;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
    background: none; border: none; font-size: 1rem; padding: 5px;
    color: var(--text-secondary); cursor: pointer; display: none;
}
.chat-list-item.active .delete-chat-btn { color: white; }
.chat-list-item:hover .delete-chat-btn { display: block; }

.sidebar-footer {
    padding: 1rem;
    border-top: 1px solid var(--border-color);
}

/* --- Main Content --- */
.main-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
}

.chat-top-bar {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}
.chat-top-bar h1 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
    color: var(--primary); /* Changed color */
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 15px;
    display: flex;
    flex-direction: column;
}

.welcome-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    flex-grow: 1;
    color: var(--text-secondary);
}
.welcome-title {
    font-size: 3rem;
    font-weight: 700;
    color: var(--primary); /* Changed color */
    margin-bottom: 2rem;
}

/* --- Message Bubbles --- */
.message-content-wrapper {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 20px;
    max-width: 95%;
}
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary);
    color: white; display: flex; align-items: center; justify-content: center;
    font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #9ca3af; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; max-width: calc(100% - 40px); }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6;
    background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; border: 1px solid var(--border-color);
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: #fef2f2; color: #991b1b; border-color: #fecaca; }
.message p { margin: 0; }
.generated-image, .sent-image {
    max-width: 100%; max-height: 400px; border-radius: 8px; margin-top: 8px;
    display: block; background-color: var(--input-bg);
}

/* Thinking Indicator */
.thinking-indicator .message { padding: 15px 18px; display: flex; align-items: center; gap: 8px; }
.thinking-indicator span {
    display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary);
    border-radius: 50%; animation: typing 1s infinite ease-in-out;
}
.thinking-indicator span:nth-child(1) { animation-delay: 0s; }
.thinking-indicator span:nth-child(2) { animation-delay: 0.1s; }
.thinking-indicator span:nth-child(3) { animation-delay: 0.2s; }
@keyframes typing { 0%, 100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-4px); opacity: 1; } }

/* Code Block */
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-buttons button { background-color: #4a4b45; border: none; color: #f8f8f2; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; }

/* Chat Input */
.chat-input-container {
    padding: 1rem 1.5rem; background-color: var(--background);
    border-top: 1px solid var(--border-color); flex-shrink: 0;
}
.chat-input-area {
    display: flex; align-items: center; background-color: #f9fafb;
    border: 1px solid var(--border-color); border-radius: 12px;
    padding: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
#message-input {
    flex-grow: 1; border: none; outline: none; background: transparent;
    font-size: 1rem; color: var(--text-primary); padding: 10px;
    resize: none; line-height: 1.5;
}
.input-actions { display: flex; align-items: center; gap: 5px; padding-right: 5px; }

.icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    border-radius: 8px; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0;
    background-color: transparent; color: var(--text-secondary);
    font-size: 1.1rem; transition: all 0.2s ease;
}
.icon-btn:hover { color: var(--primary); background-color: #eef2ff; }
.icon-btn.active { color: var(--primary); background-color: #e0e7ff; box-shadow: 0 0 0 3px #c7d2fe; }
.icon-btn:disabled { color: #d1d5db; background-color: transparent; cursor: not-allowed; }

#send-button { background-color: var(--primary); color: white; }
#send-button:hover { background-color: var(--primary-light); }
#send-button:disabled { background-color: #9ca3af; opacity: 0.7; }

/* Image Preview */
#image-upload-input { display: none; }
#image-preview-area {
    margin-bottom: 10px; position: relative; display: inline-block; max-width: 100px;
}
#image-preview-area img { display: block; max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 6px; }
#remove-image-button {
    position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6);
    color: white; border: none; border-radius: 50%; width: 20px; height: 20px;
    font-size: 0.8rem; line-height: 20px; text-align: center; cursor: pointer;
}

/* Loader & Toast */
.loader-overlay {
    position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.9);
    display: flex; justify-content: center; align-items: center; z-index: 2000;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease;
}
.loader-overlay.visible { opacity: 1; visibility: visible; }
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
    border-radius: 50%; border-left-color: var(--primary);
    animation: spin 1s ease infinite;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

#toast-container {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 1000; pointer-events: none;
}
.toast-message {
    background-color: var(--toast-bg); color: var(--toast-text);
    padding: 10px 20px; border-radius: 8px; margin-bottom: 10px;
    opacity: 0; transition: all 0.3s ease-in-out; transform: translateY(20px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); font-size: 0.9rem;
    pointer-events: auto;
}
.toast-message.show { opacity: 1; transform: translateY(0); }

/* Personality Modal */
#personality-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: var(--modal-bg); z-index: 1000;
    display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
}
#personality-overlay.visible { opacity: 1; visibility: visible; }
.personality-modal-content {
    background: var(--background); padding: 30px; border-radius: 12px;
    max-width: 450px; width: 90%; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    position: relative; transform: scale(0.95); transition: transform 0.3s ease;
}
#personality-overlay.visible .personality-modal-content { transform: scale(1); }
.personality-modal-content h2 { margin-top: 0; font-size: 1.6rem; color: var(--primary); margin-bottom: 20px; }
.personality-modal-content label { display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500; }
.personality-modal-content input, .personality-modal-content textarea {
    width: 100%; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: #f9fafb; color: var(--text-primary);
    font-size: 0.95rem; margin-bottom: 20px; box-sizing: border-box;
}
.personality-modal-content button {
    width: 100%; padding: 12px 20px; background: var(--primary);
    color: white; border: none; border-radius: 8px; cursor: pointer;
    font-size: 1rem; font-weight: 600;
}
.personality-modal-content .close-modal-btn {
    position: absolute; top: 15px; right: 15px; background: none; border: none;
    font-size: 1.5rem; color: var(--text-secondary); cursor: pointer;
}

</style>
</head>
<body>

<div id="loader" class="loader-overlay visible">
    <div class="spinner"></div>
</div>

<div id="toast-container"></div>

<div id="personality-overlay">
    <div class="personality-modal-content">
        <button class="close-modal-btn" id="close-personality-modal-btn">&times;</button>
        <h2>Personalize Graxybot</h2>
        <label for="user-name-input">What should Graxybot call you?</label>
        <input type="text" id="user-name-input" placeholder="e.g., Grayson, Boss, Friend">
        <label for="response-style-input">How do you want Graxybot to respond?</label>
        <textarea id="response-style-input" rows="3" placeholder="e.g., Be concise and funny"></textarea>
        <button id="save-personality-btn">Save Settings</button>
    </div>
</div>

<div class="chat-app">
    <aside class="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="new-chat-btn">
                <i class="fas fa-plus"></i> New Chat
            </button>
        </div>
        <ul class="chat-list" id="chat-list">
            <!-- Chat history items will be here -->
        </ul>
        <div class="sidebar-footer">
            <button class="icon-btn" id="settings-button" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </aside>

    <main class="main-content">
        <div class="chat-top-bar">
            <h1 id="chat-title">Graxybot</h1>
        </div>
        <div class="chat-messages" id="chat-messages">
            <div class="welcome-container" id="welcome-container">
                <h1 class="welcome-title">Graxybot</h1>
            </div>
        </div>
        <footer class="chat-input-container">
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <button id="remove-image-button" title="Remove image">&times;</button>
            </div>
            <div class="chat-input-area">
                <input type="text" id="message-input" placeholder="Ask me anything...">
                <div class="input-actions">
                    <button id="image-upload-button" class="icon-btn" title="Attach Image"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="image-upload-input" accept="image/*">
                    <button id="create-image-button" class="icon-btn" title="Create Image"><i class="fas fa-image"></i></button>
                    <button id="mic-button" class="icon-btn" title="Start Speech Input"><i class="fas fa-microphone"></i></button>
                    <button id="send-button" class="icon-btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                </div>
            </div>
        </footer>
    </main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script type="module">
    // --- Configuration ---
    const OPENAI_MODEL = "gpt-4.1-mini";
    const GPT_4_1_MODEL = "gpt-4.1";
    const DEFAULT_STABLE_DIFFUSION_API_URL = "https://mid-zero-unless-hero.trycloudflare.com";
    const OPENAI_PROXY_ENDPOINT = window.location.origin + '/openai/chat';

    // --- UI & Storage Keys ---
    const BOT_ICON_SRC = "graxybot.png";
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_minimalist_chats_v2";
    const CURRENT_CHAT_ID_KEY = "graxybot_minimalist_current_chat_id_v2";
    const PERSONALITY_STORAGE_KEY = "graxybot_minimalist_personality_v2";

    // --- DOM Element References ---
    let chatMessagesContainer, messageInput, sendButton, createImageButton;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let loader, toastContainer, welcomeContainer, micButton, speechRecognition, isListening = false;
    let sidebar, newChatBtn, chatList, settingsButton, chatTitle;
    let personalityOverlay, userNameInput, responseStyleInput, savePersonalityBtn, closePersonalityModalBtn;

    // --- Application State ---
    let chats = {};
    let currentChatId = null;
    let isRequestInProgress = false;
    let isImageGenerationModeActive = false;
    let currentThinkingIndicatorElement = null;
    let selectedImageData = null, selectedImageMimeType = null, selectedImagePreviewUrl = null;
    let userPersonality = { name: 'Grayson', responseStyle: null };

    // --- Core Functions ---

    /** Displays a temporary toast notification. */
    function showToast(message, type = 'info', duration = 3000) {
        if (!toastContainer) return;
        const toast = document.createElement('div');
        toast.className = `toast-message ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('show'));
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, duration);
    }

    /** Generates a unique ID for a new chat. */
    function generateChatId() { return `chat_${Date.now()}`; }

    /** Loads data from localStorage. */
    function loadData() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            chats = storedChats ? JSON.parse(storedChats) : {};
            const storedChatId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
            if (storedChatId && chats[storedChatId]) {
                currentChatId = storedChatId;
            } else {
                currentChatId = null;
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
            const storedPersonality = localStorage.getItem(PERSONALITY_STORAGE_KEY);
            if (storedPersonality) userPersonality = JSON.parse(storedPersonality);
        } catch (error) {
            console.error("Error loading data:", error);
            chats = {}; currentChatId = null;
        }
    }

    /** Saves all chats and current chat ID to localStorage. */
    function saveChats() {
        try {
            localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats));
            if (currentChatId) {
                localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId);
            } else {
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
        } catch (e) { console.error("Error saving chats:", e); }
    }
    
    /** Saves personality settings. */
    function savePersonalitySettings() {
        try {
            localStorage.setItem(PERSONALITY_STORAGE_KEY, JSON.stringify(userPersonality));
        } catch (e) { console.error("Error saving personality:", e); }
    }
    
    /** Updates the state of all interactive buttons. */
    function updateActionButtonsState() {
        const isBusy = isRequestInProgress || isListening;
        sendButton.disabled = isBusy || (!messageInput.value.trim() && !selectedImageData);
        imageUploadButton.disabled = isBusy;
        micButton.disabled = isBusy;
        micButton.classList.toggle('active', isListening);
        createImageButton.disabled = isBusy;
        createImageButton.classList.toggle('active', isImageGenerationModeActive);
        settingsButton.disabled = isBusy;
    }

    /** Gets the system prompt for OpenAI. */
    function getSystemPrompt(currentModelName) {
        let basePrompt = `You are Graybot, a helpful AI assistant created by Grayson. You are running on ${currentModelName}. Your responses should be concise, helpful, and slightly informal. Refer to yourself as Graybot. IMPORTANT: If the user asks you to generate an image, let them know they can do that by pressing the 'Create Image' button. When asked for code, default to HTML and use markdown format with language identifiers.`;
        if (userPersonality.name) basePrompt += ` Address the user as "${userPersonality.name}".`;
        if (userPersonality.responseStyle) basePrompt += ` Your response style should be: ${userPersonality.responseStyle}.`;
        return basePrompt;
    }

    /** Adds a message to the current chat's history object. */
    function addMessageToHistory(role, contentParts, imagePreview = null, generatedMediaSrc = null, mediaPrompt = null) {
       if (!currentChatId) {
           handleNewChat(false); // Create a new chat but don't clear the UI yet
       }
       if (!chats[currentChatId]) return;

        // Set title on first user message
       if (role === 'user' && chats[currentChatId].history.length === 0) {
           const firstText = contentParts.find(p => p.text)?.text;
           chats[currentChatId].title = firstText ? firstText.substring(0, 30) : "New Chat";
           renderChatList();
       }

       const messageData = { role, parts: contentParts, timestamp: new Date().toISOString() };
       if (imagePreview) messageData.imagePreview = imagePreview;
       if (generatedMediaSrc) {
           messageData.generatedMediaSrc = generatedMediaSrc;
           messageData.mediaPrompt = mediaPrompt;
       }

       chats[currentChatId].history.push(messageData);
       saveChats();
    }
    
    /** Displays a "thinking" indicator in the chat. */
    function showThinkingIndicator(message = 'Thinking...') {
        removeThinkingIndicator();
        currentThinkingIndicatorElement = displayMessage([], 'bot-thinking', false, null, null, 'fa-brain', message);
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.classList.add('thinking-indicator');
            const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
            if (msgDiv) msgDiv.innerHTML = `<span></span><span></span><span></span> ${message}`;
        }
    }

    /** Removes the thinking indicator. */
    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.remove();
            currentThinkingIndicatorElement = null;
        }
    }
    
    /** Displays a message in the chat UI. */
    function displayMessage(contentParts, sender, isError = false, imagePreview = null, generatedMediaSrc = null, customIconClass = null, mediaPrompt = null) {
        if (welcomeContainer) welcomeContainer.style.display = 'none';

        const wrapper = document.createElement('div');
        wrapper.className = 'message-content-wrapper';
        if (sender === 'user') wrapper.classList.add('user-message');

        const iconDiv = document.createElement('div');
        iconDiv.className = 'message-icon';
        if (sender === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else {
             iconDiv.innerHTML = `<i class="fas ${customIconClass || 'fa-robot'}"></i>`;
        }
        
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        if (isError) messageDiv.classList.add('error-message');

        const paragraph = document.createElement('p');
        paragraph.dataset.streamTarget = "true";

        let textContent = Array.isArray(contentParts) ? (contentParts.find(p => p.text)?.text || '') : '';

        if (generatedMediaSrc) {
            const media = document.createElement('img');
            media.src = generatedMediaSrc; media.className = 'generated-image';
            messageDiv.appendChild(media);
            if (mediaPrompt) paragraph.innerHTML = `<em>Prompt: ${mediaPrompt}</em>`;
        } else if (imagePreview) {
            const img = document.createElement('img');
            img.src = imagePreview; img.className = 'sent-image';
            messageDiv.appendChild(img);
        }

        if (textContent) processAndAppendText(textContent, paragraph);
        if (paragraph.hasChildNodes() || paragraph.textContent || sender === 'bot') {
            messageDiv.appendChild(paragraph);
        }

        bubbleDiv.appendChild(messageDiv);
        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);
        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
        
        return wrapper;
    }

    /** Processes text for code blocks. */
    function processAndAppendText(text, targetElement) {
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0, match;
        targetElement.innerHTML = '';
        while ((match = codeBlockRegex.exec(text)) !== null) {
            targetElement.innerHTML += text.substring(lastIndex, match.index).replace(/\n/g, '<br>');
            const lang = match[1]?.trim() || 'plaintext';
            const code = match[2].trim();
            const codeContainer = document.createElement('div');
            codeContainer.className = 'code-block-container';
            const header = document.createElement('div');
            header.className = 'code-block-header';
            header.innerHTML = `<span>${lang}</span><button title="Copy code">Copy</button>`;
            header.querySelector('button').onclick = () => handleCopyCode(code, header.querySelector('button'));
            const pre = document.createElement('pre');
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;
            pre.appendChild(codeEl);
            codeContainer.appendChild(header);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            lastIndex = codeBlockRegex.lastIndex;
        }
        targetElement.innerHTML += text.substring(lastIndex).replace(/\n/g, '<br>');
        if (window.Prism) setTimeout(() => Prism.highlightAllUnder(targetElement), 0);
    }
    
    /** Copies code to clipboard. */
    function handleCopyCode(codeContent, buttonElement) {
        navigator.clipboard.writeText(codeContent).then(() => {
            showToast("Code copied!", 'success');
            buttonElement.textContent = 'Copied!';
            setTimeout(() => { buttonElement.textContent = 'Copy'; }, 2000);
        });
    }
    
    /** Renders the list of chats in the sidebar. */
    function renderChatList() {
        chatList.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a,b) => (chats[b].history[0]?.timestamp || 0) - (chats[a].history[0]?.timestamp || 0));
        sortedChatIds.forEach(id => {
            const li = document.createElement('li');
            li.className = 'chat-list-item';
            li.dataset.chatId = id;
            li.textContent = chats[id].title || 'Chat';
            if (id === currentChatId) li.classList.add('active');

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteChat(id); };

            li.appendChild(deleteBtn);
            li.onclick = () => handleSelectChat(id);
            chatList.appendChild(li);
        });
    }
    
    /** Loads a selected chat into the main view. */
    function loadChat(chatId) {
        if (!chats[chatId]) return;
        currentChatId = chatId;
        saveChats();
        renderChatList();
        chatMessagesContainer.innerHTML = '';
        if (chats[chatId].history.length > 0) {
            chats[chatId].history.forEach(msg => {
                displayMessage(msg.parts, msg.role, false, msg.imagePreview, msg.generatedMediaSrc, null, msg.mediaPrompt);
            });
        } else {
             welcomeContainer.style.display = 'flex';
        }
        chatTitle.textContent = chats[chatId].title || "Graxybot";
    }

    /** Handles creating a new chat. */
    function handleNewChat(clearUI = true) {
        const newId = generateChatId();
        chats[newId] = { history: [], title: "New Chat" };
        currentChatId = newId;
        saveChats();
        renderChatList();
        if (clearUI) {
            chatMessagesContainer.innerHTML = '';
            welcomeContainer.style.display = 'flex';
            chatTitle.textContent = "Graxybot";
        }
    }

    /** Handles selecting a chat from the list. */
    function handleSelectChat(id) {
        if (id === currentChatId) return;
        loadChat(id);
    }

    /** Handles deleting a chat. */
    function handleDeleteChat(id) {
        if (confirm(`Are you sure you want to delete "${chats[id].title}"?`)) {
            delete chats[id];
            if (currentChatId === id) {
                currentChatId = null;
                chatMessagesContainer.innerHTML = '';
                welcomeContainer.style.display = 'flex';
                 chatTitle.textContent = "Graxybot";
            }
            saveChats();
            renderChatList();
        }
    }

    // --- Image and Send Logic ---
    async function handleImageSelection(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            showToast("Invalid image file type.", 'error'); return;
        }
        try {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                selectedImageData = reader.result.split(',')[1];
                selectedImageMimeType = file.type;
                selectedImagePreviewUrl = URL.createObjectURL(file);
                imagePreview.src = selectedImagePreviewUrl;
                imagePreviewArea.style.display = 'block';
                updateActionButtonsState();
            };
            reader.onerror = () => { throw new Error("File could not be read.");};
        } catch (e) {
            showToast("Error processing image.", 'error');
            removeSelectedImage();
        }
    }
    
    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result.split(',')[1]);
            reader.onerror = error => reject(error);
        });
    }

    function removeSelectedImage() {
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) URL.revokeObjectURL(selectedImagePreviewUrl);
        selectedImagePreviewUrl = null;
        imagePreviewArea.style.display = 'none';
        imageUploadInput.value = '';
        updateActionButtonsState();
    }
    
    async function triggerStableDiffusionGeneration(promptText) {
        showThinkingIndicator(`Generating: "${promptText.substring(0, 50)}..."`);
        isRequestInProgress = true; updateActionButtonsState();
        const payload = { prompt: promptText, negative_prompt: "blurry, low quality, deformed", steps: 25 };
        try {
            const response = await fetch(`${DEFAULT_STABLE_DIFFUSION_API_URL}/sdapi/v1/txt2img`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            removeThinkingIndicator();
            if (!response.ok) throw new Error(`API error: ${response.statusText}`);
            const data = await response.json();
            if (data.images && data.images.length > 0) {
                const imageSrc = `data:image/png;base64,${data.images[0]}`;
                displayMessage([], 'bot', false, null, imageSrc, 'fa-palette', promptText);
                addMessageToHistory('model', [{text: `Image generated`}], null, imageSrc, promptText);
            } else { throw new Error('No images in API response.'); }
        } catch (error) {
            removeThinkingIndicator();
            displayMessage([{ text: `Image Generation Error: ${error.message}` }], 'bot', true);
        } finally {
            isRequestInProgress = false; deactivateImageGenerationMode(); updateActionButtonsState();
        }
    }

    async function sendMessageToOpenAI(messages, modelName) {
        const botMessageElement = displayMessage([], 'bot');
        const paragraph = botMessageElement.querySelector('[data-stream-target="true"]');
        let fullResponseText = "";
        try {
            const response = await fetch(OPENAI_PROXY_ENDPOINT, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: modelName, messages })
            });
            if (!response.ok) throw new Error(`Proxy error: ${response.statusText}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                chunk.split('\n').forEach(line => {
                    if (line.startsWith('data: ')) {
                        const data = line.substring(6);
                        if (data === '[DONE]') return;
                        try {
                            const json = JSON.parse(data);
                            const content = json.choices[0]?.delta?.content || '';
                            if (content) {
                                fullResponseText += content;
                                paragraph.innerHTML += content.replace(/\n/g, '<br>');
                                chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
                            }
                        } catch (e) { /* ignore */ }
                    }
                });
            }
            processAndAppendText(fullResponseText, paragraph);
            return fullResponseText;
        } catch (error) {
            paragraph.textContent = `Error: ${error.message}`;
            botMessageElement.classList.add('error-message');
            throw error;
        }
    }

    async function handleSendMessage() {
        const messageText = messageInput.value.trim();
        if (!messageText && !selectedImageData) return;
        
        // Capture if an image is part of this message before clearing it
        const imageWasAttached = !!selectedImageData;

        isRequestInProgress = true; updateActionButtonsState();
        
        const userMessageParts = [];
        if (messageText) userMessageParts.push({ text: messageText });
        
        addMessageToHistory('user', userMessageParts, selectedImagePreviewUrl);
        displayMessage(userMessageParts, 'user', false, selectedImagePreviewUrl);
        
        const currentPrompt = messageText; // Save before clearing
        messageInput.value = '';
        removeSelectedImage();

        if (isImageGenerationModeActive) {
            await triggerStableDiffusionGeneration(currentPrompt);
        } else {
            // Determine which model to use. Upgrade to gpt-4.1 if the prompt contains "code" or has an image.
            const modelToUse = currentPrompt.toLowerCase().includes("code") || imageWasAttached ? GPT_4_1_MODEL : OPENAI_MODEL;
            
            const systemPrompt = getSystemPrompt(modelToUse);
            const historyForAPI = (chats[currentChatId]?.history || [])
                .slice(-10).map(msg => ({
                    role: msg.role === 'model' ? 'assistant' : 'user',
                    content: msg.parts.map(p => p.text).join(' ')
                }));
            const messagesForOpenAI = [{ role: "system", content: systemPrompt }, ...historyForAPI];
            
            try {
                const aiResponse = await sendMessageToOpenAI(messagesForOpenAI, modelToUse);
                addMessageToHistory('model', [{ text: aiResponse }]);
            } catch (error) {
                // Error already displayed by sendMessageToOpenAI
            } finally {
                isRequestInProgress = false; updateActionButtonsState();
            }
        }
    }

    // --- Speech Recognition ---
    function initializeSpeechRecognition() {
        const SpeechAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechAPI) { micButton.style.display = 'none'; return; }
        speechRecognition = new SpeechAPI();
        speechRecognition.onstart = () => { isListening = true; updateActionButtonsState(); messageInput.placeholder = "Listening..."; };
        speechRecognition.onresult = (e) => { messageInput.value = e.results[0][0].transcript; };
        speechRecognition.onend = () => { isListening = false; updateActionButtonsState(); messageInput.placeholder = "Ask me anything..."; if(messageInput.value) handleSendMessage(); };
        speechRecognition.onerror = (e) => { console.error(e.error); showToast(`Mic error: ${e.error}`, 'error'); isListening = false; updateActionButtonsState(); };
    }
    
    function toggleSpeechRecognition() {
        if (isListening) speechRecognition.stop();
        else {
            if (!speechRecognition) initializeSpeechRecognition();
            speechRecognition.start();
        }
    }

    // --- Mode Toggles ---
    function deactivateImageGenerationMode() {
        isImageGenerationModeActive = false;
        messageInput.placeholder = "Ask me anything...";
        updateActionButtonsState();
    }
    function handleCreateImageButtonClick() {
        isImageGenerationModeActive = !isImageGenerationModeActive;
        messageInput.placeholder = isImageGenerationModeActive ? "Enter image prompt..." : "Ask me anything...";
        updateActionButtonsState();
        messageInput.focus();
    }
    
    // --- Personality Modal ---
    function showPersonalityModal() {
        userNameInput.value = userPersonality.name || '';
        responseStyleInput.value = userPersonality.responseStyle || '';
        personalityOverlay.classList.add('visible');
    }
    function hidePersonalityModal() {
        personalityOverlay.classList.remove('visible');
    }
    function handleSavePersonality() {
        userPersonality.name = userNameInput.value.trim() || 'User';
        userPersonality.responseStyle = responseStyleInput.value.trim() || '';
        savePersonalitySettings();
        showToast("Personality saved!", "success");
        hidePersonalityModal();
    }

    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        // Assign DOM elements
        loader = document.getElementById('loader');
        toastContainer = document.getElementById('toast-container');
        sidebar = document.querySelector('.sidebar');
        newChatBtn = document.getElementById('new-chat-btn');
        chatList = document.getElementById('chat-list');
        settingsButton = document.getElementById('settings-button');
        chatTitle = document.getElementById('chat-title');
        chatMessagesContainer = document.getElementById('chat-messages');
        welcomeContainer = document.getElementById('welcome-container');
        messageInput = document.getElementById('message-input');
        sendButton = document.getElementById('send-button');
        createImageButton = document.getElementById('create-image-button');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        micButton = document.getElementById('mic-button');
        personalityOverlay = document.getElementById('personality-overlay');
        userNameInput = document.getElementById('user-name-input');
        responseStyleInput = document.getElementById('response-style-input');
        savePersonalityBtn = document.getElementById('save-personality-btn');
        closePersonalityModalBtn = document.getElementById('close-personality-modal-btn');
        
        // Load data and render UI
        loadData();
        renderChatList();
        if(currentChatId) { loadChat(currentChatId); }
        updateActionButtonsState();

        // Add Event Listeners
        newChatBtn.addEventListener('click', () => handleNewChat(true));
        settingsButton.addEventListener('click', showPersonalityModal);
        sendButton.addEventListener('click', handleSendMessage);
        messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { e.preventDefault(); handleSendMessage(); } });
        messageInput.addEventListener('input', updateActionButtonsState);
        createImageButton.addEventListener('click', handleCreateImageButtonClick);
        imageUploadButton.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageSelection);
        removeImageButton.addEventListener('click', removeSelectedImage);
        micButton.addEventListener('click', toggleSpeechRecognition);
        closePersonalityModalBtn.addEventListener('click', hidePersonalityModal);
        savePersonalityBtn.addEventListener('click', handleSavePersonality);
        personalityOverlay.addEventListener('click', (e) => { if(e.target === personalityOverlay) hidePersonalityModal(); });
        
        loader.classList.remove('visible');
        messageInput.focus();
        console.log("Graxybot UI Initialized.");
    });
</script>
</body>
</html>
