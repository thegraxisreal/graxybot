<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="graxybot.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
<style>
:root {
    --background: #0b1220;
    --sidebar-bg: #0f1729;
    --text-primary: #e8eefc;
    --text-secondary: #9fb0cc;
    --primary: #4BB5FF;
    --primary-light: #7cd6ff;
    --border-color: #1f2a3d;
    --input-bg: #0f1d31;
    --user-message-bg: #102846;
    --bot-message-bg: #0f1729;
    --hover-bg: #18263d;
    --code-bg: #0c182b;
    --code-header-bg: #12243b;
    --toast-bg: #111827;
    --toast-text: white;
    --modal-bg: rgba(0, 0, 0, 0.5);
    --sidebar-width: 260px;
    --danger-color: #ef4444;
    --danger-color-hover: #dc2626;
    --success-color: #22c55e;
    --success-color-hover: #16a34a;
}

body.theme-light {
    --background: #ffffff;
    --sidebar-bg: #f9fafb;
    --text-primary: #1a1a1a;
    --text-secondary: #6b7280;
    --primary: #4BB5FF;
    --primary-light: #7cd6ff;
    --border-color: #e5e7eb;
    --input-bg: #f3f4f6;
    --user-message-bg: #e8f6ff;
    --bot-message-bg: #f9fafb;
    --hover-bg: #f3f4f6;
    --code-bg: #272822;
    --code-header-bg: #3a3b35;
    --toast-bg: #333;
    --toast-text: white;
}

html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--background);
    color: var(--text-primary);
    display: flex;
    height: 100vh;
}

/* --- Main Layout --- */
.chat-app {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
}

#menu-backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.3);
    z-index: 1000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease;
}
#menu-backdrop.visible {
    opacity: 1;
    visibility: visible;
}


/* --- Sidebar --- */
.sidebar {
    width: var(--sidebar-width);
    background-color: var(--sidebar-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: transform 0.3s ease;
    z-index: 1001;
}
.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
}
.new-chat-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background-color: var(--background);
    color: white;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
}
.new-chat-btn:hover { background-color: var(--hover-bg); box-shadow: 0 4px 14px rgba(0,0,0,0.06); }
.new-chat-btn i { color: var(--primary); }
.changelog-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background-color: var(--input-bg);
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    margin-top: 8px;
}
.changelog-btn i { color: var(--primary); }
.changelog-btn:hover { background-color: var(--hover-bg); box-shadow: 0 4px 14px rgba(0,0,0,0.06); }
.chat-list {
    list-style: none;
    padding: 0;
    margin: 0.5rem;
    overflow-y: auto;
    flex-grow: 1;
}
.chat-list-item {
    padding: 10px 12px;
    border-radius: 10px;
    margin-bottom: 5px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
    position: relative;
    transition: background-color 0.2s ease;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
    background: none; border: none; font-size: 1rem; padding: 5px;
    color: var(--text-secondary); cursor: pointer; display: none;
}
.chat-list-item.active .delete-chat-btn { color: white; }
.chat-list-item:hover .delete-chat-btn { display: block; }

/* --- UPDATED SIDEBAR FOOTER STYLES --- */
.sidebar-footer {
    padding: 1rem;
    border-top: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 0.5rem; /* Reduced gap */
}

.sidebar-footer-controls {
    display: flex;
    gap: 0.5rem;
}

.sidebar-footer-link {
    flex-grow: 1; /* Make buttons share space */
    display: flex;
    align-items: center;
    justify-content: center; /* Center content */
    gap: 8px;
    background: var(--input-bg);
    border: 1px solid var(--border-color);
    cursor: pointer;
    color: var(--text-secondary);
    padding: 10px 14px;
    border-radius: 10px;
    font-size: 0.9rem;
    font-weight: 500;
    transition: all 0.2s ease;
}
.sidebar-footer-link:hover {
    background-color: var(--hover-bg);
    color: var(--text-primary);
    border-color: #d1d5db;
}
.sidebar-footer-link i {
    width: 16px;
    text-align: center;
}

/* --- Main Content & Themes --- */
.main-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    flex-grow: 1;
    width: calc(100% - var(--sidebar-width));
    box-sizing: border-box;
    position: relative;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    transition: background-image 0.5s ease-in-out;
    background-color: var(--background); /* Default background color */
    overflow: hidden; /* Important for theme containers */
}

#theme-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none; /* Allow clicks to go through to chat */
    overflow: hidden;
}

/* Grass Theme */
#grass-theme-container {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 25%; /* Adjust height of grass area */
    pointer-events: all; /* Capture mouse for interaction */
}
#grass-svg {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.grass-blade {
    transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
    transform-origin: bottom center;
}

/* Clouds Theme */
#clouds-theme-container {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #87CEEB; /* Sky blue */
    background: linear-gradient(to bottom, #87CEEB 0%, #B2FFFF 100%);
    pointer-events: all;
}
.cloud {
    position: absolute;
    background: white;
    border-radius: 50%;
    opacity: 0.8;
    transition: transform 0.5s ease-out;
    animation: drift linear infinite;
}
.cloud::before, .cloud::after {
    content: '';
    position: absolute;
    background: white;
    border-radius: 50%;
}
.cloud-1 { width: 200px; height: 60px; top: 10%; animation-duration: 75s; }
.cloud-1::before { width: 100px; height: 100px; top: -50px; left: 30px; }
.cloud-1::after { width: 120px; height: 80px; top: -30px; right: 20px; }
.cloud-2 { width: 300px; height: 80px; top: 25%; animation-duration: 90s; animation-delay: -20s; }
.cloud-2::before { width: 150px; height: 150px; top: -70px; left: 50px; }
.cloud-2::after { width: 180px; height: 100px; top: -40px; right: 40px; }
.cloud-3 { width: 150px; height: 50px; top: 50%; animation-duration: 60s; animation-delay: -40s; }
.cloud-3::before { width: 80px; height: 80px; top: -40px; left: 20px; }
@keyframes drift {
    from { transform: translateX(-250px) translateY(0); }
    to { transform: translateX(110vw) translateY(0); }
}


.chat-messages, .chat-input-container {
    position: relative;
    z-index: 1;
}

.chat-input-container {
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.chat-input-area {
    transition: max-width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.main-content.initial-view {
    justify-content: center;
    align-items: center;
    padding-bottom: 0;
}

.main-content.initial-view .chat-top-bar {
    background-color: transparent;
    border-bottom: none;
    position: static;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: auto;
    padding: 0;
}

.main-content.initial-view #chat-title {
    position: static;
    font-size: 3rem;
    margin-bottom: 20px;
    transform: none;
    top: auto;
    left: auto;
}

.main-content.initial-view .chat-input-container {
    position: static;
    width: 100%;
    bottom: auto;
    left: auto;
    background-color: transparent;
    backdrop-filter: none;
    border-top: none;
}

.main-content.initial-view .chat-input-area {
    max-width: 700px;
    margin: 0 auto;
    background-color: var(--background);
}

.main-content.initial-view .chat-messages {
    display: none;
}

.chat-top-bar {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    height: 38px;
    background-color: rgba(11, 18, 32, 0.75);
    backdrop-filter: blur(8px);
    position: relative; 
    z-index: 10;
}


#chat-title {
    position: fixed;
    margin: 0;
    padding: 0;
    font-weight: 700;
    color: var(--primary);
    z-index: 0; /* Keep title in the back */
    top: 1rem;
    left: 1.5rem; /* Adjusted for mobile */
    font-size: 1.2rem;
    transform: none;
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}

.menu-toggle {
    display: none; /* Hidden by default on desktop */
    z-index: 11; /* Make sure it's above other top-bar content */
}

@media (max-width: 768px) {
    #chat-title {
        left: 4.5rem;
        top: 1rem;
        font-size: 1.2rem;
        transform: none;
    }
    .menu-toggle {
        display: inline-flex;
    }
}

.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 15px;
    display: flex;
    flex-direction: column;
}

.message-content-wrapper {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 20px;
    max-width: 95%;
}
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary);
    color: white; display: flex; align-items: center; justify-content: center;
    font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #9ca3af; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; max-width: calc(100% - 40px); }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6;
    background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; border: 1px solid var(--border-color);
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: #fef2f2; color: #991b1b; border-color: #fecaca; }
.message p { margin: 0; }
.generated-image, .sent-image {
    max-width: 100%; max-height: 400px; border-radius: 8px; margin-top: 8px;
    display: block; background-color: var(--input-bg);
}

.thinking-indicator .message { padding: 15px 18px; display: flex; align-items: center; gap: 8px; }
.thinking-indicator span {
    display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary);
    border-radius: 50%; animation: typing 1s infinite ease-in-out;
}
.thinking-indicator span:nth-child(1) { animation-delay: 0s; }
.thinking-indicator span:nth-child(2) { animation-delay: 0.1s; }
.thinking-indicator span:nth-child(3) { animation-delay: 0.2s; }
@keyframes typing { 0%, 100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-4px); opacity: 1; } }
@keyframes imagePromptAura {
    0% { transform: scale(0.98); opacity: 0.55; }
    50% { transform: scale(1.04); opacity: 0.85; }
    100% { transform: scale(0.98); opacity: 0.55; }
}
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-buttons button { background-color: #4a4b45; border: none; color: #f8f8f2; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; display: inline-flex; align-items: center; gap: 5px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; }

.chat-messages, .chat-input-container {
    position: relative;
    z-index: 1;
}

.chat-input-container {
    padding: 1rem 1.5rem;
    background-color: rgba(11, 18, 32, 0.85);
    backdrop-filter: blur(8px);
    border-top: 1px solid var(--border-color); flex-shrink: 0;
    position: relative;
    z-index: 50; /* Ensure input UI is on top of everything else */
}

.chat-input-area {
    display: flex; align-items: center; background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    border-radius: 14px;
    padding: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    position: relative;
    overflow: visible;
    transition: border-color 0.3s ease, background 0.3s ease;
}
.chat-input-area::after {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: inherit;
    background: linear-gradient(120deg, rgba(75, 181, 255, 0.35), rgba(34, 211, 238, 0.35), rgba(250, 204, 21, 0.35));
    filter: blur(12px);
    opacity: 0;
    z-index: -1;
    transition: opacity 0.3s ease;
}
.chat-input-area.image-mode-active {
    border-color: rgba(75, 181, 255, 0.55);
    background-color: rgba(249, 250, 251, 0.95);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(75, 181, 255, 0.22);
}
.chat-input-area.web-design-mode-active {
    border-color: rgba(255, 193, 7, 0.55); /* Yellow border */
    background-color: var(--input-bg); /* Keep original input background for theme consistency */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(255, 193, 7, 0.22); /* Yellow box shadow */
}
.chat-input-area.image-mode-active::after,
.chat-input-area.web-design-mode-active::after {
    opacity: 1;
    animation: imagePromptAura 3.5s ease-in-out infinite;
}
.chat-input-area.web-design-mode-active::after {
    /* Override with a pure yellow gradient for Web Design mode */
    background: linear-gradient(120deg, rgba(255, 193, 7, 0.35), rgba(255, 223, 0, 0.35), rgba(255, 193, 7, 0.35));
}
.chat-input-area.image-mode-busy {
    border-color: rgba(148, 163, 184, 0.6);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.chat-input-area.image-mode-busy::after {
    opacity: 0;
}
.chat-input-area.search-mode-armed {
    border-color: rgba(16, 185, 129, 0.6);
    box-shadow: 0 1px 3px rgba(0,0,0,0.05), 0 0 0 2px rgba(16, 185, 129, 0.25);
}
.chat-input-area.search-mode-armed::after {
    opacity: 0;
}
#message-input {
    flex-grow: 1; border: none; outline: none; background: transparent;
    font-size: 1rem; color: var(--text-primary); padding: 10px;
    resize: none; line-height: 1.5;
}
.input-actions { display: flex; align-items: center; gap: 5px; padding-right: 5px; }
.icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    border-radius: 8px; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0;
    background-color: transparent; color: var(--text-secondary);
    font-size: 1.1rem; transition: all 0.2s ease;
}
.icon-btn:hover { color: var(--primary); background-color: #e8f6ff; }
.icon-btn.active { color: var(--primary); background-color: #d6efff; box-shadow: 0 0 0 3px #b4e2ff; }
.icon-btn:disabled { color: #d1d5db; background-color: transparent; cursor: not-allowed; }
#send-button { background-color: var(--primary); color: white; }
#send-button:hover { background-color: var(--primary-light); }
#send-button:disabled { background-color: #9ca3af; opacity: 0.7; }

.action-menu-container {
    position: relative;
    display: flex;
    align-items: center;
}
.agent-menu-container {
    position: relative;
    display: flex;
    align-items: center;
}
#action-menu-toggle {
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
#action-menu-toggle.active {
    transform: rotate(135deg);
    background-color: #e8f6ff;
    color: var(--primary);
}
#agent-menu-toggle {
    transition: background-color 0.2s ease, color 0.2s ease;
    width: auto; padding: 0 10px; gap: 6px;
}
#agent-menu-toggle.active {
    background-color: #fffbeb; /* Light yellow bg */
    color: #FFC107;
}
#agent-menu-toggle span {
    font-size: 0.9rem;
    font-weight: 500;
}
.action-menu {
    position: absolute;
    bottom: 100%;
    right: 0;
    margin-bottom: 10px;
    background-color: var(--background);
    border-radius: 12px;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    gap: 5px;
    padding: 8px;
    opacity: 0;
    transform: translateY(10px);
    visibility: hidden;
    transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s;
    z-index: 100; /* Increased z-index */
}
.action-menu.visible {
    opacity: 1;
    transform: translateY(0);
    visibility: visible;
}
.action-menu .menu-item {
    width: auto;
    height: 44px;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 0 15px;
    justify-content: flex-start;
    white-space: nowrap;
}

.action-menu .menu-item span {
    font-size: 0.9rem;
    font-weight: 500;
    color: var(--text-primary);
}

.menu-item-image i { color: #4BB5FF; }
.menu-item-me i { color: #FACC15; }
.menu-item-attach i { color: #3B82F6; }
.menu-item-reddit i { color: #FF4500; }
.menu-item-mic i { color: #EF4444; }
.menu-item-search i { color: #10B981; }
.menu-item-agent i { color: #FFC107; } /* Yellow for agent */

.menu-item:hover i {
    color: white !important;
}

.menu-item-image:hover { background-color: #4BB5FF; }
.menu-item-me:hover { background-color: #FACC15; }
.menu-item-attach:hover { background-color: #3B82F6; }
.menu-item-reddit:hover { background-color: #FF4500; }
.menu-item-mic:hover { background-color: #EF4444; }
.menu-item-search:hover { background-color: #10B981; }
.menu-item-agent:hover { background-color: #FFC107; } /* Yellow for agent hover */

.menu-item:hover span {
    color: white;
}
.menu-item-search.active {
    border: 1px solid rgba(16, 185, 129, 0.45);
    background-color: rgba(16, 185, 129, 0.18);
}
.menu-item-web-design.active {
    border: 1px solid rgba(255, 193, 7, 0.45); /* Yellow border */
    background-color: rgba(255, 193, 7, 0.18); /* Yellow background */
}
.menu-item-web-design.active span,
.menu-item-web-design.active i {
    color: #FFC107; /* Yellow for active icon/text */
}

.floating-coach {
    position: absolute;
    right: -12px;
    bottom: 64px;
    display: flex;
    align-items: center;
    gap: 0.6rem;
    padding: 0.65rem 0.9rem;
    background: #ffffff;
    border-radius: 14px;
    border: 1px solid rgba(15, 23, 42, 0.08);
    box-shadow: 0 16px 36px rgba(15, 23, 42, 0.18);
    opacity: 0;
    transform: translateY(8px);
    pointer-events: none;
    transition: opacity 0.35s ease, transform 0.35s ease;
    z-index: 1200;
}
.floating-coach::after {
    content: '';
    position: absolute;
    bottom: -8px;
    right: 26px;
    width: 0;
    height: 0;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 10px solid #ffffff;
    filter: drop-shadow(0 2px 4px rgba(15, 23, 42, 0.12));
}
.floating-coach.visible {
    opacity: 1;
    transform: translateY(0);
}
.floating-coach .coach-text {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary);
    max-width: 220px;
}
.floating-coach .coach-arrow {
    width: 32px;
    height: 32px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(79, 70, 229, 0.12);
    color: var(--primary);
    font-size: 1.1rem;
}

.image-build-message .message {
    display: flex;
    flex-direction: column;
    gap: 16px;
}
.image-build-preview {
    width: 220px;
    height: 220px;
    border-radius: 18px;
    position: relative;
    overflow: hidden;
    background: rgba(15, 23, 42, 0.08);
    display: flex;
    align-items: center;
    justify-content: center;
}
.image-build-swatch {
    width: 150%;
    height: 150%;
    filter: blur(22px);
    opacity: 0.9;
    animation: imageBuildSwirl 2.8s ease-in-out infinite alternate;
}
.image-build-glow {
    position: absolute;
    inset: 18%;
    border-radius: 20px;
    background: rgba(255, 255, 255, 0.25);
    filter: blur(28px);
    animation: imageBuildGlow 1.9s ease-in-out infinite alternate;
}
.image-build-caption {
    font-size: 0.9rem;
    color: var(--text-secondary);
    line-height: 1.45;
}
.image-build-caption strong {
    display: block;
    font-size: 0.95rem;
    color: var(--text-primary);
}
.image-build-caption .caption-prompt {
    display: block;
    margin-top: 4px;
    font-style: italic;
    color: var(--text-secondary);
    opacity: 0.85;
}

@keyframes imageBuildSwirl {
    0% { transform: rotate(0deg) scale(1); }
    100% { transform: rotate(25deg) scale(1.08); }
}
@keyframes imageBuildGlow {
    0% { opacity: 0.45; transform: scale(0.95); }
    100% { opacity: 0.75; transform: scale(1.05); }
}

#image-upload-input { display: none; }
#image-preview-area {
    margin-bottom: 10px; position: relative; display: inline-block; max-width: 100px;
}
#image-preview-area img { display: block; max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 6px; }
#remove-image-button {
    position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6);
    color: white; border: none; border-radius: 50%; width: 20px; height: 20px;
    font-size: 0.8rem; line-height: 20px; text-align: center; cursor: pointer;
}
.me-active-banner {
    margin-top: 10px;
    padding: 10px 14px;
    border-radius: 10px;
    background: rgba(250, 204, 21, 0.15);
    border: 1px solid rgba(250, 204, 21, 0.3);
    display: none;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
}
.me-active-info {
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-primary);
    font-size: 0.9rem;
    font-weight: 500;
}
.me-active-info i {
    color: #facc15;
    font-size: 1rem;
}
.me-active-controls {
    display: flex;
    gap: 8px;
}
.me-active-controls button {
    background: transparent;
    border: 1px solid rgba(250, 204, 21, 0.5);
    color: var(--text-primary);
    padding: 6px 12px;
    border-radius: 8px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
}
.me-active-controls button:hover {
    background: rgba(250, 204, 21, 0.35);
}
.me-input-highlight {
    border-color: rgba(250, 204, 21, 0.8) !important;
    box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.35) !important;
    background: #fffdf3 !important;
}

.web-design-mode-container {
    position: relative;
    display: flex;
    align-items: center;
}
#web-design-mode-toggle {
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    width: auto; padding: 0 10px; gap: 6px;
    background-color: var(--input-bg); /* Use theme variable for default background */
    color: var(--text-secondary); /* Use theme variable for default text color */
    border: 1px solid var(--border-color); /* Use theme variable for default border */
}
#web-design-mode-toggle:hover {
    background-color: var(--hover-bg); /* Use theme variable for hover background */
    color: var(--text-primary); /* Use theme variable for hover text color */
}

/* Style for when a mode is actually selected (always, as it shows "Pro" or "Simple") */
#web-design-mode-toggle.web-design-mode-selected {
    background-color: rgba(255, 193, 7, 0.15); /* Yellow tint */
    color: #FFC107; /* Yellow text */
    border: 1px solid rgba(255, 193, 7, 0.3);
}
#web-design-mode-toggle.web-design-mode-selected:hover {
    background-color: rgba(255, 193, 7, 0.25);
}

#web-design-mode-toggle span {
    font-size: 0.9rem;
    font-weight: 600;
}

/* Ensure menu items in the Web Design mode dropdown are readable */
.web-design-mode-container .menu-item {
    color: var(--text-primary);
    background-color: transparent;
    border: none;
    cursor: pointer;
    width: 100%;
    text-align: left;
    transition: background-color 0.2s ease;
}
.web-design-mode-container .menu-item:hover {
    background-color: rgba(255, 193, 7, 0.15); /* Yellow hover */
    color: #FFC107;
}
.web-design-mode-container .menu-item i {
    width: 20px;
    text-align: center;
    color: var(--text-secondary);
}
.web-design-mode-container .menu-item:hover i {
    color: #FFC107 !important;
}

.loader-overlay {
    position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.9);
    display: flex; justify-content: center; align-items: center; z-index: 2002;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease;
}
.loader-overlay.visible { opacity: 1; visibility: visible; }
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
    border-radius: 50%; border-left-color: var(--primary);
    animation: spin 1s ease infinite;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
#toast-container {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 3002;
    pointer-events: none;
}
.toast-message {
    background-color: var(--toast-bg); color: var(--toast-text);
    padding: 10px 20px; border-radius: 8px; margin-bottom: 10px;
    opacity: 0; transition: all 0.3s ease-in-out; transform: translateY(20px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); font-size: 0.9rem;
    pointer-events: auto;
}
.toast-message.show { opacity: 1; transform: translateY(0); }

/* --- Settings & Themes Modals --- */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: var(--modal-bg); z-index: 1002;
    display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
}
.modal-overlay.visible { opacity: 1; visibility: visible; }
.modal-content {
    background: var(--background); padding: 30px; border-radius: 12px;
    max-width: 500px; width: 90%; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    position: relative; transform: scale(0.95); transition: transform 0.3s ease;
}
.modal-overlay.visible .modal-content { transform: scale(1); }
.modal-content h2 { margin-top: 0; font-size: 1.6rem; color: var(--primary); margin-bottom: 20px; }
.modal-subtitle { margin-bottom: 16px; color: var(--text-secondary); }
.modal-content label { display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500; }
.modal-content input, .modal-content textarea {
    width: 100%; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: var(--input-bg); color: var(--text-primary);
    font-size: 0.95rem; margin-bottom: 20px; box-sizing: border-box;
}
.modal-content button {
    width: 100%; padding: 12px 20px; background: var(--primary);
    color: white; border: none; border-radius: 8px; cursor: pointer;
    font-size: 1rem; font-weight: 600;
}
.modal-content .close-modal-btn {
    position: absolute; top: 15px; right: 15px; background: none; border: none;
    font-size: 1.5rem; color: var(--text-secondary); cursor: pointer;
}
.modal-content .secondary-btn {
    background-color: var(--input-bg);
    color: var(--text-primary);
    margin-top: 10px;
}
.modal-content .danger-btn {
    background-color: var(--danger-color);
    margin-top: 10px;
}
.modal-content .danger-btn:hover {
    background-color: var(--danger-color-hover);
}

.settings-layout {
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
}
.settings-tabs {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    min-width: 160px;
}
.settings-tab-button {
    position: relative;
    text-align: left;
    padding: 0.6rem 1rem;
    border-radius: 10px;
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease;
}
.settings-tab-button:hover {
    background: var(--hover-bg);
    color: var(--text-primary);
}
.settings-tab-button.active {
    background: rgba(79, 70, 229, 0.12);
    color: var(--primary);
}
.settings-panels {
    flex: 1;
}
.settings-tab-panel {
    display: none;
    animation: fadeIn 0.2s ease;
}
.settings-tab-panel.active {
    display: block;
}
.changelog-list {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
}
.changelog-entry {
    padding: 14px;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background: var(--bot-message-bg);
    overflow: hidden;
}
.changelog-hero {
    width: 100%;
    max-height: 320px;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 12px;
    border: 1px solid var(--border-color);
    background: var(--input-bg);
    display: flex;
    align-items: center;
    justify-content: center;
}
.changelog-hero img {
    width: 100%;
    height: auto;
    max-height: 320px;
    object-fit: contain;
    display: block;
}
.changelog-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    gap: 10px;
}
.changelog-title {
    font-weight: 700;
    color: var(--text-primary);
}
.changelog-date {
    color: var(--text-secondary);
    font-size: 0.9rem;
}
.changelog-entry ul {
    margin: 0;
    padding-left: 20px;
    color: var(--text-secondary);
    line-height: 1.6;
}
.changelog-modal {
    max-width: 1100px;
    width: 96vw;
    max-height: 92vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: 24px;
}
.changelog-body {
    overflow-y: auto;
    padding-right: 6px;
    margin-top: 10px;
}
.changelog-body::-webkit-scrollbar {
    width: 8px;
}
.changelog-body::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.15);
    border-radius: 6px;
}
.launch-popup-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.55);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 5000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.25s ease;
}
.launch-popup-overlay.visible {
    opacity: 1;
    pointer-events: all;
}
.launch-popup {
    width: min(520px, 92vw);
    background: var(--bot-message-bg);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 18px;
    box-shadow: 0 15px 45px rgba(0,0,0,0.35);
    text-align: center;
}
.launch-popup img {
    width: 100%;
    max-height: 220px;
    object-fit: contain;
    border-radius: 12px;
    margin-bottom: 12px;
}
.launch-popup h3 {
    margin: 6px 0 8px;
    color: var(--text-primary);
}
.launch-popup p {
    margin: 0 0 16px;
    color: var(--text-secondary);
}
.launch-popup-actions {
    display: flex;
    gap: 10px;
    justify-content: center;
}
.launch-popup button {
    border: none;
    border-radius: 10px;
    padding: 10px 14px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.12s ease, box-shadow 0.12s ease;
}
.launch-popup .primary {
    background: var(--primary);
    color: white;
    box-shadow: 0 4px 12px rgba(75,181,255,0.4);
}
.launch-popup .secondary {
    background: var(--input-bg);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
.launch-popup button:hover { transform: translateY(-1px); }
.launch-popup button:active { transform: translateY(0); }
.settings-toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 12px;
    background: var(--bot-message-bg);
    margin-top: 10px;
    gap: 12px;
}
.toggle-text {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.toggle-title {
    font-weight: 600;
    color: var(--text-primary);
}
.toggle-subtitle {
    color: var(--text-secondary);
    font-size: 0.9rem;
}
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 46px;
    height: 26px;
}
.toggle-switch input { display: none; }
.toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #1f2a3d;
    transition: 0.3s;
    border-radius: 26px;
    border: 1px solid var(--border-color);
}
.toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px; width: 18px;
    left: 4px; bottom: 4px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
}
.toggle-switch input:checked + .toggle-slider {
    background-color: var(--primary);
    box-shadow: 0 0 0 4px rgba(75, 181, 255, 0.15);
}
.toggle-switch input:checked + .toggle-slider:before {
    transform: translateX(18px);
}
.usage-section {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
}
.usage-card {
    background: var(--background);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1.1rem 1.2rem;
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
}
.usage-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.75rem;
}
.usage-progress {
    height: 10px;
    border-radius: 999px;
    background: rgba(79, 70, 229, 0.12);
    overflow: hidden;
}
.usage-progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--primary), var(--primary-light));
    transition: width 0.3s ease;
}
.usage-progress-bar.at-limit {
    background: linear-gradient(90deg, var(--danger-color), var(--danger-color-hover));
}
.usage-reset {
    margin-top: 0.6rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
}
.usage-note {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(6px); }
    to { opacity: 1; transform: translateY(0); }
}

/* --- Me Popup --- */
#me-popup {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease;
    z-index: 3000;
}
#me-popup.visible {
    opacity: 1;
    visibility: visible;
}
.me-popup-card {
    background: var(--background);
    border-radius: 16px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.25);
    width: min(420px, 90%);
    padding: 28px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    position: relative;
}
.me-popup-card h2 {
    margin: 0;
    color: var(--primary);
    font-size: 1.6rem;
}
.me-popup-card p {
    margin: 0;
    color: var(--text-secondary);
    line-height: 1.5;
}
.me-media-area {
    display: flex;
    flex-direction: column;
    gap: 12px;
    align-items: center;
}
.me-media-preview {
    width: 220px;
    height: 220px;
    border-radius: 12px;
    border: 1px dashed var(--border-color);
    background: var(--input-bg);
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
    transition: transform 0.2s ease;
}
.me-media-preview.clickable {
    cursor: pointer;
}
.me-media-preview video,
.me-media-preview img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
.me-media-preview img.has-photo {
    border: 2px solid rgba(250, 204, 21, 0.6);
}
.me-control-row {
    display: flex;
    justify-content: center;
    gap: 12px;
    width: 100%;
}
.me-control-row button {
    flex: 1;
    border-radius: 10px;
    padding: 12px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: transform 0.1s ease, box-shadow 0.1s ease;
}
.me-popup-card .primary-btn,
.me-popup-card .secondary-btn,
.me-popup-card .danger-btn {
    border-radius: 10px;
    padding: 12px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: transform 0.1s ease, box-shadow 0.1s ease;
}
.me-control-row .primary-btn {
    background: var(--primary);
    color: white;
}
.me-control-row .secondary-btn {
    background: var(--input-bg);
    color: var(--text-primary);
}
.me-popup-card .primary-btn {
    background: var(--primary);
    color: white;
}
.me-popup-card .secondary-btn {
    background: var(--input-bg);
    color: var(--text-primary);
}
.me-popup-card .danger-btn {
    background: var(--danger-color);
    color: white;
}
.me-control-row button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15);
}
.me-popup-card .primary-btn:hover,
.me-popup-card .secondary-btn:hover,
.me-popup-card .danger-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15);
}
#me-retake-row {
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}
#me-retake-row.visible {
    opacity: 1;
    pointer-events: auto;
}
.me-popup-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.me-popup-actions button {
    border-radius: 10px;
    padding: 12px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: transform 0.1s ease, box-shadow 0.1s ease;
}
.me-popup-actions button.primary-btn {
    background: var(--primary);
    color: white;
}
.me-popup-actions button.secondary-btn {
    background: var(--input-bg);
    color: var(--text-primary);
}
.me-popup-actions button.danger-btn {
    background: var(--danger-color);
    color: white;
}
.me-popup-actions button:hover {
    transform: translateY(-1px);
    box-shadow: 0 6px 16px rgba(0,0,0,0.15);
}
.me-popup-close {
    position: absolute;
    top: 12px;
    right: 16px;
    background: none;
    border: none;
    font-size: 1.5rem;
    color: var(--text-secondary);
    cursor: pointer;
}
.me-prompt-area {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.me-prompt-area textarea {
    width: 100%;
    min-height: 90px;
    border-radius: 10px;
    border: 1px solid var(--border-color);
    padding: 12px;
    font-family: inherit;
    font-size: 0.95rem;
    resize: vertical;
    background: var(--input-bg);
    transition: box-shadow 0.2s ease, border-color 0.2s ease;
}
.me-prompt-area.active textarea {
    border-color: rgba(250, 204, 21, 0.9);
    box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.35);
    background: #fffdf3;
}
.me-prompt-area textarea:focus {
    border-color: rgba(250, 204, 21, 0.8);
    box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.35);
    outline: none;
}
.me-hint {
    font-size: 0.85rem;
    color: var(--text-secondary);
    text-align: center;
}

/* Themes Modal Specifics */
#themes-modal-content .theme-options {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 15px;
    margin-bottom: 25px;
}
.theme-box {
    height: 120px;
    border: 2px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 8px;
    background-color: var(--input-bg);
}
.theme-box:hover {
    border-color: var(--primary);
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
.theme-box.active {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px var(--primary-light);
}
.theme-box .theme-name {
    font-weight: 600;
    color: var(--text-primary);
    z-index: 2;
}
.theme-box .theme-icon {
    font-size: 1.8rem;
    color: var(--primary);
    z-index: 2;
}
#grass-theme-box { background: linear-gradient(to top, #90ee90, #c1ffc1); }
#clouds-theme-box { background: linear-gradient(to bottom, #87CEEB, #B2FFFF); }

#generate-theme-container {
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}
.modal-preview-box {
    margin-top: 15px;
    height: 150px;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--input-bg);
    background-size: cover;
    background-position: center;
    position: relative;
    overflow: hidden;
}
.modal-preview-box .modal-spinner { display: none; }
.modal-preview-box img { max-width: 100%; max-height: 100%; }

/* --- Mobile Responsive Styles --- */
@media (max-width: 768px) {
    .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100%;
        transform: translateX(-100%);
    }
    .sidebar.visible {
        transform: translateX(0);
    }
    .main-content {
        width: 100%;
    }
    #chat-title.title-center {
        left: 50%;
        font-size: 2.5rem;
    }
}

/* --- Reddit Story Player Styles --- */
#story-overlay {
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 0;
    background-color: black;
    z-index: 4000;
}
#story-video-container {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
}
#story-video {
    height: 100%;
    width: auto;
    object-fit: cover;
}
#story-captions-container {
    position: absolute;
    bottom: 10%;
    color: white;
    text-align: center;
    font-size: 2.5rem;
    font-weight: bold;
    padding: 20px;
    width: 80%;
    text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
    background-color: rgba(0,0,0,0.3);
    border-radius: 10px;
}
#story-captions-container .highlight {
    color: #ffc107;
}
#close-story-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    font-size: 2.5rem;
    color: white;
    background: rgba(0,0,0,0.5);
    border-radius: 50%;
    width: 50px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    z-index: 4001;
}

#story-watermark {
    position: absolute;
    bottom: 15px;
    left: 15px;
    font-size: 1.2rem;
    font-weight: 700;
    color: var(--primary);
    opacity: 0.4;
    z-index: 4001;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
}

#story-outro {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 4002;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease;
}
#story-outro.visible {
    opacity: 1;
    visibility: visible;
}
.outro-line-1, .outro-line-2 {
    color: white;
    font-weight: 700;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.8s ease, transform 0.8s ease;
}
.outro-line-1 {
    font-size: 3.5rem;
    color: var(--primary);
    transition-delay: 0.5s;
}
.outro-line-2 {
    font-size: 1.8rem;
    margin-top: 1rem;
    transition-delay: 0.8s;
}
#story-outro.visible .outro-line-1,
#story-outro.visible .outro-line-2 {
    opacity: 1;
    transform: translateY(0);
}

</style>
</head>
<body>

<div id="loader" class="loader-overlay">
    <div class="spinner"></div>
</div>

<div id="toast-container"></div>

<!-- Settings Modal -->
<div id="personality-overlay" class="modal-overlay">
    <div id="personality-modal-content" class="modal-content">
        <button class="close-modal-btn" id="close-personality-modal-btn">&times;</button>
        <h2>Graxybot Settings</h2>
        <div class="settings-layout">
            <div class="settings-tabs">
                <button class="settings-tab-button active" data-settings-tab="profile">Profile</button>
                <button class="settings-tab-button" data-settings-tab="usage">Usage</button>
            </div>
            <div class="settings-panels">
                <div class="settings-tab-panel active" id="settings-tab-profile" data-settings-panel="profile">
                    <label for="user-name-input">What should Graxybot call you?</label>
                    <input type="text" id="user-name-input" placeholder="e.g., Alex, Boss, Friend">
                    <label for="response-style-input">How do you want Graxybot to respond?</label>
                    <textarea id="response-style-input" rows="3" placeholder="e.g., Be concise and funny"></textarea>
                    <div class="settings-toggle-row">
                        <div class="toggle-text">
                            <div class="toggle-title">Dark mode</div>
                            <div class="toggle-subtitle">Keep things moody or switch back to light.</div>
                        </div>
                        <label class="toggle-switch">
                            <input type="checkbox" id="theme-mode-toggle" checked>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <button id="save-personality-btn">Save Settings</button>
                    <button id="wipe-data-btn" class="danger-btn">Wipe All Data</button>
                </div>
                <div class="settings-tab-panel" id="settings-tab-usage" data-settings-panel="usage">
                    <div class="usage-section">
                        <div class="usage-card">
                            <div class="usage-header">
                                <span>Chats</span>
                                <span id="usage-chats-label">0 / 50</span>
                            </div>
                            <div class="usage-progress">
                                <div class="usage-progress-bar" id="usage-chats-bar"></div>
                            </div>
                            <div class="usage-reset" id="usage-chats-reset">Full allowance available</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-header">
                                <span>Images</span>
                                <span id="usage-images-label">0 / 20</span>
                            </div>
                            <div class="usage-progress">
                                <div class="usage-progress-bar" id="usage-images-bar"></div>
                            </div>
                            <div class="usage-reset" id="usage-images-reset">Full allowance available</div>
                        </div>
                        <p class="usage-note">Each limit resets automatically every 2 hours. Invite your friends, but pace the magic.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Changelog Modal -->
<div id="changelog-overlay" class="modal-overlay">
    <div id="changelog-modal-content" class="modal-content changelog-modal">
        <button class="close-modal-btn" id="close-changelog-btn">&times;</button>
        <h2>Changelog</h2>
        <div class="modal-subtitle">Latest updates to Graxybot.</div>
        <div class="changelog-body">
        <div class="changelog-list">
            <article class="changelog-entry">
                <div class="changelog-hero">
                    <img src="header2.png" alt="Day 2 header">
                </div>
                <div class="changelog-meta">
                    <span class="changelog-title">12 Days of Graxybot — Day 2</span>
                    <span class="changelog-date">Today</span>
                </div>
                <ul>
                    <li>New web search mode toggle in the + menu so you can fetch fresh answers on demand.</li>
                    <li>Chat now suggests turning on Search when you ask for time-sensitive info (dates, scores, etc.).</li>
                    <li>Refined search prompt to keep replies simple, source-aware, and grounded in live results.</li>
                </ul>
            </article>
            <article class="changelog-entry">
                <div class="changelog-hero">
                    <img src="header.png" alt="Day 1 header">
                </div>
                <div class="changelog-meta">
                    <span class="changelog-title">12 Days of Graxybot — Day 1</span>
                    <span class="changelog-date">Today</span>
                </div>
                <ul>
                    <li>New dark-default UI with blue accent, rounded surfaces, and a light/dark toggle in Settings.</li>
                    <li>Switched image generation to OpenAI <code>gpt-image-1-mini</code> (low quality) via the proxy.</li>
                    <li>Refreshed sidebar (removed desktop download), new chat text color, and cleaned old coachmark.</li>
                    <li>Dynamic header titles that personalize once you set a name; default stays “Graxybot.”</li>
                    <li>Chat input uses the themed background; overall backgrounds respect your selected theme.</li>
                </ul>
            </article>
        </div>
        </div>
    </div>
</div>

<!-- Initial Name Modal -->
<div id="initial-name-overlay" class="modal-overlay">
    <div class="modal-content">
        <h2>hi! what's your name?</h2>
        <p class="modal-subtitle">graxybot likes to keep it personal.</p>
        <input type="text" id="initial-name-input" placeholder="type your name...">
        <button id="initial-name-save-btn">let's chat</button>
    </div>
</div>

<!-- Me Popup -->
<div id="me-popup">
    <div class="me-popup-card">
        <button class="me-popup-close" id="me-popup-close-btn">&times;</button>
        <h2>me mode</h2>
        <p id="me-popup-subtitle">snap a quick pic so graxybot can remix you into anything.</p>

        <div class="me-media-area" id="me-media-area">
            <div class="me-media-preview" id="me-media-preview">
                <span id="me-media-placeholder">no photo yet</span>
                <img id="me-photo-preview" alt="me preview" style="display:none;">
            </div>
            <video id="me-camera-stream" playsinline style="display:none;"></video>
            <canvas id="me-canvas" width="512" height="512" style="display:none;"></canvas>
        </div>

        <div class="me-prompt-area" id="me-prompt-area" style="display:none;">
            <textarea id="me-prompt-input" placeholder="example: put me in a neon cyberpunk world"></textarea>
            <div class="me-hint">graxybot keeps your picture on this device. hit generate to send it with your prompt.</div>
        </div>

        <div class="me-control-row">
            <button id="me-start-camera-btn" class="secondary-btn">open camera</button>
            <button id="me-upload-btn" class="secondary-btn">upload photo</button>
        </div>
        <button id="me-capture-btn" class="primary-btn" style="display:none;">capture photo</button>
        <div class="me-control-row" id="me-retake-row" style="display:none;">
            <button id="me-retake-btn" class="secondary-btn">retake photo</button>
            <button id="me-remove-btn" class="danger-btn">remove photo</button>
        </div>
        <input type="file" id="me-upload-input" accept="image/*" style="display:none;">
    </div>
</div>

<!-- Themes Modal -->
<div id="themes-overlay" class="modal-overlay">
    <div id="themes-modal-content" class="modal-content">
        <button class="close-modal-btn" id="close-themes-modal-btn">&times;</button>
        <h2>Chat Themes</h2>
        
        <div class="theme-options">
            <div class="theme-box" id="grass-theme-box" data-theme="grass">
                <i class="fas fa-leaf theme-icon"></i>
                <span class="theme-name">Grass</span>
            </div>
            <div class="theme-box" id="clouds-theme-box" data-theme="clouds">
                <i class="fas fa-cloud theme-icon"></i>
                <span class="theme-name">Clouds</span>
            </div>
        </div>

        <div id="generate-theme-container">
            <label for="theme-prompt-input">Or generate a custom theme:</label>
            <input type="text" id="theme-prompt-input" placeholder="e.g., a serene mountain lake at dawn">
            <button id="generate-theme-btn">Generate Image</button>
            
            <div id="theme-preview" class="modal-preview-box">
                <div class="spinner modal-spinner" id="theme-spinner"></div>
                <img id="theme-image-preview" src="" alt="Theme preview" style="display: none;"/>
            </div>
        </div>

        <button id="save-theme-btn" class="secondary-btn" disabled>Save Generated Theme</button>
        <button id="remove-theme-btn" class="danger-btn">Remove Theme</button>
    </div>
</div>

<div class="chat-app" id="chat-app">
<div id="launch-popup-overlay" class="launch-popup-overlay">
    <div class="launch-popup">
        <img src="popup.png" alt="Graxybot update">
        <h3>Graxybot can now search the web</h3>
        <p>Toggle Search in the + menu for fresh, accurate answers pulled live.</p>
        <div class="launch-popup-actions">
            <button class="primary" id="launch-popup-changelog-btn">Read Changelog</button>
            <button class="secondary" id="launch-popup-close-btn">Close</button>
        </div>
    </div>
</div>
     <div id="menu-backdrop"></div>
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="new-chat-btn">
                <i class="fas fa-plus"></i> New Chat
            </button>
            <button class="changelog-btn" id="changelog-btn">
                <i class="fas fa-list-alt"></i> Changelog
            </button>
        </div>
        <ul class="chat-list" id="chat-list">
        </ul>
        <div class="sidebar-footer">
            <div class="sidebar-footer-controls">
                <button class="sidebar-footer-link" id="themes-button">
                    <i class="fas fa-palette"></i>
                    <span>Themes</span>
                </button>
                <button class="sidebar-footer-link" id="settings-button">
                    <i class="fas fa-cog"></i>
                    <span>Settings</span>
                </button>
            </div>
        </div>
    </aside>

    <main class="main-content" id="main-content">
        <div id="theme-container"></div>
        <div class="chat-top-bar">
             <button class="icon-btn menu-toggle" id="menu-toggle-btn">
                <i class="fas fa-bars"></i>
            </button>
            <h1 id="chat-title">Graxybot</h1>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <footer class="chat-input-container">
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <button id="remove-image-button" title="Remove image">&times;</button>
            </div>
            <div class="chat-input-area">
                <input type="text" id="message-input" placeholder="Ask me anything...">
                <div id="me-active-banner" class="me-active-banner">
                    <div class="me-active-info">
                        <i class="fas fa-user-astronaut"></i>
                        <span>me photo locked in. type your remix and hit send.</span>
                    </div>
                    <div class="me-active-controls">
                        <button id="me-inline-retake-btn">retake</button>
                        <button id="me-inline-remove-btn">remove</button>
                    </div>
                </div>
                <div class="input-actions">
                    <div class="agent-menu-container">
                        <div class="action-menu" id="agent-menu">
                            <button id="web-design-agent-button" class="icon-btn menu-item menu-item-web-design" title="Web Design Agent"><i class="fas fa-palette"></i><span>Web Design</span></button>
                            <button id="deltamath-agent-button" class="icon-btn menu-item" title="Deltamath Agent (Beta)" disabled><i class="fas fa-calculator"></i><span>Deltamath (Beta)</span></button>
                        </div>
                        <button id="agent-menu-toggle" class="icon-btn" title="Agents"><i class="fas fa-robot"></i><span>Agents</span></button>
                    </div>
                    <div class="web-design-mode-container" id="web-design-mode-container" style="display: none;">
                        <div class="action-menu" id="web-design-mode-menu">
                            <button class="menu-item" id="mode-simple-btn"><i class="fas fa-bolt"></i><span>Simple</span></button>
                            <button class="menu-item" id="mode-pro-btn"><i class="fas fa-star"></i><span>Pro</span></button>
                        </div>
                        <button id="web-design-mode-toggle" class="icon-btn" title="Web Design Mode"><span>Pro</span></button>
                    </div>
                    <div class="action-menu-container">
                        <div class="action-menu" id="action-menu">
                            <button id="create-image-button" class="icon-btn menu-item menu-item-image" title="Create Image"><i class="fas fa-image"></i><span>Create Image</span></button>
                            <button id="image-upload-button" class="icon-btn menu-item menu-item-attach" title="Attach File"><i class="fas fa-paperclip"></i><span>Attach File</span></button>
                            <button id="reddit-story-button" class="icon-btn menu-item menu-item-reddit" title="Generate Reddit Story"><i class="fab fa-reddit-alien"></i><span>Reddit Story</span></button>
                            <button id="mic-button" class="icon-btn menu-item menu-item-mic" title="Voice Mode"><i class="fas fa-microphone"></i><span>Voice Mode</span></button>
                            <button id="search-mode-button" class="icon-btn menu-item menu-item-search" title="Search the Web"><i class="fas fa-globe"></i><span>Search</span></button>
                        </div>
                        <button id="action-menu-toggle" class="icon-btn" title="More Actions"><i class="fas fa-plus"></i></button>
                    </div>
                    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
                    <button id="send-button" class="icon-btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                </div>
            </div>
        </footer>
    </main>
</div>

<div id="story-overlay" class="modal-overlay" style="background-color: black; z-index: 4000;">
    <div id="story-video-container">
        <video id="story-video" playsinline loop muted></video>
    </div>
    <div id="story-captions-container"></div>
    <div id="story-watermark">Graxybot</div>
    <div id="story-outro">
        <div class="outro-line-1">Made with Graxybot</div>
        <div class="outro-line-2">Make your own at Graxybot.com</div>
    </div>
    <button id="download-story-btn" class="icon-btn" title="Download Video"><i class="fas fa-download"></i></button>
    <button id="close-story-btn" class="close-modal-btn">&times;</button>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script type="module">
    // --- Configuration ---
    const GEMINI_CHAT_MODEL = "gemini-2.0-flash";
    const GEMINI_IMAGE_ENDPOINT = window.location.origin + '/gemini/image';
    const OPENAI_CHAT_MODEL = "gpt-4.1-mini";
    const OPENAI_PROXY_ENDPOINT = window.location.origin + '/openai/chat';
    const OPENAI_SEARCH_ENDPOINT = window.location.origin + '/openai/search';
    const GEMINI_CHAT_ENDPOINT = window.location.origin + '/gemini/chat';

    // --- UI & Storage Keys ---
    const DEFAULT_CHAT_MODEL = OPENAI_CHAT_MODEL;
    const BOT_ICON_SRC = "graxybot.png";
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_minimalist_chats_v3";
    const CURRENT_CHAT_ID_KEY = "graxybot_minimalist_current_chat_id_v3";
    const PERSONALITY_STORAGE_KEY = "graxybot_minimalist_personality_v3";
    const THEME_STORAGE_KEY = "graxybot_theme_v1";
    const THEME_MODE_STORAGE_KEY = "graxybot_theme_mode_v1";
    const ME_PROFILE_STORAGE_KEY = "graxybot_me_profile_v1";
    const USAGE_STORAGE_KEY = "graxybot_usage_stats_v1";
    const CHAT_USAGE_LIMIT = 50;
    const IMAGE_USAGE_LIMIT = 20;
    const USAGE_WINDOW_MS = 2 * 60 * 60 * 1000; // two hours rolling window (chat/images)
    const SEARCH_USAGE_WINDOW_MS = 12 * 60 * 60 * 1000; // 12 hours for search
    const SEARCH_USAGE_LIMIT = 5;
    const BACKGROUND_VIDEOS = ['vid1.mp4', 'vid2.mp4', 'vid3.mp4'];

    // --- DOM Element References ---
    let chatApp, chatMessagesContainer, messageInput, chatInputArea, sendButton, createImageButton;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let loader, toastContainer, micButton, speechRecognition, isListening = false;
    let sidebar, newChatBtn, chatList, settingsButton, chatTitle, mainContent, menuBackdrop, menuToggleBtn;
    let personalityOverlay, userNameInput, responseStyleInput, savePersonalityBtn, closePersonalityModalBtn;
    // New Theme elements
    let themesButton, themesOverlay, closeThemesModalBtn, themePromptInput, generateThemeBtn;
    let themePreview, themeSpinner, themeImagePreview, saveThemeBtn, removeThemeBtn, themeContainer;
    let grassThemeBox, cloudsThemeBox;
    let themeModeToggle;
    let meButton, mePopup, mePopupCloseBtn, meStartCameraBtn, meCaptureBtn, meUploadBtn, meUploadInput;
    let meRetakeRow, meRetakeBtn, meRemoveBtn, meMediaPreview, meMediaPlaceholder, mePhotoPreview;
    let mePromptArea, mePromptInput, meSubtitle, meCameraStreamEl, meCanvas;
    let meActiveBanner, meInlineRetakeBtn, meInlineRemoveBtn;
    let webDesignModeContainer, webDesignModeToggle, webDesignModeMenu, modeSimpleBtn, modeProBtn;
    let currentWebDesignMode = 'simple';
    
    let settingsTabButtons = [];
    let settingsTabPanels = [];
    let usageChatsBar, usageChatsLabel, usageChatsReset;
    let usageImagesBar, usageImagesLabel, usageImagesReset;
    
    let actionMenuToggle, actionMenu, actionCoachmark;
    let agentMenuToggle, agentMenu, webDesignAgentButton;
    let searchModeButton;
    let wipeDataBtn;
    let initialNameOverlay, initialNameInput, initialNameSaveBtn;
    let redditStoryButton, storyOverlay, storyVideo, storyCaptionsContainer, closeStoryBtn, downloadStoryBtn;
    let changelogOverlay, changelogBtn, closeChangelogBtn;

    // --- Application State ---
    let chats = {};
    let currentChatId = null;
    let isRequestInProgress = false;
    let isImageGenerationModeActive = false;
    let isWebDesignModeActive = false;
    let currentThinkingIndicatorElement = null;
    let selectedImageData = null, selectedImageMimeType = null, selectedImagePreviewUrl = null;
    let userPersonality = { name: null, responseStyle: null };
    let currentTheme = { type: 'none' }; // e.g., { type: 'grass' }, { type: 'clouds' }, { type: 'generated', data: '...' }
    let generatedThemeData = null; // Holds temporary generated image data
    let currentSpeechUtterance = null;
    let lastStoryVoiceName = null;
    let meProfile = null;
    let meStream = null;
    let meIsCapturing = false;
    let meQuickModeActive = false;
    let usageStats = { chats: [], images: [], searches: [] };
    let usageUpdateInterval = null;
    let coachmarkHideTimeout = null;
    let isSearchModeQueued = false;
    
    // --- Core Functions ---
    function showToast(message, type = 'info', duration = 3000) {
        if (!toastContainer) return;
        const toast = document.createElement('div');
        toast.className = `toast-message ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('show'));
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, duration);
    }
    function applyThemeMode(mode) {
        const normalized = mode === 'light' ? 'light' : 'dark';
        if (normalized === 'light') {
            document.body.classList.add('theme-light');
        } else {
            document.body.classList.remove('theme-light');
        }
        localStorage.setItem(THEME_MODE_STORAGE_KEY, normalized);
        if (themeModeToggle) {
            themeModeToggle.checked = normalized === 'dark';
        }
    }
    function setDynamicChatTitle() {
        if (!chatTitle) return;
        const name = (userPersonality?.name || '').trim();
        if (!name) {
            chatTitle.textContent = 'Graxybot';
            return;
        }
        const roll = Math.random();
        let title = 'Graxybot';
        if (roll < 0.7) {
            title = 'Graxybot';
        } else if (roll < 0.8) {
            title = `how can i help today, ${name}?`;
        } else if (roll < 0.9) {
            title = `hey ${name}`;
        } else {
            title = `how\'s it going, ${name}?`;
        }
        chatTitle.textContent = title;
    }
    function generateChatId() { return `chat_${Date.now()}`; }
    function loadData() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            chats = storedChats ? JSON.parse(storedChats) : {};
            const storedChatId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
            if (storedChatId && chats[storedChatId]) {
                currentChatId = storedChatId;
            } else {
                currentChatId = null;
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
            const storedPersonality = localStorage.getItem(PERSONALITY_STORAGE_KEY);
            if (storedPersonality) userPersonality = JSON.parse(storedPersonality);
            
            const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
            if (storedTheme) {
                currentTheme = JSON.parse(storedTheme);
                applyTheme(currentTheme.type, currentTheme.data);
            }

        } catch (error) {
            console.error("Error loading data:", error);
            chats = {}; currentChatId = null;
        }
    }
    function saveChats() {
        try {
            localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats));
            if (currentChatId) {
                localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId);
            } else {
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
        } catch (e) { console.error("Error saving chats:", e); }
    }
    function savePersonalitySettings() {
        try {
            localStorage.setItem(PERSONALITY_STORAGE_KEY, JSON.stringify(userPersonality));
        } catch (e) { console.error("Error saving personality:", e); }
    }
    function updateActionButtonsState() {
        const isBusy = isRequestInProgress || isListening;
        sendButton.disabled = isBusy || (!messageInput.value.trim() && !selectedImageData);
        imageUploadButton.disabled = isBusy;
        micButton.disabled = isBusy;
        micButton.classList.toggle('active', isListening);
        createImageButton.disabled = isBusy;
        createImageButton.classList.toggle('active', isImageGenerationModeActive);
        if (actionMenuToggle) actionMenuToggle.disabled = isBusy;
        if (agentMenuToggle) agentMenuToggle.disabled = isBusy;
        if (webDesignAgentButton) webDesignAgentButton.disabled = isBusy;
        if (searchModeButton) {
            searchModeButton.disabled = isBusy;
        }
        if (redditStoryButton) redditStoryButton.disabled = isBusy;
        if (meButton) meButton.disabled = isBusy;
        if (meStartCameraBtn) meStartCameraBtn.disabled = isBusy;
        if (meUploadBtn) meUploadBtn.disabled = isBusy;
        if (meCaptureBtn) meCaptureBtn.disabled = isBusy;
        if (meRetakeBtn) meRetakeBtn.disabled = isBusy;
        if (meRemoveBtn) meRemoveBtn.disabled = isBusy;
        if (meInlineRetakeBtn) meInlineRetakeBtn.disabled = isBusy;
        if (meInlineRemoveBtn) meInlineRemoveBtn.disabled = isBusy;
        if (webDesignAgentButton) {
            webDesignAgentButton.disabled = isBusy;
            webDesignAgentButton.classList.toggle('active', isWebDesignModeActive);
        }
        settingsButton.disabled = isBusy;
        themesButton.disabled = isBusy;
        if (chatInputArea) {
            const highlightImageActive = isImageGenerationModeActive && !isBusy;
            const highlightWebActive = isWebDesignModeActive && !isBusy;
            chatInputArea.classList.toggle('image-mode-active', highlightImageActive);
            chatInputArea.classList.toggle('web-design-mode-active', highlightWebActive);
            chatInputArea.classList.toggle('image-mode-busy', (isImageGenerationModeActive || isWebDesignModeActive) && isBusy);
        }
        updateSearchModeUI();
    }
    function refreshInputPlaceholder() {
        if (!messageInput || meQuickModeActive) return;
        if (isImageGenerationModeActive) {
            messageInput.placeholder = "Enter image prompt...";
            return;
        }
        if (isWebDesignModeActive) {
            messageInput.placeholder = "Describe the website you want...";
            return;
        }
        if (isSearchModeQueued) {
            messageInput.placeholder = "What should I search for?";
            return;
        }
        messageInput.placeholder = "Ask me anything...";
    }
    function updateSearchModeUI() {
        if (searchModeButton) {
            searchModeButton.classList.toggle('active', isSearchModeQueued);
        }
        if (chatInputArea) {
            const busy = isRequestInProgress || isListening;
            chatInputArea.classList.toggle('search-mode-armed', isSearchModeQueued && !busy);
        }
        refreshInputPlaceholder();
    }
    function getSystemPrompt(currentModelName, isRedditStory = false) {
        let basePrompt = `You are Graxybot, a helpful AI assistant.\n You are currently running on the ${currentModelName} model.\n Your creator is 'thegraxisreal'.`;

        if (isRedditStory) {
            basePrompt += `
 IMPORTANT: You are a master storyteller. Generate a compelling, first-person story in the style of a Reddit post. The story should have a clear beginning, a build-up of suspense or drama, and a satisfying conclusion or twist. It must be engaging and suitable for a voiceover. CRITICAL FORMATTING RULE: To ensure a natural-sounding voiceover, break the story into lines of approximately 5 to 7 words each. However, you MUST insert the newline character (
) ONLY at the end of a complete sentence or at a natural pause point in a sentence (like after a comma). This means a line might occasionally be shorter or longer to respect grammatical structure. Do NOT break lines in the middle of a phrase. Do NOT include any introductory phrases like "Okay, here's a story for you:". Start directly with the story content.`;
        } else {
            basePrompt += `\n IMPORTANT: When answering any questions about Global history or geography, or solving social studies homework sheets, all answers should be 1 or 2 words, formatted in all lowercase, with absolutely no restating of the question.\n When receiving said social studies sheets, questions 1-5 should be answered in 1 or 2 words in all lowercase, and the ending questions that are longer should be answered in 1 or 2 sentences, all at a 9th-grade level for those problems.\n Those restrictions only apply to global history questions. All other questions should be answered in lowercase and at a normal level.\n Provide only the final answer, without revealing your internal thought process or reasoning steps unless explicitly asked to explain.\n Keep your responses concise, helpful, and slightly informal.\n Refer to yourself as Graxybot.\n IMPORTANT: If the user asks you to generate an image or video/animation, let them know they can do that by pressing the buttons at the bottom of the screen, BUT if their prompt seems to ask directly for an image (e.g., \'draw a cat\'), you should fulfill that request directly instead of referring them to the buttons.\n When asked for code, default to HTML.\n When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\``;
        }

        if (userPersonality.name) {
             basePrompt += `\n Address the user as "${userPersonality.name}".`;
        }
        if(userPersonality.responseStyle){
            basePrompt += `\n Follow these response style instructions: "${userPersonality.responseStyle}"`;
        }
        basePrompt += `\n If you are about to say you lack real-time or up-to-date information, invite the user to search the web via the + menu in the chat bar.`;
        return basePrompt;
    }
    function getSearchSystemPrompt() {
        return [
            "You are Graxybot, operating in live web search mode using model gpt-5.1.",
            "You MUST call the web_search tool before answering every request.",
            "Ground answers only on what the search returns; do not rely on stale training data or say you lack real-time access.",
            "Keep responses concise, casual, and in simple plain language with short sentences. If useful, include brief source hints like (nasa.gov)."
        ].join("\\n");
    }

    function getWebDesignSystemPrompt(mode = 'pro') {
        const styles = [
            "Minimalism (lots of whitespace, clean sans-serif fonts, limited color palette)",
            "Neo-Brutalism (high contrast, bold borders, harsh shadows, monospaced fonts, vibrant clashy colors)",
            "Glassmorphism (translucent frosted glass effects, vivid background blobs, light borders)",
            "Retro 90s/Y2K (pixel fonts, neon green/pink, terminal aesthetic, glitch effects)",
            "Skeuomorphism (realistic textures, depths, shadows, physical-feeling elements)",
            "Typographic/Editorial (massive text, focus on layout and font pairing, magazine style)",
            "Dark Mode Cyberpunk (neon glows, dark backgrounds, futuristic tech feel)",
            "Paper/Collage (torn paper edges, grainy textures, hand-drawn elements)",
            "Bauhaus (geometric shapes, primary colors, diagonal layouts)",
            "Soft UI / Neumorphism (soft shadows, elements extruded from background, rounded corners)"
        ];
        
        const selectedStyle = styles[Math.floor(Math.random() * styles.length)];

        const lengthConstraint = mode === 'simple' 
            ? "Keep code concise and under 300 lines (approx 7k tokens) for speed."
            : "Keep code clean and strictly under 10,000 tokens (approx. 400-500 lines of high-quality code).";

        return `You are the "Visionary Web Design Agent," a world-class UI/UX developer famous on Awwwards and Dribbble for creating visually stunning, high-impact single-page websites.

Your goal is to take a user's concept and translate it into a single, self-contained HTML5 file. You must strictly adhere to the following directives:

### 1. MANDATORY VISUAL STYLE
**You MUST use the following design aesthetic for this specific request:**
👉 **${selectedStyle}** 👈

Do NOT deviate from this style. Commit to it 100%. If it says colorful, make it colorful. If it says minimal, make it minimal.

### 2. VISUALS FIRST, TEXT LAST
* **The Anti-Essay Rule:** You are allergic to long text. Never generate paragraphs longer than 2 sentences.
* **Visual Hierarchy:** Use text primarily as a design element (massive headlines, typographic textures).
* **Content:** Use punchy, marketing-style copy (e.g., "Taste the Future," "Create," "Bold Moves").
* **Layout:** Prioritize generous whitespace (padding/margins). If the page feels crowded, delete text.
* **Imagery:** Use high-quality placeholder images (e.g., unsplash source URLs) heavily.

### 3. TECHNICAL CONSTRAINTS
* **Single File:** Output valid HTML5 with embedded CSS (\`<style>\`) and JS (\`<script>\`).
* **No External Frameworks:** Do not use Bootstrap, Tailwind, or jQuery. Write pure, efficient vanilla CSS and JS.
* **Assets:** You may import Google Fonts and FontAwesome (via CDN).
* **Efficiency:** ${lengthConstraint} Use CSS Grid and Flexbox efficiently.
* **Micro-interactions:** You must include hover states, smooth transitions, and at least one creative interaction (e.g., a reveal on scroll or a dynamic cursor).

### 4. OUTPUT FORMAT
* Do not speak to the user.
* Do not explain the code.
* Do not explicitly state which aesthetic you chose.
* Output ONLY the single Markdown code block containing the HTML code.

### 5. DESIGN EXECUTION
* If the style is **Neo-Brutalism**: Use high contrast, heavy strokes, stark shadows, and monospaced fonts.
* If the style is **Glassmorphism**: Use backdrop-filters, transparency, and soft gradients.
* If the style is **Minimalism**: Use extreme whitespace and simple sans-serif typography.
* (Apply similar specific design logic to whichever style you select).

**INPUT:** A user idea.
**OUTPUT:** A single HTML file representing a high-end, Dribbble-quality interpretation of that idea.`;
    }
    function addMessageToHistory(role, contentParts, imagePreview = null, generatedMediaSrc = null, mediaPrompt = null, extraData = null) {
       if (!currentChatId) { handleNewChat(false); }
       if (!chats[currentChatId]) return;
       if (role === 'user' && chats[currentChatId].history.length === 0) {
           const firstText = contentParts.find(p => p.text)?.text;
           chats[currentChatId].title = firstText ? firstText.substring(0, 30) : "New Chat";
           renderChatList();
       }
       const messageData = { role, parts: contentParts, timestamp: new Date().toISOString() };
       if (imagePreview) messageData.imagePreview = imagePreview;
       if (generatedMediaSrc) {
           messageData.generatedMediaSrc = generatedMediaSrc;
           messageData.mediaPrompt = mediaPrompt;
       }
       if (extraData) {
           messageData.extraData = extraData;
       }
       chats[currentChatId].history.push(messageData);
       saveChats();
    }
    function showThinkingIndicator(message = 'Thinking...', iconClass = 'fa-brain') {
        removeThinkingIndicator();
        currentThinkingIndicatorElement = displayMessage([], 'bot-thinking', false, null, null, iconClass, message);
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.classList.add('thinking-indicator');
            const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
            if (msgDiv) msgDiv.innerHTML = `<span></span><span></span><span></span> ${message}`;
        }
    }
    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.remove();
            currentThinkingIndicatorElement = null;
        }
    }
    function displayMessage(contentParts, sender, isError = false, imagePreview = null, generatedMediaSrc = null, customIconClass = null, mediaPrompt = null, extraData = null) {
        const usingMeQuickMode = meQuickModeActive && meProfile && meProfile.imageData;

        setChatActiveState(false);
        const wrapper = document.createElement('div');
        wrapper.className = 'message-content-wrapper';
        if (sender === 'user') wrapper.classList.add('user-message');
        const iconDiv = document.createElement('div');
        iconDiv.className = 'message-icon';
        if (sender === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else {
            if (customIconClass) {
                 iconDiv.innerHTML = `<i class="fas ${customIconClass}"></i>`;
            } else {
                const img = document.createElement('img');
                img.src = BOT_ICON_SRC;
                img.alt = "G";
                img.onerror = () => iconDiv.innerHTML = `<i class="fas fa-robot"></i>`;
                iconDiv.appendChild(img);
            }
        }
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        if (isError) messageDiv.classList.add('error-message');
        const paragraph = document.createElement('p');
        paragraph.dataset.streamTarget = "true";
        let textContent = Array.isArray(contentParts) ? (contentParts.find(p => p.text)?.text || '') : '';
        
        if (extraData && extraData.type === 'web_design' && extraData.html) {
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.alignItems = 'flex-start';
            container.style.gap = '8px';

            const viewButton = document.createElement('button');
            // Style similar to me-active-controls buttons
            viewButton.style.background = 'transparent';
            viewButton.style.border = '1px solid rgba(255, 193, 7, 0.5)';
            viewButton.style.color = 'var(--text-primary)';
            viewButton.style.padding = '8px 16px';
            viewButton.style.borderRadius = '8px';
            viewButton.style.fontWeight = '600';
            viewButton.style.cursor = 'pointer';
            viewButton.style.display = 'inline-flex';
            viewButton.style.alignItems = 'center';
            viewButton.style.gap = '8px';
            viewButton.style.transition = 'all 0.2s ease';
            
            viewButton.innerHTML = '<i class="fas fa-external-link-alt" style="color: #FFC107;"></i> View Site';
            
            viewButton.onmouseover = () => {
                viewButton.style.background = 'rgba(255, 193, 7, 0.15)';
            };
            viewButton.onmouseout = () => {
                viewButton.style.background = 'transparent';
            };

            viewButton.onclick = () => {
                const blob = new Blob([extraData.html], {type: 'text/html'});
                const url = URL.createObjectURL(blob);
                window.open(url, '_blank');
            };
            
            container.appendChild(viewButton);

            if (extraData.stats) {
                const statsLine = document.createElement('div');
                statsLine.style.fontSize = '0.75rem';
                statsLine.style.color = 'var(--text-secondary)';
                statsLine.style.marginLeft = '4px';
                statsLine.textContent = `${extraData.stats.lines} lines generated in ${extraData.stats.time}s`;
                container.appendChild(statsLine);
            }

            messageDiv.appendChild(container);
        } else {
            if (generatedMediaSrc) {
                const media = document.createElement('img');
                media.src = generatedMediaSrc; media.className = 'generated-image';
                messageDiv.appendChild(media);
                if (mediaPrompt) paragraph.innerHTML = `<em>Prompt: ${mediaPrompt}</em>`;
            } else if (imagePreview) {
                const img = document.createElement('img');
                img.src = imagePreview; img.className = 'sent-image';
                messageDiv.appendChild(img);
            }
            if (textContent) processAndAppendText(textContent, paragraph);
            if (paragraph.hasChildNodes() || paragraph.textContent || sender === 'bot') {
                messageDiv.appendChild(paragraph);
            }
        }

        bubbleDiv.appendChild(messageDiv);
        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);
        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
        return wrapper;
    }
    
    function processAndAppendText(text, targetElement, shouldHighlight = true) {
        targetElement.innerHTML = '';
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;

        while ((match = codeBlockRegex.exec(text)) !== null) {
            const precedingText = text.substring(lastIndex, match.index);
            if (precedingText) {
                const textSpan = document.createElement('span');
                textSpan.innerHTML = precedingText.replace(/\n/g, '<br>');
                targetElement.appendChild(textSpan);
            }

            const lang = match[1]?.trim().toLowerCase() || 'plaintext';
            const code = match[2].trim();
            
            const codeContainer = document.createElement('div');
            codeContainer.className = 'code-block-container';

            const header = document.createElement('div');
            header.className = 'code-block-header';

            const langSpan = document.createElement('span');
            langSpan.textContent = lang;

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'code-block-buttons';

            if (lang === 'html') {
                const runButton = document.createElement('button');
                runButton.innerHTML = '<i class="fas fa-play"></i> Run';
                runButton.title = 'Run Code';
                runButton.onclick = () => handleRunCode(code);
                buttonContainer.appendChild(runButton);
            }

            const copyButton = document.createElement('button');
            copyButton.innerHTML = '<i class="fas fa-copy"></i> Copy';
            copyButton.title = 'Copy Code';
            copyButton.onclick = (e) => handleCopyCode(code, e.currentTarget);
            buttonContainer.appendChild(copyButton);
            
            header.appendChild(langSpan);
            header.appendChild(buttonContainer);

            const pre = document.createElement('pre');
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;

            pre.appendChild(codeEl);
            codeContainer.appendChild(header);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            
            lastIndex = codeBlockRegex.lastIndex;
        }

        const remainingText = text.substring(lastIndex);
        if (remainingText) {
            const textSpan = document.createElement('span');
            textSpan.innerHTML = remainingText.replace(/\n/g, '<br>');
            targetElement.appendChild(textSpan);
        }

        if (shouldHighlight && window.Prism) {
            setTimeout(() => Prism.highlightAllUnder(targetElement), 0);
        }
    }

    function handleCopyCode(codeContent, buttonElement) {
        navigator.clipboard.writeText(codeContent).then(() => {
            showToast("Code copied!", 'success');
            buttonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
            setTimeout(() => { 
                buttonElement.innerHTML = '<i class="fas fa-copy"></i> Copy';
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            showToast("Failed to copy code.", 'error');
        });
    }

    function handleRunCode(codeContent) {
        try {
            const newWindow = window.open('', '_blank');
            if (newWindow) {
                newWindow.document.open();
                newWindow.document.write(codeContent);
                newWindow.document.close();
            } else {
                showToast("Please allow pop-ups to run code.", 'error');
            }
        } catch (e) {
             showToast("Error opening window. Check pop-up blocker.", 'error');
             console.error("Error running code:", e);
        }
    }

    function renderChatList() {
        chatList.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a,b) => (chats[b].history[0]?.timestamp || 0) - (chats[a].history[0]?.timestamp || 0));
        sortedChatIds.forEach(id => {
            const li = document.createElement('li');
            li.className = 'chat-list-item';
            li.dataset.chatId = id;
            li.textContent = chats[id].title || 'Chat';
            if (id === currentChatId) li.classList.add('active');
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteChat(id); };
            li.appendChild(deleteBtn);
            li.onclick = () => handleSelectChat(id);
            chatList.appendChild(li);
        });
    }
    function loadChat(chatId) {
        if (!chats[chatId]) return;
        currentChatId = chatId;
        saveChats();
        renderChatList();
        chatMessagesContainer.innerHTML = '';
        const hasHistory = chats[chatId].history.length > 0;
        setChatActiveState(!hasHistory);
        if (hasHistory) {
            chats[chatId].history.forEach(msg => {
                displayMessage(msg.parts, msg.role, false, msg.imagePreview, msg.generatedMediaSrc, null, msg.mediaPrompt, msg.extraData);
            });
        }
    }
    function handleNewChat(clearUI = true) {
        const newId = generateChatId();
        chats[newId] = { history: [], title: "New Chat" };
        currentChatId = newId;
        saveChats();
        renderChatList();
        if (clearUI) {
            chatMessagesContainer.innerHTML = '';
            setChatActiveState(true);
            deactivateMeQuickMode();
        }
    }
    function handleSelectChat(id) {
        if (id === currentChatId) return;
        sidebar.classList.remove('visible');
        menuBackdrop.classList.remove('visible');
        loadChat(id);
        deactivateMeQuickMode();
    }
    function handleDeleteChat(id) {
        if (confirm(`Are you sure you want to delete "${chats[id].title}"?`)) {
            delete chats[id];
            if (currentChatId === id) {
                currentChatId = null;
                chatMessagesContainer.innerHTML = '';
                setChatActiveState(true);
                deactivateMeQuickMode();
            }
            saveChats();
            renderChatList();
        }
    }
    
    function setChatActiveState(isActive) {
        if (isActive) {
            mainContent.classList.add('initial-view');
        } else {
            mainContent.classList.remove('initial-view');
        }
    }

    async function handleImageSelection(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            showToast("Invalid image file type.", 'error'); return;
        }
        try {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                selectedImageData = reader.result.split(',')[1];
                selectedImageMimeType = file.type;
                selectedImagePreviewUrl = URL.createObjectURL(file);
                imagePreview.src = selectedImagePreviewUrl;
                imagePreviewArea.style.display = 'block';
                updateActionButtonsState();
            };
            reader.onerror = () => { throw new Error("File could not be read.");};
        } catch (e) {
            showToast("Error processing image.", 'error');
            removeSelectedImage();
        }
    }
    function removeSelectedImage() {
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) URL.revokeObjectURL(selectedImagePreviewUrl);
        selectedImagePreviewUrl = null;
        imagePreviewArea.style.display = 'none';
        imageUploadInput.value = '';
        updateActionButtonsState();
    }

    // --- Usage Tracking ---
    function loadUsageStats() {
        try {
            const stored = localStorage.getItem(USAGE_STORAGE_KEY);
            if (stored) {
                const parsed = JSON.parse(stored);
                usageStats = {
                    chats: Array.isArray(parsed?.chats) ? parsed.chats : [],
                    images: Array.isArray(parsed?.images) ? parsed.images : [],
                    searches: Array.isArray(parsed?.searches) ? parsed.searches : []
                };
            } else {
                usageStats = { chats: [], images: [], searches: [] };
            }
        } catch (error) {
            console.error("Error loading usage stats:", error);
            usageStats = { chats: [], images: [], searches: [] };
        }
        pruneUsageStats();
    }

    function saveUsageStats() {
        try {
            localStorage.setItem(USAGE_STORAGE_KEY, JSON.stringify(usageStats));
        } catch (error) {
            console.error("Error saving usage stats:", error);
        }
    }

    function pruneUsageStats(save = true) {
        const now = Date.now();
        const types = ['chats', 'images', 'searches'];
        types.forEach(type => {
            const { windowMs } = getUsageConfig(type);
            usageStats[type] = (usageStats[type] || []).filter(ts => now - ts < windowMs);
        });
        if (save) saveUsageStats();
    }

    function getUsageConfig(type) {
        if (type === 'images') return { limit: IMAGE_USAGE_LIMIT, windowMs: USAGE_WINDOW_MS };
        if (type === 'searches') return { limit: SEARCH_USAGE_LIMIT, windowMs: SEARCH_USAGE_WINDOW_MS };
        return { limit: CHAT_USAGE_LIMIT, windowMs: USAGE_WINDOW_MS };
    }

    function getUsageStatus(type) {
        const { limit, windowMs } = getUsageConfig(type);
        const list = usageStats[type] || [];
        const now = Date.now();
        const count = list.length;
        let remainingMs = windowMs;
        if (count > 0) {
            const oldest = Math.min(...list);
            remainingMs = Math.max(0, windowMs - (now - oldest));
        }
        return { count, limit, remainingMs };
    }

    function tryConsumeUsage(type) {
        pruneUsageStats(false);
        const { limit, windowMs } = getUsageConfig(type);
        usageStats[type] = usageStats[type] || [];
        const list = usageStats[type];
        if (list.length >= limit) {
            const oldest = Math.min(...list);
            const remainingMs = Math.max(0, windowMs - (Date.now() - oldest));
            saveUsageStats();
            return { success: false, remainingMs };
        }
        list.push(Date.now());
        saveUsageStats();
        updateUsageUI();
        return { success: true, remainingMs: 0 };
    }

    function formatDuration(ms) {
        if (!ms || ms <= 0) return 'a few moments';
        const totalSeconds = Math.ceil(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        if (hours > 0 && minutes > 0) return `${hours}h ${minutes}m`;
        if (hours > 0) return `${hours}h`;
        return `${Math.max(minutes, 1)}m`;
    }

    function updateUsageUI() {
        pruneUsageStats(false);
        const chatStatus = getUsageStatus('chats');
        const imageStatus = getUsageStatus('images');

        if (usageChatsLabel) usageChatsLabel.textContent = `${chatStatus.count} / ${chatStatus.limit}`;
        if (usageImagesLabel) usageImagesLabel.textContent = `${imageStatus.count} / ${imageStatus.limit}`;

        const chatPercent = chatStatus.limit ? Math.min(100, (chatStatus.count / chatStatus.limit) * 100) : 0;
        const imagePercent = imageStatus.limit ? Math.min(100, (imageStatus.count / imageStatus.limit) * 100) : 0;

        if (usageChatsBar) {
            usageChatsBar.style.width = `${chatPercent}%`;
            usageChatsBar.classList.toggle('at-limit', chatStatus.count >= chatStatus.limit);
        }
        if (usageImagesBar) {
            usageImagesBar.style.width = `${imagePercent}%`;
            usageImagesBar.classList.toggle('at-limit', imageStatus.count >= imageStatus.limit);
        }

        if (usageChatsReset) {
            usageChatsReset.textContent = chatStatus.count
                ? `Resets in ${formatDuration(chatStatus.remainingMs)}`
                : 'Full allowance available';
        }
        if (usageImagesReset) {
            usageImagesReset.textContent = imageStatus.count
                ? `Resets in ${formatDuration(imageStatus.remainingMs)}`
                : 'Full allowance available';
        }
    }

    function showActionCoachmark() {
        if (!actionCoachmark) return;
        actionCoachmark.classList.add('visible');
        if (coachmarkHideTimeout) {
            clearTimeout(coachmarkHideTimeout);
        }
        coachmarkHideTimeout = setTimeout(() => hideActionCoachmark(true), 5000);
    }

    function hideActionCoachmark(removeNode = false) {
        if (!actionCoachmark) return;
        actionCoachmark.classList.remove('visible');
        if (coachmarkHideTimeout) {
            clearTimeout(coachmarkHideTimeout);
            coachmarkHideTimeout = null;
        }
        if (removeNode) {
            setTimeout(() => {
                actionCoachmark?.remove();
                actionCoachmark = null;
            }, 400);
        }
    }

    function activateSettingsTab(tabId = 'profile') {
        if (!settingsTabButtons || !settingsTabPanels) return;
        settingsTabButtons.forEach(btn => {
            if (!btn) return;
            btn.classList.toggle('active', btn.dataset.settingsTab === tabId);
        });
        settingsTabPanels.forEach(panel => {
            if (!panel) return;
            panel.classList.toggle('active', panel.dataset.settingsPanel === tabId);
        });
        if (tabId === 'usage') {
            updateUsageUI();
        }
    }

    function saveMeProfile() {
        try {
            if (meProfile && meProfile.imageData) {
                localStorage.setItem(ME_PROFILE_STORAGE_KEY, JSON.stringify(meProfile));
            } else {
                localStorage.removeItem(ME_PROFILE_STORAGE_KEY);
            }
        } catch (error) {
            console.error("Error saving me profile:", error);
        }
    }

    function loadMeProfileFromStorage() {
        try {
            const stored = localStorage.getItem(ME_PROFILE_STORAGE_KEY);
            meProfile = stored ? JSON.parse(stored) : null;
        } catch (error) {
            console.error("Error loading me profile:", error);
            meProfile = null;
        }
        updateMePopupUI();
    }

    function activateMeQuickMode(focusInput = true) {
        meQuickModeActive = true;
        if (messageInput) {
            if (!messageInput.dataset.prevPlaceholder) {
                messageInput.dataset.prevPlaceholder = messageInput.placeholder;
            }
            messageInput.placeholder = "describe your remix...";
            messageInput.classList.add('me-input-highlight');
            if (focusInput) {
                setTimeout(() => messageInput.focus(), 0);
            }
        }
        if (meActiveBanner) {
            meActiveBanner.style.display = 'flex';
        }
        showToast("me photo ready. type your remix and hit send.", "info", 2200);
        updateActionButtonsState();
    }

    function deactivateMeQuickMode() {
        meQuickModeActive = false;
        if (messageInput) {
            messageInput.classList.remove('me-input-highlight');
        }
        if (messageInput && messageInput.dataset.prevPlaceholder) {
            delete messageInput.dataset.prevPlaceholder;
        }
        refreshInputPlaceholder();
        if (meActiveBanner) {
            meActiveBanner.style.display = 'none';
        }
        updateActionButtonsState();
    }

    function updateMePopupUI() {
        if (!mePopup || !meMediaPreview || !meMediaPlaceholder || !mePhotoPreview || !meRetakeRow || !meRetakeBtn || !meRemoveBtn || !meStartCameraBtn || !meUploadBtn || !meSubtitle) return;
        const hasPhoto = meProfile && meProfile.imageData;
        const placeholder = meMediaPlaceholder;
        const photoImg = mePhotoPreview;

        if (!meIsCapturing) {
            meCameraStreamEl.style.display = 'none';
            meCaptureBtn.style.display = 'none';
        }

        if (hasPhoto) {
            const dataUrl = `data:${meProfile.mimeType || 'image/png'};base64,${meProfile.imageData}`;
            photoImg.src = dataUrl;
            photoImg.style.display = 'block';
            photoImg.classList.add('has-photo');
            placeholder.style.display = 'none';
            meMediaPreview.style.display = 'flex';
            meMediaPreview.classList.add('clickable');
            if (meRetakeRow) {
                meRetakeRow.style.display = 'flex';
                requestAnimationFrame(() => meRetakeRow.classList.add('visible'));
            }
            meRetakeBtn.style.display = 'block';
            meRemoveBtn.style.display = 'block';
            meStartCameraBtn.style.display = 'none';
            meUploadBtn.style.display = 'none';
            meSubtitle.textContent = "ready when you are. describe what you want graxybot to make.";
        } else {
            if (!meIsCapturing) {
                photoImg.style.display = 'none';
                photoImg.classList.remove('has-photo');
                placeholder.style.display = 'block';
                meMediaPreview.style.display = 'flex';
                meMediaPreview.classList.remove('clickable');
                mePromptArea.style.display = 'none';
                if (meRetakeRow) {
                    meRetakeRow.classList.remove('visible');
                    setTimeout(() => {
                        if (meRetakeRow && !meRetakeRow.classList.contains('visible')) {
                            meRetakeRow.style.display = 'none';
                        }
                    }, 200);
                }
                meRetakeBtn.style.display = 'none';
                meRemoveBtn.style.display = 'none';
                meStartCameraBtn.style.display = 'block';
                meUploadBtn.style.display = 'block';
                meSubtitle.textContent = "snap a quick pic so graxybot can remix you into anything.";
                mePromptInput.value = '';
            }
        }
    }

    function showMePopup() {
        if (!mePopup) return;
        mePopup.classList.add('visible');
        updateMePopupUI();
        if (mePromptInput && meProfile && meProfile.imageData) {
            setTimeout(() => mePromptInput.focus(), 0);
        }
    }

    function hideMePopup() {
        if (!mePopup) return;
        mePopup.classList.remove('visible');
        stopMeCamera();
    }

    async function startMeCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showToast("camera not supported, try uploading a photo.", "error");
            return;
        }
        try {
            meStream = await navigator.mediaDevices.getUserMedia({ video: { width: 720, height: 720 } });
            meCameraStreamEl.srcObject = meStream;
            await meCameraStreamEl.play();
            meIsCapturing = true;
            meCameraStreamEl.style.display = 'block';
            meMediaPreview.style.display = 'none';
            meCaptureBtn.style.display = 'block';
            meStartCameraBtn.style.display = 'none';
            meUploadBtn.style.display = 'none';
            mePromptArea.style.display = 'none';
            meRetakeBtn.style.display = 'none';
            if (meRetakeRow) {
                meRetakeRow.style.display = 'none';
                meRetakeRow.classList.remove('visible');
            }
            if (meRemoveBtn) meRemoveBtn.style.display = 'none';
            meSubtitle.textContent = "line up your face and tap capture.";
        } catch (error) {
            console.error("camera error:", error);
            showToast("couldn't open camera, try uploading instead.", "error");
            stopMeCamera();
        }
    }

    function stopMeCamera() {
        if (meStream) {
            meStream.getTracks().forEach(track => track.stop());
            meStream = null;
        }
        meIsCapturing = false;
        if (meCameraStreamEl) {
            meCameraStreamEl.pause();
            meCameraStreamEl.style.display = 'none';
            meCameraStreamEl.srcObject = null;
        }
        meCaptureBtn.style.display = 'none';
        meUploadBtn.style.display = 'block';
        meStartCameraBtn.style.display = meProfile && meProfile.imageData ? 'none' : 'block';
        updateMePopupUI();
    }

    function handleMeCapture() {
        if (!meIsCapturing) return;
        const video = meCameraStreamEl;
        if (!video.videoWidth || !video.videoHeight) {
            showToast("camera still warming up. try again.", "error");
            return;
        }
        const canvas = meCanvas;
        const ctx = canvas.getContext('2d');
        const size = Math.min(video.videoWidth, video.videoHeight);
        const sx = (video.videoWidth - size) / 2;
        const sy = (video.videoHeight - size) / 2;
        ctx.drawImage(video, sx, sy, size, size, 0, 0, canvas.width, canvas.height);
        const dataUrl = canvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1];
        meProfile = {
            imageData: base64,
            mimeType: 'image/png',
            updatedAt: new Date().toISOString()
        };
        saveMeProfile();
        stopMeCamera();
        hideMePopup();
        activateMeQuickMode();
        showToast("me photo saved! type your remix and hit send.", "success", 2500);
    }

    function handleMeUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            showToast("unsupported image type.", "error");
            return;
        }
        const reader = new FileReader();
        reader.onload = () => {
            const result = reader.result;
            const base64 = result.split(',')[1];
            meProfile = {
                imageData: base64,
                mimeType: file.type,
                updatedAt: new Date().toISOString()
            };
            saveMeProfile();
            hideMePopup();
            activateMeQuickMode();
            showToast("me photo saved! type your remix and hit send.", "success", 2500);
            meUploadInput.value = '';
        };
        reader.onerror = () => {
            showToast("couldn't read that photo.", "error");
        };
        reader.readAsDataURL(file);
    }

    async function handleMeGenerate() {
        if (!meProfile || !meProfile.imageData) {
            showToast("grab or upload a photo first.", "error");
            return;
        }
        hideMePopup();
        activateMeQuickMode();
        showToast("me mode ready. type your remix!", "info", 2000);
    }

    function handleMeRemove() {
        meProfile = null;
        saveMeProfile();
        mePromptInput.value = '';
        updateMePopupUI();
        deactivateMeQuickMode();
    }
    
    function isImageGenerationRequest(prompt) {
        const lowercasedPrompt = prompt.toLowerCase();
        const keywords = [
            'draw', 'paint', 'sketch', 'illustrate', 'generate an image', 
            'make an image', 'create an image', 'show me a picture', 'make a picture',
            'create a picture'
        ];
        return keywords.some(keyword => lowercasedPrompt.includes(keyword));
    }

    function randomVividColor() {
        const hue = Math.floor(Math.random() * 360);
        const saturation = 60 + Math.random() * 20;
        const lightness = 45 + Math.random() * 10;
        return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }
    function isLikelyFreshInfoQuery(text = '') {
        const lower = text.toLowerCase();
        const keywords = [
            'today', 'yesterday', 'tonight', 'current', 'latest', 'breaking', 'live',
            'date', 'time', 'day', 'month', 'year', 'now',
            'score', 'final score', 'game', 'match', 'weather', 'forecast', 'stock', 'price',
            'launched', 'released', 'release date', 'earnings', 'who won', 'win', 'loss'
        ];
        return keywords.some(k => lower.includes(k));
    }

    function buildSwirlGradient() {
        const colors = [randomVividColor(), randomVividColor(), randomVividColor()];
        const start = Math.floor(Math.random() * 360);
        return `conic-gradient(from ${start}deg, ${colors[0]}, ${colors[1]}, ${colors[2]}, ${colors[0]})`;
    }

    function truncatePromptText(text, maxLength = 68) {
        if (!text) return '';
        const trimmed = text.trim();
        if (trimmed.length <= maxLength) return trimmed;
        return `${trimmed.substring(0, maxLength - 1)}…`;
    }

    function showImageGenerationProgress(promptText = '') {
        removeThinkingIndicator();
        const wrapper = displayMessage([], 'bot', false, null, null, 'fa-palette');
        if (!wrapper) return null;
        wrapper.classList.add('image-build-message');
        const messageDiv = wrapper.querySelector('.message');
        if (messageDiv) {
            messageDiv.innerHTML = '';
            const preview = document.createElement('div');
            preview.className = 'image-build-preview';

            const swatch = document.createElement('div');
            swatch.className = 'image-build-swatch';
            swatch.style.background = buildSwirlGradient();
            swatch.style.animationDelay = `${(Math.random() * 1.4).toFixed(2)}s`;
            preview.appendChild(swatch);

            const glow = document.createElement('div');
            glow.className = 'image-build-glow';
            glow.style.animationDelay = `${(Math.random() * 1.2).toFixed(2)}s`;
            preview.appendChild(glow);

            messageDiv.appendChild(preview);

            const caption = document.createElement('div');
            caption.className = 'image-build-caption';
            const title = document.createElement('strong');
            title.textContent = 'graxybot is painting…';
            caption.appendChild(title);
            const trimmedPrompt = truncatePromptText(promptText);
            if (trimmedPrompt) {
                const promptLine = document.createElement('span');
                promptLine.className = 'caption-prompt';
                promptLine.textContent = `“${trimmedPrompt}”`;
                caption.appendChild(promptLine);
            } else {
                const promptLine = document.createElement('span');
                promptLine.className = 'caption-prompt';
                promptLine.textContent = 'dreaming something vivid for you';
                caption.appendChild(promptLine);
            }
            messageDiv.appendChild(caption);
        }
        currentThinkingIndicatorElement = wrapper;
        return wrapper;
    }

    async function triggerGeminiImageGeneration(promptText, isForTheme = false, referenceImage = null) {
        if (!isForTheme) {
            hideActionCoachmark(true);
            showImageGenerationProgress(promptText);
        }
        isRequestInProgress = true; 
        if(!isForTheme) updateActionButtonsState();

        const payload = { prompt: promptText };
        if (referenceImage && referenceImage.imageData) {
            payload.referenceImage = {
                data: referenceImage.imageData,
                mimeType: referenceImage.mimeType || 'image/png'
            };
        }
        try {
            const response = await fetch(GEMINI_IMAGE_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const responseText = await response.text();
            if(!isForTheme) removeThinkingIndicator();
            let parsedData = null;
            if (responseText) {
                try {
                    parsedData = JSON.parse(responseText);
                } catch (err) {
                    parsedData = null;
                }
            }
            if (!response.ok) {
                let errorMessage = `API error ${response.status}`;
                if (parsedData?.message) {
                    errorMessage = parsedData.message;
                } else if (parsedData?.error) {
                    errorMessage = typeof parsedData.error === 'string' ? parsedData.error : JSON.stringify(parsedData.error);
                } else if (responseText) {
                    errorMessage = responseText;
                }
                throw new Error(errorMessage);
            }
            const data = parsedData || {};
            if (data.image || data.imageUrl) {
                const imageSrc = data.image
                    ? `data:${data.mimeType || 'image/png'};base64,${data.image}`
                    : data.imageUrl;
                if (isForTheme) {
                    return imageSrc;
                } else {
                    displayMessage([], 'bot', false, null, imageSrc, 'fa-palette', promptText);
                    addMessageToHistory('model', [{text: `Image generated`}], null, imageSrc, promptText);
                }
            } else {
                throw new Error('No image data returned from Gemini.');
            }
        } catch (error) {
            removeThinkingIndicator();
            if(!isForTheme) {
                const friendlyMessage = error.message?.startsWith('API error')
                    ? `Image generation failed: ${error.message}`
                    : error.message || 'Image generation failed.';
                displayMessage([{ text: friendlyMessage }], 'bot', true);
            }
            throw error;
        } finally {
            removeThinkingIndicator();
            isRequestInProgress = false; 
            if(!isForTheme) {
                deactivateImageGenerationMode(); 
                updateActionButtonsState();
            }
        }
    }
    async function streamOpenAIResponse(messages, modelName, stream = true, silent = false) {
        console.log("sendMessageToOpenAI: Start", modelName);
        // If silent, we don't display a message initially
        const botMessageElement = (!silent && stream) ? displayMessage([], 'bot') : null;
        const paragraph = botMessageElement ? botMessageElement.querySelector('[data-stream-target="true"]') : null;
        
        let fullResponseText = "";
        try {
            const response = await fetch(OPENAI_PROXY_ENDPOINT, {
                method: 'POST', 
                headers: { 'Content-Type': 'application/json' }, 
                body: JSON.stringify({ model: modelName, messages, stream: true })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Proxy error ${response.status}: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                chunk.split('\n').forEach(line => {
                    if (!line.startsWith('data: ')) {
                        if (line.trim() !== '') {
                            console.warn("Unexpected non-data: prefixed line in stream:", line);
                        }
                        return;
                    }
                    const data = line.substring(6);
                    if (data === '[DONE]') {
                        return;
                    }
                    try {
                        const json = JSON.parse(data);
                        const content = json.choices?.[0]?.delta?.content || '';
                        if (content) {
                            fullResponseText += content;
                            if (paragraph) {
                               processAndAppendText(fullResponseText, paragraph, false); // No highlight during stream
                               chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
                            }
                        }
                    } catch (e) { 
                        console.warn("Non-JSON data in stream:", data, e);
                    }
                });
            }
            if (paragraph) {
                processAndAppendText(fullResponseText, paragraph, true); // Highlight at the end
            }
            console.log("sendMessageToOpenAI: End (Success)");
            return fullResponseText;
        } catch (error) {
            if (paragraph) {
                paragraph.textContent = `Error: ${error.message}`;
                paragraph.parentElement.classList.add('error-message');
            }
            console.error("sendMessageToOpenAI: Error", error);
            throw error;
        }
    }

    async function sendMessageToModel(messages, modelName, stream = true, silent = false) {
        if (modelName === GEMINI_CHAT_MODEL) {
            console.log("sendMessageToGemini: Start", modelName);
            const botMessageElement = (!silent && stream) ? displayMessage([], 'bot') : null;
            const paragraph = botMessageElement ? botMessageElement.querySelector('[data-stream-target="true"]') : null;
            let fullResponseText = "";
            try {
                const response = await fetch(GEMINI_CHAT_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Proxy error ${response.status}: ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    const chunk = decoder.decode(value);
                    chunk.split('\n').forEach(line => {
                        if (!line.startsWith('data: ')) {
                            if (line.trim() !== '') {
                                console.warn("Unexpected non-data: prefixed line in stream:", line);
                            }
                            return;
                        }
                        const data = line.substring(6);
                        if (data === '[DONE]') {
                            return;
                        }
                        try {
                            const json = JSON.parse(data);
                            const content = json.choices?.[0]?.delta?.content || '';
                            if (content) {
                                fullResponseText += content;
                                if (paragraph) {
                                    processAndAppendText(fullResponseText, paragraph, false); // No highlight during stream
                                    chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
                                }
                            }
                        } catch (e) {
                            console.warn("Non-JSON data in stream:", data, e);
                        }
                    });
                }
                if (paragraph) {
                    processAndAppendText(fullResponseText, paragraph, true); // Highlight at end
                }
                console.log("sendMessageToGemini: End (Success)");
                return fullResponseText;
            } catch (error) {
                if (paragraph) {
                    const errMsg = /429|quota|resource_exhausted/i.test(error?.message || '')
                        ? "nano banana is taking a breather. try again in a bit."
                        : `Error: ${error.message}`;
                    paragraph.textContent = errMsg;
                    paragraph.parentElement.classList.add('error-message');
                }
                console.error("sendMessageToGemini: Error", error);
                throw error;
            }
        }

        return streamOpenAIResponse(messages, modelName, stream, silent);
    }

    async function sendSearchRequest(queryText) {
        if (!queryText) throw new Error("Search query missing.");
        const instructions = getSearchSystemPrompt();
        try {
            const response = await fetch(OPENAI_SEARCH_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: queryText, instructions })
            });
            const rawText = await response.text();
            let data = {};
            if (rawText) {
                try {
                    data = JSON.parse(rawText);
                } catch (err) {
                    data = {};
                }
            }
            if (!response.ok) {
                const message = data?.error || data?.details || response.statusText || 'Search request failed.';
                throw new Error(message);
            }
            let text = '';
            if (typeof data?.text === 'string') {
                text = data.text.trim();
            } else if (Array.isArray(data?.text)) {
                text = data.text.join('\n').trim();
            } else if (Array.isArray(data?.output_text)) {
                text = data.output_text.join('\n').trim();
            } else if (Array.isArray(data?.raw?.output_text)) {
                text = data.raw.output_text.join('\n').trim();
            }
            if (!text) {
                text = 'Search finished but no response text was returned.';
            }
            return text;
        } catch (error) {
            console.error("sendSearchRequest error:", error);
            throw error;
        }
    }
    
    async function handleSendMessage() {
        console.log("handleSendMessage: Start");
        const messageText = messageInput.value.trim();
        if (!messageText && !selectedImageData) {
            console.log("handleSendMessage: No message or image, returning.");
            return;
        }

        hideActionCoachmark(true);

        const usingMeQuickMode = meQuickModeActive && meProfile && meProfile.imageData;
        let currentPrompt = messageText;
        let useSearchMode = isSearchModeQueued;

        const shouldGenerateImage = !useSearchMode && (usingMeQuickMode || isImageGenerationModeActive || isImageGenerationRequest(currentPrompt));
        const usageType = useSearchMode ? 'searches' : shouldGenerateImage ? 'images' : 'chats';
        const usageAttempt = tryConsumeUsage(usageType);

        if (!usageAttempt.success) {
            if (usageType === 'searches') {
                showToast("looks like graxybot's under high usage, try asking again later.", 'error', 4000);
            } else {
                const waitText = usageAttempt.remainingMs
                    ? ` try again in ${formatDuration(usageAttempt.remainingMs)}.`
                    : '';
                const label = usageType === 'images' ? 'image' : 'chat';
                showToast(`${label} limit reached.${waitText}`, 'error', 4000);
            }
            return;
        }

        if (useSearchMode) {
            isSearchModeQueued = false;
            updateSearchModeUI();
        }

        setChatActiveState(false);
        
        const userMessageParts = [];
        if (messageText) userMessageParts.push({ text: messageText });
        
        addMessageToHistory('user', userMessageParts, selectedImagePreviewUrl);
        displayMessage(userMessageParts, 'user', false, selectedImagePreviewUrl);

        messageInput.value = '';
        removeSelectedImage();

        // Suggest manual search for time-sensitive questions
        if (!useSearchMode && !shouldGenerateImage && isLikelyFreshInfoQuery(currentPrompt)) {
            const promptMsg = "need fresh info? turn on Search in the + menu, then resend.";
            displayMessage([{ text: promptMsg }], 'bot', false, null, null, 'fa-globe');
            addMessageToHistory('model', [{ text: promptMsg }]);
            updateActionButtonsState();
            return;
        }

        if (shouldGenerateImage) {
            isRequestInProgress = true; 
            updateActionButtonsState();
            console.log("handleSendMessage: Triggering image generation.");
            const promptForImage = usingMeQuickMode
                ? `Use the provided reference photo of this person and transform them accordingly. ${currentPrompt}`
                : currentPrompt;
            await triggerGeminiImageGeneration(promptForImage, false, usingMeQuickMode ? meProfile : null);
            isRequestInProgress = false; 
            updateActionButtonsState();
            if (usingMeQuickMode) {
                deactivateMeQuickMode();
            }

        } else if (useSearchMode) {
            isRequestInProgress = true;
            updateActionButtonsState();
            console.log("handleSendMessage: Running web search.");
            showThinkingIndicator("Searching the web...", 'fa-globe');
            try {
                const searchResponse = await sendSearchRequest(currentPrompt);
                removeThinkingIndicator();
                displayMessage([{ text: searchResponse }], 'bot', false, null, null, 'fa-globe');
                addMessageToHistory('model', [{ text: searchResponse }]);
            } catch (error) {
                removeThinkingIndicator();
                const friendly = /limit|quota|rate/i.test(error?.message || '')
                    ? "search is cooling off. try again soon."
                    : `Search failed: ${error.message}`;
                displayMessage([{ text: friendly }], 'bot', true, null, null, 'fa-globe');
            } finally {
                isRequestInProgress = false;
                updateActionButtonsState();
                console.log("handleSendMessage: End (search).");
            }
        } else if (isWebDesignModeActive) {
            isRequestInProgress = true; 
            updateActionButtonsState();
            console.log("handleSendMessage: Web Design Agent active.");
            
            showThinkingIndicator("Designing your Site...", 'fa-palette');

            // Determine mode from variable
            const designMode = currentWebDesignMode;
            const modelToUse = designMode === 'simple' ? "gpt-4.1-mini" : "gpt-5.1";
            
            const systemPrompt = getWebDesignSystemPrompt(designMode);
            
            const historyForAPI = (chats[currentChatId]?.history || [])
                .slice(-6).map(msg => ({ // Less history for focused design task
                    role: msg.role === 'model' ? 'assistant' : 'user',
                    content: msg.parts.map(p => p.text).join(' ')
                }));
            
            // Prioritize the current prompt context
            const messagesForModel = [
                { role: "system", content: systemPrompt },
                ...historyForAPI,
                { role: "user", content: currentPrompt } // Ensure current prompt is explicit if history is messy
            ];
            
            // Remove the duplicate user message if it was already added to history above (it is added in handleSendMessage before this block)
            // Actually, historyForAPI includes the message we just added? 
            // Let's check addMessageToHistory... Yes, it pushes to history.
            // So historyForAPI will include the current message as the last item.
            // We just need the system prompt + history.
            
            const messages = [{ role: "system", content: systemPrompt }, ...historyForAPI];

            const startTime = Date.now(); // Start timer

            try {
                const aiResponse = await sendMessageToModel(messages, modelToUse, true, true); // Silent mode
                
                const endTime = Date.now(); // End timer
                const durationSeconds = ((endTime - startTime) / 1000).toFixed(1);

                // Extract HTML code from response
                const codeBlockRegex = /```html([\s\S]*?)```/i;
                const match = aiResponse.match(codeBlockRegex);
                const htmlCode = match ? match[1].trim() : aiResponse;
                
                // robust line counting
                const lineCount = htmlCode.split(/\r\n|\r|\n/).length;

                // Display result with View Site button
                const extraData = { 
                    type: 'web_design', 
                    html: htmlCode,
                    stats: { 
                        lines: lineCount, 
                        time: durationSeconds 
                    }
                };
                console.log("Web Design Stats:", extraData.stats); // Debug log

                displayMessage([], 'bot', false, null, null, 'fa-palette', null, extraData);
                addMessageToHistory('model', [{ text: "Website generated" }], null, null, null, extraData);

            } catch (error) {
                 // Error handled in sendMessageToModel / displayMessage
                 removeThinkingIndicator();
                 displayMessage([{ text: `Design failed: ${error.message}` }], 'bot', true);
            } finally {
                removeThinkingIndicator();
                isRequestInProgress = false;
                updateActionButtonsState();
                console.log("handleSendMessage: End (Web Design).");
            }

        } else {
            isRequestInProgress = true; 
            updateActionButtonsState();
            console.log("handleSendMessage: Sending message to model.");
            
            const modelToUse = DEFAULT_CHAT_MODEL;
            const systemPrompt = getSystemPrompt(modelToUse);
            const historyForAPI = (chats[currentChatId]?.history || [])
                .slice(-10).map(msg => ({
                    role: msg.role === 'model' ? 'assistant' : 'user',
                    content: msg.parts.map(p => p.text).join(' ')
                }));
            const messagesForModel = [{ role: "system", content: systemPrompt }, ...historyForAPI];
            
            try {
                const aiResponse = await sendMessageToModel(messagesForModel, modelToUse);
                addMessageToHistory('model', [{ text: aiResponse }]);
            } catch (error) {
                // Error is already displayed by sendMessageToModel
            } finally {
                isRequestInProgress = false;
                updateActionButtonsState();
                console.log("handleSendMessage: End.");
            }
        }
    }
    
    // --- UI Toggles & Handlers ---
    function initializeSpeechRecognition() {
        const SpeechAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechAPI) { 
            micButton.style.display = 'none'; 
            return; 
        }
        speechRecognition = new SpeechAPI();
        speechRecognition.continuous = false;
        speechRecognition.interimResults = false;

        speechRecognition.onstart = () => { 
            isListening = true; 
            updateActionButtonsState(); 
            messageInput.placeholder = "Listening...";
        };

        speechRecognition.onresult = (e) => { 
            const transcript = e.results[e.results.length - 1][0].transcript;
            messageInput.value = transcript;
        };

        speechRecognition.onend = () => { 
            isListening = false;
            updateActionButtonsState(); 
            refreshInputPlaceholder();
            if(messageInput.value.trim()) {
                handleSendMessage(); 
            }
        };

        speechRecognition.onerror = (e) => { 
            console.error("Speech recognition error:", e.error); 
            showToast(`Mic error: ${e.error}`, 'error'); 
            isListening = false;
            updateActionButtonsState();
            refreshInputPlaceholder();
        };
    }
    function toggleSpeechRecognition() {
        if(isListening) {
             speechRecognition.stop();
        } else {
             if (!speechRecognition) initializeSpeechRecognition();
             speechRecognition.start();
        }
    }
    function deactivateImageGenerationMode() {
        isImageGenerationModeActive = false;
        refreshInputPlaceholder();
        updateActionButtonsState();
    }
    function handleCreateImageButtonClick() {
        hideActionCoachmark(true);
        isImageGenerationModeActive = !isImageGenerationModeActive;
        if (isImageGenerationModeActive) {
            if (isSearchModeQueued) isSearchModeQueued = false;
            if (isWebDesignModeActive) isWebDesignModeActive = false;
        }
        refreshInputPlaceholder();
        updateSearchModeUI();
        updateWebDesignModeUI();
        updateActionButtonsState();
        messageInput.focus();
    }
    function handleSearchModeToggle() {
        hideActionCoachmark(true);
        if (isRequestInProgress) return;
        isSearchModeQueued = !isSearchModeQueued;
        if (isSearchModeQueued) {
            if (isImageGenerationModeActive) {
                isImageGenerationModeActive = false;
            }
            if (isWebDesignModeActive) {
                isWebDesignModeActive = false;
            }
            refreshInputPlaceholder();
            if (meQuickModeActive) {
                deactivateMeQuickMode();
            }
            showToast("next message will search the web.", "info", 2200);
        } else {
            showToast("web search off.", "info", 1800);
        }
        updateSearchModeUI();
        updateWebDesignModeUI();
        updateActionButtonsState();
        if (actionMenu) actionMenu.classList.remove('visible');
        if (actionMenuToggle) actionMenuToggle.classList.remove('active');
    }
    function handleWebDesignAgentToggle() {
        hideActionCoachmark(true);
        if (isRequestInProgress) return;
        
        isWebDesignModeActive = !isWebDesignModeActive;
        console.log("Web Design Mode toggled:", isWebDesignModeActive);
        
        if (isWebDesignModeActive) {
            // Disable other modes
            if (isImageGenerationModeActive) isImageGenerationModeActive = false;
            if (isSearchModeQueued) isSearchModeQueued = false;
            if (meQuickModeActive) deactivateMeQuickMode();
            
            showToast("Web Design Agent active!", "info", 2000);
        } else {
            showToast("Web Design Agent disabled.", "info", 1800);
        }
        
        updateWebDesignModeUI();
        updateActionButtonsState();
        
        // Close menu
        if (agentMenu) agentMenu.classList.remove('visible');
        if (agentMenuToggle) agentMenuToggle.classList.remove('active');
    }

    function updateWebDesignModeUI() {
        if (webDesignAgentButton) {
            webDesignAgentButton.classList.toggle('active', isWebDesignModeActive);
        }
        
        if (webDesignModeContainer) {
            webDesignModeContainer.style.display = isWebDesignModeActive ? 'flex' : 'none';
        }
        
        if (chatInputArea) {
            const busy = isRequestInProgress || isListening;
            chatInputArea.classList.toggle('web-design-mode-active', isWebDesignModeActive && !busy);
            // Re-apply busy state logic just in case
            chatInputArea.classList.toggle('image-mode-busy', (isImageGenerationModeActive || isWebDesignModeActive) && busy);
        }

        if (chatTitle) {
            if (isWebDesignModeActive) {
                // Store original title if needed, or just set it
                chatTitle.textContent = "What can I design?";
            } else {
                setDynamicChatTitle();
            }
        }
        refreshInputPlaceholder();
    }
    
    function showPersonalityModal() {
        activateSettingsTab('profile');
        updateUsageUI();
        userNameInput.value = userPersonality.name || '';
        responseStyleInput.value = userPersonality.responseStyle || '';
        personalityOverlay.classList.add('visible');
    }
    function hidePersonalityModal() {
        personalityOverlay.classList.remove('visible');
    }
    function handleSavePersonality() {
        userPersonality.name = userNameInput.value.trim() || null;
        userPersonality.responseStyle = responseStyleInput.value.trim() || '';
        savePersonalitySettings();
        setDynamicChatTitle();
        showToast("Personality saved!", "success");
        hidePersonalityModal();
    }

    function showInitialNamePrompt() {
        if (!initialNameOverlay) return;
        initialNameOverlay.classList.add('visible');
        if (initialNameInput) {
            initialNameInput.value = '';
            setTimeout(() => initialNameInput.focus(), 0);
        }
    }
    function hideInitialNamePrompt() {
        if (!initialNameOverlay) return;
        initialNameOverlay.classList.remove('visible');
    }
    function handleInitialNameSave() {
        if (!initialNameInput) return;
        const name = initialNameInput.value.trim();
        if (!name) {
            showToast("please add a name first.", "error");
            initialNameInput.focus();
            return;
        }
        userPersonality.name = name;
        savePersonalitySettings();
        setDynamicChatTitle();
        hideInitialNamePrompt();
        showToast(`hey ${name}!`, "success");
    }

    // --- Theme Functions ---
    function showThemesModal() {
        themesOverlay.classList.add('visible');
        themePromptInput.value = '';
        themeImagePreview.style.display = 'none';
        saveThemeBtn.disabled = true;
        generatedThemeData = null;
        updateActiveThemeBox();
    }
    function hideThemesModal() {
        themesOverlay.classList.remove('visible');
    }

    function updateActiveThemeBox() {
        document.querySelectorAll('.theme-box').forEach(box => {
            box.classList.toggle('active', box.dataset.theme === currentTheme.type);
        });
    }
    
    function saveAndApplyTheme(type, data = null) {
        currentTheme = { type, data };
        localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(currentTheme));
        applyTheme(type, data);
        updateActiveThemeBox();
    }

    function applyTheme(type, data) {
        // Clear existing theme elements and listeners
        themeContainer.innerHTML = '';
        mainContent.style.backgroundImage = '';
        mainContent.removeEventListener('mousemove', handleGrassInteraction);
        mainContent.removeEventListener('mousemove', handleCloudInteraction);

        switch(type) {
            case 'grass':
                mainContent.style.backgroundColor = '#c1ffc1';
                createGrassTheme();
                break;
            case 'clouds':
                createCloudsTheme();
                break;
            case 'generated':
                if (data) mainContent.style.backgroundImage = `url(${data})`;
                break;
            case 'none':
            default:
                 mainContent.style.backgroundColor = '#f0f4f8'; // Default bg
                break;
        }
    }

    function createGrassTheme() {
        const grassContainer = document.createElement('div');
        grassContainer.id = 'grass-theme-container';
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute('id', 'grass-svg');
        svg.setAttribute('preserveAspectRatio', 'none');
        svg.setAttribute('viewBox', '0 0 100 10');
        
        for (let i = 0; i < 150; i++) {
            const path = document.createElementNS(svgNS, "path");
            const x = Math.random() * 100;
            const h = 2 + Math.random() * 8;
            const w = 0.2 + Math.random() * 0.3;
            const sway = (Math.random() - 0.5) * 2;
            path.setAttribute('d', `M ${x} 10 Q ${x+sway} ${10-h/2}, ${x} ${10-h}`);
            path.setAttribute('stroke', `hsl(120, ${60 + Math.random()*20}%, ${30 + Math.random()*20}%)`);
            path.setAttribute('stroke-width', w);
            path.setAttribute('fill', 'none');
            path.setAttribute('class', 'grass-blade');
            path.style.animation = `sway ${2 + Math.random() * 4}s ease-in-out ${Math.random() * -6}s infinite alternate`;
            svg.appendChild(path);
        }
        
        grassContainer.appendChild(svg);
        themeContainer.appendChild(grassContainer);
        mainContent.addEventListener('mousemove', handleGrassInteraction);
    }
    
    function handleGrassInteraction(e) {
        const containerRect = e.currentTarget.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const blades = document.querySelectorAll('.grass-blade');
        blades.forEach(blade => {
            const bladeBox = blade.getBBox();
            const bladeX = (bladeBox.x / 100) * containerRect.width;
            const dist = Math.abs(mouseX - bladeX);
            if (dist < 50) {
                const angle = (mouseX - bladeX) * 0.3 * (1 - dist / 50);
                blade.style.transform = `rotate(${angle}deg)`;
            } else {
                blade.style.transform = 'rotate(0deg)';
            }
        });
    }

    function createCloudsTheme() {
        const cloudContainer = document.createElement('div');
        cloudContainer.id = 'clouds-theme-container';
        for(let i=1; i<=3; i++) {
            const cloud = document.createElement('div');
            cloud.className = `cloud cloud-${i}`;
            cloudContainer.appendChild(cloud);
        }
        themeContainer.appendChild(cloudContainer);
        mainContent.addEventListener('mousemove', handleCloudInteraction);
    }

    function handleCloudInteraction(e) {
        const containerRect = e.currentTarget.getBoundingClientRect();
        const mouseX = e.clientX - containerRect.left;
        const mouseY = e.clientY - containerRect.top;
        const clouds = document.querySelectorAll('.cloud');
        clouds.forEach((cloud, index) => {
            const moveX = (mouseX - containerRect.width / 2) / (20 + index * 10);
            const moveY = (mouseY - containerRect.height / 2) / (20 + index * 10);
            cloud.style.transform = `translateX(${moveX}px) translateY(${moveY}px)`;
        });
    }


    async function handleGenerateTheme() {
        const prompt = themePromptInput.value.trim();
        if (!prompt) {
            showToast("Please enter a prompt for the theme.", "error");
            return;
        }
        themeSpinner.style.display = 'block';
        themeImagePreview.style.display = 'none';
        generateThemeBtn.disabled = true;
        saveThemeBtn.disabled = true;
        try {
            const imageSrc = await triggerGeminiImageGeneration(prompt, true);
            if(imageSrc){
                generatedThemeData = imageSrc;
                themeImagePreview.src = imageSrc;
                themeImagePreview.style.display = 'block';
                saveThemeBtn.disabled = false;
            } else {
                 showToast("Failed to generate theme. Please try again.", "error");
            }
        } catch (error) {
            console.error("Theme generation error:", error);
            showToast(`Error: ${error.message}`, "error");
        } finally {
            themeSpinner.style.display = 'none';
            generateThemeBtn.disabled = false;
        }
    }
    
    function handleSaveGeneratedTheme() {
        if (generatedThemeData) {
            saveAndApplyTheme('generated', generatedThemeData);
            showToast("Theme saved!", "success");
            hideThemesModal();
        }
    }

    function handleRemoveTheme() {
        saveAndApplyTheme('none');
        showToast("Theme removed.", "success");
        hideThemesModal();
    }
    
    // --- Reddit Story Functions ---
    let videoPlaybackInterval;
    let currentVideoIndex = 0;

    async function handleRedditStoryGeneration() {
        const promptText = messageInput.value.trim();
        if (!promptText) {
            showToast("Please enter a topic for the story.", "error");
            return;
        }

        const usageAttempt = tryConsumeUsage('chats');
        if (!usageAttempt.success) {
            const waitText = usageAttempt.remainingMs
                ? ` try again in ${formatDuration(usageAttempt.remainingMs)}.`
                : '';
            showToast(`chat limit reached.${waitText}`, "error", 4000);
            return;
        }

        displayMessage([{ text: `Tell me a Reddit story about ${promptText}` }], 'user');
        addMessageToHistory('user', [{ text: `Tell me a Reddit story about ${promptText}` }]);
        messageInput.value = '';
        updateActionButtonsState();
        isRequestInProgress = true;
        showThinkingIndicator("Writing your story...");

        try {
            const systemPrompt = getSystemPrompt(DEFAULT_CHAT_MODEL, true);
            const messages = [{ role: "system", content: systemPrompt }, { role: "user", content: promptText }];
            
            const storyText = await sendMessageToModel(messages, DEFAULT_CHAT_MODEL, true); 

            removeThinkingIndicator();
            addMessageToHistory('model', [{ text: storyText }]);

            await playStoryWithVideo(storyText);

        } catch (error) {
            removeThinkingIndicator();
            displayMessage([{ text: `Error generating story: ${error.message}` }], 'bot', true);
        } finally {
            isRequestInProgress = false;
            updateActionButtonsState();
        }
    }

    async function playStoryWithVideo(text) {
        if ('speechSynthesis' in window === false) {
            showToast("Speech synthesis is not supported in your browser.", "error");
            return;
        }

        window.speechSynthesis.cancel();
        storyOverlay.classList.add('visible');
        storyVideo.muted = true;

        const lines = text.split(/\n+/).filter(line => line.trim().length > 0);
        let currentLineIndex = 0;

        const getVoicesAsync = () => {
            return new Promise(resolve => {
                let voices = window.speechSynthesis.getVoices();
                if (voices.length) {
                    resolve(voices);
                } else {
                    window.speechSynthesis.onvoiceschanged = () => {
                        voices = window.speechSynthesis.getVoices();
                        resolve(voices);
                    };
                }
            });
        };

        const voices = await getVoicesAsync();
        let availableVoices = voices.filter(voice => 
            voice.name.includes('Google') && 
            (voice.lang === 'en-US' || voice.lang === 'en-GB')
        );

        if (availableVoices.length > 1 && lastStoryVoiceName) {
            availableVoices = availableVoices.filter(v => v.name !== lastStoryVoiceName);
        }

        let storyVoice = null;
        if (availableVoices.length > 0) {
            storyVoice = availableVoices[Math.floor(Math.random() * availableVoices.length)];
            lastStoryVoiceName = storyVoice.name;
        } else {
            const allGoogleVoices = voices.filter(voice => voice.name.includes('Google') && (voice.lang === 'en-US' || voice.lang === 'en-GB'));
            if (allGoogleVoices.length > 0) {
                storyVoice = allGoogleVoices[Math.floor(Math.random() * allGoogleVoices.length)];
                lastStoryVoiceName = storyVoice.name;
            }
        }

        const speakNextLine = () => {
            if (currentLineIndex < lines.length) {
                const lineText = lines[currentLineIndex].trim();
                storyCaptionsContainer.textContent = lineText;

                currentSpeechUtterance = new SpeechSynthesisUtterance(lineText);
                
                if (storyVoice) {
                    currentSpeechUtterance.voice = storyVoice;
                }

                window.speechSynthesis.speak(currentSpeechUtterance);

                currentSpeechUtterance.onend = () => {
                    currentLineIndex++;
                    speakNextLine();
                };

                currentSpeechUtterance.onerror = (e) => {
                    console.error("Speech synthesis error:", e);
                    showToast(`Speech error: ${e.error}`, 'error');
                    closeStoryPlayer();
                };
            } else {
                showOutro();
            }
        };

        speakNextLine();

        currentVideoIndex = 0;
        function playNextVideoSegment() {
            if (BACKGROUND_VIDEOS.length === 0) return;
            const videoSrc = BACKGROUND_VIDEOS[currentVideoIndex % BACKGROUND_VIDEOS.length];
            storyVideo.src = videoSrc;
            storyVideo.currentTime = 0;
            storyVideo.play().catch(e => console.error("Video autoplay failed:", e));
            currentVideoIndex++;
        }

        playNextVideoSegment();
        videoPlaybackInterval = setInterval(playNextVideoSegment, 20000);
    }

    function showOutro() {
        const storyOutro = document.getElementById('story-outro');
        storyOutro.classList.add('visible');
        setTimeout(() => {
            closeStoryPlayer();
        }, 4000);
    }

    function closeStoryPlayer() {
        if (currentSpeechUtterance) {
            window.speechSynthesis.cancel();
            currentSpeechUtterance = null;
        }
        clearInterval(videoPlaybackInterval);
        storyOverlay.classList.remove('visible');
        storyVideo.pause();
        storyVideo.src = '';
        storyVideo.currentTime = 0;

        const storyOutro = document.getElementById('story-outro');
        storyOutro.classList.remove('visible');
    }

    function handleWipeData() {
        if (confirm("Are you sure you want to delete ALL chats, settings, and stored data? This cannot be undone.")) {
            localStorage.clear();
            usageStats = { chats: [], images: [] };
            updateUsageUI();
            
            showToast("All data has been wiped.", "success");
            setTimeout(() => window.location.reload(), 1500);
        }
    }
    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        // Assign DOM elements
        loader = document.getElementById('loader');
        toastContainer = document.getElementById('toast-container');
        chatApp = document.getElementById('chat-app');
        sidebar = document.getElementById('sidebar');
        mainContent = document.getElementById('main-content');
        themeContainer = document.getElementById('theme-container');
        newChatBtn = document.getElementById('new-chat-btn');
        chatList = document.getElementById('chat-list');
        settingsButton = document.getElementById('settings-button');
        themesButton = document.getElementById('themes-button');
        chatTitle = document.getElementById('chat-title');
        menuBackdrop = document.getElementById('menu-backdrop');
        menuToggleBtn = document.getElementById('menu-toggle-btn');
        chatMessagesContainer = document.getElementById('chat-messages');
        messageInput = document.getElementById('message-input');
        chatInputArea = document.querySelector('.chat-input-area');
        sendButton = document.getElementById('send-button');
        createImageButton = document.getElementById('create-image-button');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        micButton = document.getElementById('mic-button');
        redditStoryButton = document.getElementById('reddit-story-button');
        storyOverlay = document.getElementById('story-overlay');
        storyVideo = document.getElementById('story-video');
        storyCaptionsContainer = document.getElementById('story-captions-container');
        closeStoryBtn = document.getElementById('close-story-btn');
        downloadStoryBtn = document.getElementById('download-story-btn');
        
        changelogOverlay = document.getElementById('changelog-overlay');
        changelogBtn = document.getElementById('changelog-btn');
        closeChangelogBtn = document.getElementById('close-changelog-btn');
        
        personalityOverlay = document.getElementById('personality-overlay');
        userNameInput = document.getElementById('user-name-input');
        responseStyleInput = document.getElementById('response-style-input');
        savePersonalityBtn = document.getElementById('save-personality-btn');
        closePersonalityModalBtn = document.getElementById('close-personality-modal-btn');
        themeModeToggle = document.getElementById('theme-mode-toggle');
        
        themesOverlay = document.getElementById('themes-overlay');
        closeThemesModalBtn = document.getElementById('close-themes-modal-btn');
        themePromptInput = document.getElementById('theme-prompt-input');
        generateThemeBtn = document.getElementById('generate-theme-btn');
        themePreview = document.getElementById('theme-preview');
        themeSpinner = document.getElementById('theme-spinner');
        themeImagePreview = document.getElementById('theme-image-preview');
        saveThemeBtn = document.getElementById('save-theme-btn');
        removeThemeBtn = document.getElementById('remove-theme-btn');
        grassThemeBox = document.getElementById('grass-theme-box');
        cloudsThemeBox = document.getElementById('clouds-theme-box');

        meButton = document.getElementById('me-button');
        mePopup = document.getElementById('me-popup');
        mePopupCloseBtn = document.getElementById('me-popup-close-btn');
        meStartCameraBtn = document.getElementById('me-start-camera-btn');
        meCaptureBtn = document.getElementById('me-capture-btn');
        meUploadBtn = document.getElementById('me-upload-btn');
        meUploadInput = document.getElementById('me-upload-input');
        meRetakeRow = document.getElementById('me-retake-row');
        meRetakeBtn = document.getElementById('me-retake-btn');
        meRemoveBtn = document.getElementById('me-remove-btn');
        meMediaPreview = document.getElementById('me-media-preview');
        meMediaPlaceholder = document.getElementById('me-media-placeholder');
        mePhotoPreview = document.getElementById('me-photo-preview');
        mePromptArea = document.getElementById('me-prompt-area');
        mePromptInput = document.getElementById('me-prompt-input');
        meSubtitle = document.getElementById('me-popup-subtitle');
        meCameraStreamEl = document.getElementById('me-camera-stream');
        meCanvas = document.getElementById('me-canvas');
        meActiveBanner = document.getElementById('me-active-banner');
        meInlineRetakeBtn = document.getElementById('me-inline-retake-btn');
        meInlineRemoveBtn = document.getElementById('me-inline-remove-btn');
        webDesignModeContainer = document.getElementById('web-design-mode-container');
        webDesignModeToggle = document.getElementById('web-design-mode-toggle');
        webDesignModeMenu = document.getElementById('web-design-mode-menu');
        modeSimpleBtn = document.getElementById('mode-simple-btn');
        modeProBtn = document.getElementById('mode-pro-btn');

        settingsTabButtons = Array.from(document.querySelectorAll('[data-settings-tab]'));
        settingsTabPanels = Array.from(document.querySelectorAll('[data-settings-panel]'));
        usageChatsBar = document.getElementById('usage-chats-bar');
        usageChatsLabel = document.getElementById('usage-chats-label');
        usageChatsReset = document.getElementById('usage-chats-reset');
        usageImagesBar = document.getElementById('usage-images-bar');
        usageImagesLabel = document.getElementById('usage-images-label');
        usageImagesReset = document.getElementById('usage-images-reset');

        actionMenuToggle = document.getElementById('action-menu-toggle');
        actionMenu = document.getElementById('action-menu');
        agentMenuToggle = document.getElementById('agent-menu-toggle');
        agentMenu = document.getElementById('agent-menu');
        webDesignAgentButton = document.getElementById('web-design-agent-button');
        actionCoachmark = document.getElementById('action-coachmark');
        searchModeButton = document.getElementById('search-mode-button');
        const launchPopupOverlay = document.getElementById('launch-popup-overlay');
        const launchPopupCloseBtn = document.getElementById('launch-popup-close-btn');
        const launchPopupChangelogBtn = document.getElementById('launch-popup-changelog-btn');

        wipeDataBtn = document.getElementById('wipe-data-btn');
        initialNameOverlay = document.getElementById('initial-name-overlay');
        initialNameInput = document.getElementById('initial-name-input');
        initialNameSaveBtn = document.getElementById('initial-name-save-btn');

        const storedThemeMode = localStorage.getItem(THEME_MODE_STORAGE_KEY) || 'dark';
        applyThemeMode(storedThemeMode);
        setDynamicChatTitle();

        // --- Event Listeners ---
        actionMenuToggle.addEventListener('click', () => {
            hideActionCoachmark(true);
            actionMenu.classList.toggle('visible');
            actionMenuToggle.classList.toggle('active');
            // Ensure agent menu is closed when action menu is opened
            if (agentMenu) agentMenu.classList.remove('visible');
            if (agentMenuToggle) agentMenuToggle.classList.remove('active');
        });

        if (agentMenuToggle) {
            agentMenuToggle.addEventListener('click', () => {
                agentMenu.classList.toggle('visible');
                agentMenuToggle.classList.toggle('active');
                // Ensure action menu is closed when agent menu is opened
                actionMenu.classList.remove('visible');
                actionMenuToggle.classList.remove('active');
                hideActionCoachmark(true);
            });
        }

        if (webDesignModeToggle) {
            webDesignModeToggle.addEventListener('click', () => {
                webDesignModeMenu.classList.toggle('visible');
                // Close other menus
                if (actionMenu) actionMenu.classList.remove('visible');
                if (actionMenuToggle) actionMenuToggle.classList.remove('active');
                if (agentMenu) agentMenu.classList.remove('visible');
                if (agentMenuToggle) agentMenuToggle.classList.remove('active');
            });
        }
        
        function setWebDesignMode(mode) {
            currentWebDesignMode = mode;
            const label = mode === 'simple' ? 'Simple' : 'Pro';
            if (webDesignModeToggle) {
                webDesignModeToggle.querySelector('span').textContent = label;
                webDesignModeToggle.classList.add('web-design-mode-selected'); // Apply selected class
            }
            if (webDesignModeMenu) webDesignModeMenu.classList.remove('visible');
            showToast(`Web Design: ${label} Mode`, 'info');
        }

        if (modeSimpleBtn) modeSimpleBtn.addEventListener('click', () => setWebDesignMode('simple'));
        if (modeProBtn) modeProBtn.addEventListener('click', () => setWebDesignMode('pro'));

        // ... (rest of the event listeners) ...

        // Initialize Web Design mode state
        setWebDesignMode(currentWebDesignMode);
        
        document.addEventListener('click', (e) => {
            const clickedInsideActionMenu = actionMenu && (actionMenu.contains(e.target) || actionMenuToggle.contains(e.target));
            const clickedInsideAgentMenu = agentMenu && (agentMenu.contains(e.target) || agentMenuToggle.contains(e.target));
            const clickedInsideWebDesignMenu = webDesignModeContainer && (webDesignModeContainer.contains(e.target));

            if (!clickedInsideActionMenu) {
                if (actionMenu) actionMenu.classList.remove('visible');
                if (actionMenuToggle) actionMenuToggle.classList.remove('active');
            }
            if (!clickedInsideAgentMenu) {
                if (agentMenu) agentMenu.classList.remove('visible');
                if (agentMenuToggle) agentMenuToggle.classList.remove('active');
            }
            if (!clickedInsideWebDesignMenu) {
                if (webDesignModeMenu) webDesignModeMenu.classList.remove('visible');
            }
            hideActionCoachmark(true);
        });
        if (searchModeButton) {
            searchModeButton.addEventListener('click', handleSearchModeToggle);
        }
        if (themeModeToggle) {
            themeModeToggle.addEventListener('change', (e) => {
                applyThemeMode(e.target.checked ? 'dark' : 'light');
            });
        }
        
        loadData();
        loadMeProfileFromStorage();
        loadUsageStats();
        updateUsageUI();
        if (usageUpdateInterval) clearInterval(usageUpdateInterval);
        usageUpdateInterval = setInterval(updateUsageUI, 60000);
        if (!userPersonality.name) {
            showInitialNamePrompt();
        }
        renderChatList();
        setChatActiveState(true); 
        if (currentChatId && chats[currentChatId]?.history.length > 0) {
            loadChat(currentChatId); 
        }
        updateActionButtonsState();
        if (actionCoachmark) {
            setTimeout(() => showActionCoachmark(), 400);
        }

        newChatBtn.addEventListener('click', () => {
            if (currentChatId && chats[currentChatId] && chats[currentChatId].history.length === 0) {
                showToast("Send a message to start the current chat first.", 'info');
                sidebar.classList.remove('visible');
                menuBackdrop.classList.remove('visible');
                return;
            }
            sidebar.classList.remove('visible');
            menuBackdrop.classList.remove('visible');
            handleNewChat(true);
        });
        settingsButton.addEventListener('click', showPersonalityModal);
        themesButton.addEventListener('click', showThemesModal);
        settingsTabButtons.forEach(btn => {
            btn.addEventListener('click', () => activateSettingsTab(btn.dataset.settingsTab));
        });
        
        menuToggleBtn.addEventListener('click', () => {
            sidebar.classList.add('visible');
            menuBackdrop.classList.add('visible');
        });
        
        menuBackdrop.addEventListener('click', () => {
             sidebar.classList.remove('visible');
            menuBackdrop.classList.remove('visible');
        });
        sendButton.addEventListener('click', handleSendMessage);
        redditStoryButton.addEventListener('click', handleRedditStoryGeneration);
        closeStoryBtn.addEventListener('click', closeStoryPlayer);
        downloadStoryBtn.addEventListener('click', () => {
            if (storyVideo.src) {
                const a = document.createElement('a');
                a.href = storyVideo.src;
                a.download = 'graxybot_story_video.mp4';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast("Downloading video...", "info");
            } else {
                showToast("No video to download.", "error");
            }
        });
        messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { e.preventDefault(); handleSendMessage(); } });
        messageInput.addEventListener('input', () => {
            updateActionButtonsState();
        });
        createImageButton.addEventListener('click', handleCreateImageButtonClick);
        imageUploadButton.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageSelection);
        removeImageButton.addEventListener('click', removeSelectedImage);
        if (micButton) micButton.addEventListener('click', toggleSpeechRecognition);

        if (webDesignAgentButton) {
            // Use onclick to prevent multiple listeners
            webDesignAgentButton.onclick = handleWebDesignAgentToggle;
        }
        
        closePersonalityModalBtn.addEventListener('click', hidePersonalityModal);
        savePersonalityBtn.addEventListener('click', handleSavePersonality);
        personalityOverlay.addEventListener('click', (e) => { if(e.target === personalityOverlay) hidePersonalityModal(); });
        
        closeThemesModalBtn.addEventListener('click', hideThemesModal);
        themesOverlay.addEventListener('click', (e) => { if(e.target === themesOverlay) hideThemesModal(); });
        generateThemeBtn.addEventListener('click', handleGenerateTheme);
        saveThemeBtn.addEventListener('click', handleSaveGeneratedTheme);
        removeThemeBtn.addEventListener('click', handleRemoveTheme);
        grassThemeBox.addEventListener('click', () => saveAndApplyTheme('grass'));
        cloudsThemeBox.addEventListener('click', () => saveAndApplyTheme('clouds'));
        if (changelogBtn) changelogBtn.addEventListener('click', () => changelogOverlay.classList.add('visible'));
        if (closeChangelogBtn) closeChangelogBtn.addEventListener('click', () => changelogOverlay.classList.remove('visible'));
        if (changelogOverlay) changelogOverlay.addEventListener('click', (e) => { if (e.target === changelogOverlay) changelogOverlay.classList.remove('visible'); });
        if (launchPopupOverlay) {
            launchPopupOverlay.classList.add('visible');
        }
        if (launchPopupCloseBtn) {
            launchPopupCloseBtn.addEventListener('click', () => {
                launchPopupOverlay?.classList.remove('visible');
            });
        }
        if (launchPopupChangelogBtn) {
            launchPopupChangelogBtn.addEventListener('click', () => {
                launchPopupOverlay?.classList.remove('visible');
                changelogOverlay?.classList.add('visible');
            });
        }

        if (meButton) {
            meButton.addEventListener('click', () => {
                if (meProfile && meProfile.imageData) {
                    if (meQuickModeActive) {
                        deactivateMeQuickMode();
                        showMePopup();
                    } else {
                        activateMeQuickMode();
                    }
                } else {
                    showMePopup();
                }
            });
        }
        if (mePopup) mePopup.addEventListener('click', (e) => { if (e.target === mePopup) hideMePopup(); });
        if (mePopupCloseBtn) mePopupCloseBtn.addEventListener('click', hideMePopup);
        if (meStartCameraBtn) meStartCameraBtn.addEventListener('click', startMeCamera);
        if (meCaptureBtn) meCaptureBtn.addEventListener('click', handleMeCapture);
        if (meUploadBtn) meUploadBtn.addEventListener('click', () => { if (meUploadInput) meUploadInput.click(); });
        if (meUploadInput) meUploadInput.addEventListener('change', handleMeUpload);
        if (meMediaPreview) {
            meMediaPreview.addEventListener('click', () => {
                if (meProfile && meProfile.imageData) {
                    activateMeQuickMode();
                }
            });
        }
        if (meRetakeBtn) meRetakeBtn.addEventListener('click', () => startMeCamera());
        if (meRemoveBtn) meRemoveBtn.addEventListener('click', handleMeRemove);
        if (meInlineRetakeBtn) {
            meInlineRetakeBtn.addEventListener('click', () => {
                deactivateMeQuickMode();
                showMePopup();
                setTimeout(() => startMeCamera(), 120);
            });
        }
        if (meInlineRemoveBtn) {
            meInlineRemoveBtn.addEventListener('click', () => {
                handleMeRemove();
                showToast("me photo removed.", "info", 2000);
            });
        }
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mePopup && mePopup.classList.contains('visible')) {
                hideMePopup();
            }
        });

        wipeDataBtn.addEventListener('click', handleWipeData);
        if (initialNameSaveBtn) {
            initialNameSaveBtn.addEventListener('click', handleInitialNameSave);
        }
        if (initialNameInput) {
            initialNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleInitialNameSave();
                }
            });
        }

        loader.classList.remove('visible');
        updateSearchModeUI();
        messageInput.focus();
        console.log("Graxybot UI Initialized.");

    });
</script>
</body>
</html>
