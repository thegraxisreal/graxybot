<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="graxybot.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
<style>
:root {
    --background: #ffffff;
    --sidebar-bg: #f9fafb;
    --text-primary: #1a1a1a;
    --text-secondary: #6b7280;
    --primary: #4f46e5;
    --primary-light: #675ef2;
    --border-color: #e5e7eb;
    --input-bg: #f3f4f6;
    --user-message-bg: #eef2ff;
    --bot-message-bg: #ffffff;
    --hover-bg: #f3f4f6;
    --code-bg: #272822;
    --code-header-bg: #3a3b35;
    --toast-bg: #333;
    --toast-text: white;
    --modal-bg: rgba(0, 0, 0, 0.5);
    --sidebar-width: 260px;
}

html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}

body {
    font-family: 'Inter', sans-serif;
    background-color: var(--background);
    color: var(--text-primary);
    display: flex;
    height: 100vh;
}

/* --- Main Layout --- */
.chat-app {
    display: flex;
    height: 100%;
    width: 100%;
}

/* --- Sidebar --- */
.sidebar {
    width: var(--sidebar-width);
    background-color: var(--sidebar-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    transition: transform 0.3s ease;
}
.sidebar-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
}
.new-chat-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--background);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease;
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }
.chat-list {
    list-style: none;
    padding: 0;
    margin: 0.5rem;
    overflow-y: auto;
    flex-grow: 1;
}
.chat-list-item {
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 5px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.9rem;
    position: relative;
    transition: background-color 0.2s ease;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%);
    background: none; border: none; font-size: 1rem; padding: 5px;
    color: var(--text-secondary); cursor: pointer; display: none;
}
.chat-list-item.active .delete-chat-btn { color: white; }
.chat-list-item:hover .delete-chat-btn { display: block; }
.sidebar-footer {
    padding: 1rem;
    border-top: 1px solid var(--border-color);
}

/* --- Main Content --- */
.main-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    position: relative; /* Context for absolute positioning */
}
.chat-top-bar {
    padding: 0.75rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 1rem;
    height: 38px; /* Give it a static height */
}
.menu-toggle {
    display: none; /* Hidden on desktop */
}

/* Title Animation */
#chat-title {
    margin: 0;
    font-weight: 700;
    color: var(--primary);
    white-space: nowrap;
    position: absolute;
    /* Corner is the default state */
    top: 0.75rem;
    left: 4rem; /* Aligned with top bar content */
    font-size: 1.2rem;
    transform: scale(1);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
}
.main-content.new-chat-active #chat-title {
    /* Center state */
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 3rem;
}
@media (max-width: 768px) {
    #chat-title.title-corner {
        font-size: 1.1rem;
    }
    .main-content.new-chat-active #chat-title {
         font-size: 2.5rem;
    }
}


.chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 20px 15px;
    display: flex;
    flex-direction: column;
}

/* --- Message Bubbles --- */
.message-content-wrapper {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 20px;
    max-width: 95%;
}
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary);
    color: white; display: flex; align-items: center; justify-content: center;
    font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #9ca3af; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; max-width: calc(100% - 40px); }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6;
    background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; border: 1px solid var(--border-color);
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: #fef2f2; color: #991b1b; border-color: #fecaca; }
.message p { margin: 0; }
.generated-image, .sent-image {
    max-width: 100%; max-height: 400px; border-radius: 8px; margin-top: 8px;
    display: block; background-color: var(--input-bg);
}

/* Thinking Indicator & Code Block */
.thinking-indicator .message { padding: 15px 18px; display: flex; align-items: center; gap: 8px; }
.thinking-indicator span {
    display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary);
    border-radius: 50%; animation: typing 1s infinite ease-in-out;
}
.thinking-indicator span:nth-child(1) { animation-delay: 0s; }
.thinking-indicator span:nth-child(2) { animation-delay: 0.1s; }
.thinking-indicator span:nth-child(3) { animation-delay: 0.2s; }
@keyframes typing { 0%, 100% { transform: translateY(0); opacity: 0.5; } 50% { transform: translateY(-4px); opacity: 1; } }
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-buttons button { background-color: #4a4b45; border: none; color: #f8f8f2; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; }

/* Chat Input */
.chat-input-container {
    padding: 1rem 1.5rem; background-color: var(--background);
    border-top: 1px solid var(--border-color); flex-shrink: 0;
}
.chat-input-area {
    display: flex; align-items: center; background-color: #f9fafb;
    border: 1px solid var(--border-color); border-radius: 12px;
    padding: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
#message-input {
    flex-grow: 1; border: none; outline: none; background: transparent;
    font-size: 1rem; color: var(--text-primary); padding: 10px;
    resize: none; line-height: 1.5;
}
.input-actions { display: flex; align-items: center; gap: 5px; padding-right: 5px; }
.icon-btn {
    display: inline-flex; align-items: center; justify-content: center;
    border-radius: 8px; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0;
    background-color: transparent; color: var(--text-secondary);
    font-size: 1.1rem; transition: all 0.2s ease;
}
.icon-btn:hover { color: var(--primary); background-color: #eef2ff; }
.icon-btn.active { color: var(--primary); background-color: #e0e7ff; box-shadow: 0 0 0 3px #c7d2fe; }
.icon-btn:disabled { color: #d1d5db; background-color: transparent; cursor: not-allowed; }
#send-button { background-color: var(--primary); color: white; }
#send-button:hover { background-color: var(--primary-light); }
#send-button:disabled { background-color: #9ca3af; opacity: 0.7; }
#image-upload-input { display: none; }
#image-preview-area {
    margin-bottom: 10px; position: relative; display: inline-block; max-width: 100px;
}
#image-preview-area img { display: block; max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 6px; }
#remove-image-button {
    position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6);
    color: white; border: none; border-radius: 50%; width: 20px; height: 20px;
    font-size: 0.8rem; line-height: 20px; text-align: center; cursor: pointer;
}

/* Loader, Toast, Modals */
.loader-overlay {
    position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.9);
    display: flex; justify-content: center; align-items: center; z-index: 2000;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease;
}
.loader-overlay.visible { opacity: 1; visibility: visible; }
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
    border-radius: 50%; border-left-color: var(--primary);
    animation: spin 1s ease infinite;
}
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
#toast-container {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 1000; pointer-events: none;
}
.toast-message {
    background-color: var(--toast-bg); color: var(--toast-text);
    padding: 10px 20px; border-radius: 8px; margin-bottom: 10px;
    opacity: 0; transition: all 0.3s ease-in-out; transform: translateY(20px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); font-size: 0.9rem;
    pointer-events: auto;
}
.toast-message.show { opacity: 1; transform: translateY(0); }
#personality-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: var(--modal-bg); z-index: 1000;
    display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
}
#personality-overlay.visible { opacity: 1; visibility: visible; }
.personality-modal-content {
    background: var(--background); padding: 30px; border-radius: 12px;
    max-width: 450px; width: 90%; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    position: relative; transform: scale(0.95); transition: transform 0.3s ease;
}
#personality-overlay.visible .personality-modal-content { transform: scale(1); }
.personality-modal-content h2 { margin-top: 0; font-size: 1.6rem; color: var(--primary); margin-bottom: 20px; }
.personality-modal-content label { display: block; font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 8px; font-weight: 500; }
.personality-modal-content input, .personality-modal-content textarea {
    width: 100%; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: #f9fafb; color: var(--text-primary);
    font-size: 0.95rem; margin-bottom: 20px; box-sizing: border-box;
}
.personality-modal-content button {
    width: 100%; padding: 12px 20px; background: var(--primary);
    color: white; border: none; border-radius: 8px; cursor: pointer;
    font-size: 1rem; font-weight: 600;
}
.personality-modal-content .close-modal-btn {
    position: absolute; top: 15px; right: 15px; background: none; border: none;
    font-size: 1.5rem; color: var(--text-secondary); cursor: pointer;
}

/* --- Mobile Responsive Styles --- */
@media (max-width: 768px) {
    .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100%;
        z-index: 1001; /* Above main content */
        transform: translateX(-100%);
    }
    .sidebar.visible {
        transform: translateX(0);
    }
    .main-content {
        width: 100%;
    }
    .menu-toggle {
        display: block;
    }
     #chat-title.title-corner {
        left: 4rem; /* Readjust for mobile */
    }
    .chat-input-container {
        padding: 0.75rem;
    }
}

/* --- Voice Mode Styles --- */
#voice-mode-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--background);
    z-index: 1002;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease, visibility 0.5s ease;
}
#voice-mode-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#voice-mode-canvas-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
.voice-mode-content {
    position: relative;
    z-index: 1;
    text-align: center;
    color: var(--text-primary);
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    width: 100%;
}
#transcribed-text, #bot-response-text {
    font-size: 1.5rem;
    font-weight: 500;
    max-width: 80%;
    margin: 2rem 0;
    transition: opacity 0.3s ease;
    min-height: 2em;
}
#thinking-indicator-voice {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-secondary);
    display: none;
    height: 1.5rem;
}
.voice-mode-controls {
    position: absolute;
    bottom: 5%;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 2rem;
    align-items: center;
}
.voice-mode-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    font-size: 1.5rem;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
}
#voice-mic-btn {
    background-color: var(--primary);
}
#voice-mic-btn.listening {
    animation: pulse 1.5s infinite;
}
#voice-hang-up-btn {
    background-color: #ef4444; /* Red */
}
#voice-hang-up-btn:hover {
    background-color: #dc2626; /* Darker Red */
}
@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.7);
    }
    70% {
        box-shadow: 0 0 0 20px rgba(79, 70, 229, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
    }
}
</style>
</head>
<body>

<div id="loader" class="loader-overlay visible">
    <div class="spinner"></div>
</div>

<div id="toast-container"></div>

<div id="personality-overlay">
    <div class="personality-modal-content">
        <button class="close-modal-btn" id="close-personality-modal-btn">&times;</button>
        <h2>Personalize Graxybot</h2>
        <label for="user-name-input">What should Graxybot call you?</label>
        <input type="text" id="user-name-input" placeholder="e.g., Alex, Boss, Friend">
        <label for="response-style-input">How do you want Graxybot to respond?</label>
        <textarea id="response-style-input" rows="3" placeholder="e.g., Be concise and funny"></textarea>
        <button id="save-personality-btn">Save Settings</button>
    </div>
</div>

<div class="chat-app" id="chat-app">
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="new-chat-btn">
                <i class="fas fa-plus"></i> New Chat
            </button>
        </div>
        <ul class="chat-list" id="chat-list">
        </ul>
        <div class="sidebar-footer">
            <button class="icon-btn" id="settings-button" title="Settings">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </aside>

    <main class="main-content" id="main-content">
        <div class="chat-top-bar">
             <button class="icon-btn menu-toggle" id="menu-toggle">
                <i class="fas fa-bars"></i>
            </button>
            <h1 id="chat-title">Graxybot</h1>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <footer class="chat-input-container">
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <button id="remove-image-button" title="Remove image">&times;</button>
            </div>
            <div class="chat-input-area">
                <input type="text" id="message-input" placeholder="Ask me anything...">
                <div class="input-actions">
                    <button id="image-upload-button" class="icon-btn" title="Attach Image"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="image-upload-input" accept="image/*">
                    <button id="create-image-button" class="icon-btn" title="Create Image"><i class="fas fa-image"></i></button>
                    <button id="mic-button" class="icon-btn" title="Start Speech Input"><i class="fas fa-microphone"></i></button>
                    <button id="send-button" class="icon-btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                </div>
            </div>
        </footer>
    </main>
</div>

<div id="voice-mode-overlay">
    <div id="voice-mode-canvas-container"></div>
    <div class="voice-mode-content">
        <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center;">
            <p id="transcribed-text"></p>
            <p id="thinking-indicator-voice">Thinking...</p>
            <p id="bot-response-text"></p>
        </div>
        <div class="voice-mode-controls">
            <button class="icon-btn voice-mode-btn" id="voice-mic-btn"><i class="fas fa-microphone"></i></button>
            <button class="icon-btn voice-mode-btn" id="voice-hang-up-btn"><i class="fas fa-phone-slash"></i></button>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

<script type="module">
    // --- Configuration ---
    const OPENAI_MODEL = "gpt-4.1-mini";
    const GPT_4_1_MODEL = "gpt-4.1";
    const DEFAULT_STABLE_DIFFUSION_API_URL = "https://mid-zero-unless-hero.trycloudflare.com";
    const OPENAI_PROXY_ENDPOINT = window.location.origin + '/openai/chat';

    // --- UI & Storage Keys ---
    const BOT_ICON_SRC = "graxybot.png";
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_minimalist_chats_v3";
    const CURRENT_CHAT_ID_KEY = "graxybot_minimalist_current_chat_id_v3";
    const PERSONALITY_STORAGE_KEY = "graxybot_minimalist_personality_v3";

    // --- DOM Element References ---
    let chatApp, chatMessagesContainer, messageInput, sendButton, createImageButton;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let loader, toastContainer, micButton, speechRecognition, isListening = false;
    let sidebar, newChatBtn, chatList, settingsButton, chatTitle, menuToggle, mainContent;
    let personalityOverlay, userNameInput, responseStyleInput, savePersonalityBtn, closePersonalityModalBtn;
    let voiceModeOverlay, voiceModeCanvasContainer, voiceMicBtn, voiceHangUpBtn, transcribedText, botResponseText, thinkingIndicatorVoice;

    // --- Application State ---
    let chats = {};
    let currentChatId = null;
    let isRequestInProgress = false;
    let isImageGenerationModeActive = false;
    let currentThinkingIndicatorElement = null;
    let selectedImageData = null, selectedImageMimeType = null, selectedImagePreviewUrl = null;
    let userPersonality = { name: null, responseStyle: null };
    
    // --- Voice Mode 3D Scene ---
    let voiceScene, voiceCamera, voiceRenderer, sphereParticles, logoParticles, particleTexture;

    // --- Core Functions ---
    function showToast(message, type = 'info', duration = 3000) {
        if (!toastContainer) return;
        const toast = document.createElement('div');
        toast.className = `toast-message ${type}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        requestAnimationFrame(() => toast.classList.add('show'));
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, duration);
    }
    function generateChatId() { return `chat_${Date.now()}`; }
    function loadData() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            chats = storedChats ? JSON.parse(storedChats) : {};
            const storedChatId = localStorage.getItem(CURRENT_CHAT_ID_KEY);
            if (storedChatId && chats[storedChatId]) {
                currentChatId = storedChatId;
            } else {
                currentChatId = null;
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
            const storedPersonality = localStorage.getItem(PERSONALITY_STORAGE_KEY);
            if (storedPersonality) userPersonality = JSON.parse(storedPersonality);
        } catch (error) {
            console.error("Error loading data:", error);
            chats = {}; currentChatId = null;
        }
    }
    function saveChats() {
        try {
            localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats));
            if (currentChatId) {
                localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId);
            } else {
                localStorage.removeItem(CURRENT_CHAT_ID_KEY);
            }
        } catch (e) { console.error("Error saving chats:", e); }
    }
    function savePersonalitySettings() {
        try {
            localStorage.setItem(PERSONALITY_STORAGE_KEY, JSON.stringify(userPersonality));
        } catch (e) { console.error("Error saving personality:", e); }
    }
    function updateActionButtonsState() {
        const isBusy = isRequestInProgress || isListening;
        sendButton.disabled = isBusy || (!messageInput.value.trim() && !selectedImageData);
        imageUploadButton.disabled = isBusy;
        micButton.disabled = isBusy;
        micButton.classList.toggle('active', isListening);
        createImageButton.disabled = isBusy;
        createImageButton.classList.toggle('active', isImageGenerationModeActive);
        settingsButton.disabled = isBusy;
    }
    function getSystemPrompt(currentModelName) {
        let basePrompt = `You are Graxybot, a helpful AI assistant.
You are currently running on the ${currentModelName} model.
Your creator is 'thegraxisreal'.
IMPORTANT: When answering any questions about Global history or geography, or solving social studies homework sheets, all answers should be 1 or 2 words, formatted in all lowercase, with absolutely no restating of the question.
When receiving said social studies sheets, questions 1-5 should be answered in 1 or 2 words in all lowercase, and the ending questions that are longer should be answered in 1 or 2 sentences, all at a 9th-grade level for those problems.
Those restrictions only apply to global history questions. All other questions should be answered in lowercase and at a normal level.
Provide only the final answer, without revealing your internal thought process or reasoning steps unless explicitly asked to explain.
Keep your responses concise, helpful, and slightly informal.
Avoid overly complex language unless necessary.
Refer to yourself as Graxybot.
IMPORTANT: If the user asks you to generate an image or video/animation, let them know they can do that by pressing the buttons at the bottom of the screen.
When asked for code, default to HTML.
When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\``;
        if (userPersonality.name) {
             basePrompt += `\nAddress the user as "${userPersonality.name}".`;
        }
        return basePrompt;
    }
    function addMessageToHistory(role, contentParts, imagePreview = null, generatedMediaSrc = null, mediaPrompt = null) {
       if (!currentChatId) { handleNewChat(false); }
       if (!chats[currentChatId]) return;
       if (role === 'user' && chats[currentChatId].history.length === 0) {
           const firstText = contentParts.find(p => p.text)?.text;
           chats[currentChatId].title = firstText ? firstText.substring(0, 30) : "New Chat";
           renderChatList();
       }
       const messageData = { role, parts: contentParts, timestamp: new Date().toISOString() };
       if (imagePreview) messageData.imagePreview = imagePreview;
       if (generatedMediaSrc) {
           messageData.generatedMediaSrc = generatedMediaSrc;
           messageData.mediaPrompt = mediaPrompt;
       }
       chats[currentChatId].history.push(messageData);
       saveChats();
    }
    function showThinkingIndicator(message = 'Thinking...') {
        removeThinkingIndicator();
        currentThinkingIndicatorElement = displayMessage([], 'bot-thinking', false, null, null, 'fa-brain', message);
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.classList.add('thinking-indicator');
            const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
            if (msgDiv) msgDiv.innerHTML = `<span></span><span></span><span></span> ${message}`;
        }
    }
    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.remove();
            currentThinkingIndicatorElement = null;
        }
    }
    function displayMessage(contentParts, sender, isError = false, imagePreview = null, generatedMediaSrc = null, customIconClass = null, mediaPrompt = null) {
        mainContent.classList.remove('new-chat-active');
        const wrapper = document.createElement('div');
        wrapper.className = 'message-content-wrapper';
        if (sender === 'user') wrapper.classList.add('user-message');
        const iconDiv = document.createElement('div');
        iconDiv.className = 'message-icon';
        if (sender === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else {
            if (customIconClass) {
                 iconDiv.innerHTML = `<i class="fas ${customIconClass}"></i>`;
            } else {
                const img = document.createElement('img');
                img.src = BOT_ICON_SRC;
                img.alt = "G";
                img.onerror = () => iconDiv.innerHTML = `<i class="fas fa-robot"></i>`;
                iconDiv.appendChild(img);
            }
        }
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'message-bubble';
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        if (isError) messageDiv.classList.add('error-message');
        const paragraph = document.createElement('p');
        paragraph.dataset.streamTarget = "true";
        let textContent = Array.isArray(contentParts) ? (contentParts.find(p => p.text)?.text || '') : '';
        if (generatedMediaSrc) {
            const media = document.createElement('img');
            media.src = generatedMediaSrc; media.className = 'generated-image';
            messageDiv.appendChild(media);
            if (mediaPrompt) paragraph.innerHTML = `<em>Prompt: ${mediaPrompt}</em>`;
        } else if (imagePreview) {
            const img = document.createElement('img');
            img.src = imagePreview; img.className = 'sent-image';
            messageDiv.appendChild(img);
        }
        if (textContent) processAndAppendText(textContent, paragraph);
        if (paragraph.hasChildNodes() || paragraph.textContent || sender === 'bot') {
            messageDiv.appendChild(paragraph);
        }
        bubbleDiv.appendChild(messageDiv);
        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);
        chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
        return wrapper;
    }
    function processAndAppendText(text, targetElement) {
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0, match;
        targetElement.innerHTML = '';
        while ((match = codeBlockRegex.exec(text)) !== null) {
            targetElement.innerHTML += text.substring(lastIndex, match.index).replace(/\n/g, '<br>');
            const lang = match[1]?.trim() || 'plaintext';
            const code = match[2].trim();
            const codeContainer = document.createElement('div');
            codeContainer.className = 'code-block-container';
            const header = document.createElement('div');
            header.className = 'code-block-header';
            header.innerHTML = `<span>${lang}</span><button title="Copy code">Copy</button>`;
            header.querySelector('button').onclick = () => handleCopyCode(code, header.querySelector('button'));
            const pre = document.createElement('pre');
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;
            pre.appendChild(codeEl);
            codeContainer.appendChild(header);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            lastIndex = codeBlockRegex.lastIndex;
        }
        targetElement.innerHTML += text.substring(lastIndex).replace(/\n/g, '<br>');
        if (window.Prism) setTimeout(() => Prism.highlightAllUnder(targetElement), 0);
    }
    function handleCopyCode(codeContent, buttonElement) {
        navigator.clipboard.writeText(codeContent).then(() => {
            showToast("Code copied!", 'success');
            buttonElement.textContent = 'Copied!';
            setTimeout(() => { buttonElement.textContent = 'Copy'; }, 2000);
        });
    }
    function renderChatList() {
        chatList.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a,b) => (chats[b].history[0]?.timestamp || 0) - (chats[a].history[0]?.timestamp || 0));
        sortedChatIds.forEach(id => {
            const li = document.createElement('li');
            li.className = 'chat-list-item';
            li.dataset.chatId = id;
            li.textContent = chats[id].title || 'Chat';
            if (id === currentChatId) li.classList.add('active');
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-chat-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteChat(id); };
            li.appendChild(deleteBtn);
            li.onclick = () => handleSelectChat(id);
            chatList.appendChild(li);
        });
    }
    function loadChat(chatId) {
        if (!chats[chatId]) return;
        currentChatId = chatId;
        saveChats();
        renderChatList();
        chatMessagesContainer.innerHTML = '';
        mainContent.classList.remove('new-chat-active');
        if (chats[chatId].history.length > 0) {
            chats[chatId].history.forEach(msg => {
                displayMessage(msg.parts, msg.role, false, msg.imagePreview, msg.generatedMediaSrc, null, msg.mediaPrompt);
            });
        } else {
             mainContent.classList.add('new-chat-active');
        }
    }
    function handleNewChat(clearUI = true) {
        const newId = generateChatId();
        chats[newId] = { history: [], title: "New Chat" };
        currentChatId = newId;
        saveChats();
        renderChatList();
        if (clearUI) {
            chatMessagesContainer.innerHTML = '';
            mainContent.classList.add('new-chat-active');
        }
    }
    function handleSelectChat(id) {
        if (id === currentChatId) return;
        sidebar.classList.remove('visible');
        loadChat(id);
    }
    function handleDeleteChat(id) {
        if (confirm(`Are you sure you want to delete "${chats[id].title}"?`)) {
            delete chats[id];
            if (currentChatId === id) {
                currentChatId = null;
                chatMessagesContainer.innerHTML = '';
                 mainContent.classList.add('new-chat-active');
            }
            saveChats();
            renderChatList();
        }
    }
    async function handleImageSelection(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) {
            showToast("Invalid image file type.", 'error'); return;
        }
        try {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => {
                selectedImageData = reader.result.split(',')[1];
                selectedImageMimeType = file.type;
                selectedImagePreviewUrl = URL.createObjectURL(file);
                imagePreview.src = selectedImagePreviewUrl;
                imagePreviewArea.style.display = 'block';
                updateActionButtonsState();
            };
            reader.onerror = () => { throw new Error("File could not be read.");};
        } catch (e) {
            showToast("Error processing image.", 'error');
            removeSelectedImage();
        }
    }
    function removeSelectedImage() {
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) URL.revokeObjectURL(selectedImagePreviewUrl);
        selectedImagePreviewUrl = null;
        imagePreviewArea.style.display = 'none';
        imageUploadInput.value = '';
        updateActionButtonsState();
    }
    async function triggerStableDiffusionGeneration(promptText) {
        showThinkingIndicator(`Generating: "${promptText.substring(0, 50)}..."`);
        isRequestInProgress = true; updateActionButtonsState();
        const payload = { prompt: promptText, negative_prompt: "blurry, low quality, deformed", steps: 25 };
        try {
            const response = await fetch(`${DEFAULT_STABLE_DIFFUSION_API_URL}/sdapi/v1/txt2img`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            removeThinkingIndicator();
            if (!response.ok) throw new Error(`API error: ${response.statusText}`);
            const data = await response.json();
            if (data.images && data.images.length > 0) {
                const imageSrc = `data:image/png;base64,${data.images[0]}`;
                displayMessage([], 'bot', false, null, imageSrc, 'fa-palette', promptText);
                addMessageToHistory('model', [{text: `Image generated`}], null, imageSrc, promptText);
            } else { throw new Error('No images in API response.'); }
        } catch (error) {
            removeThinkingIndicator();
            displayMessage([{ text: `Image Generation Error: ${error.message}` }], 'bot', true);
        } finally {
            isRequestInProgress = false; deactivateImageGenerationMode(); updateActionButtonsState();
        }
    }
    async function sendMessageToOpenAI(messages, modelName, isVoiceMode = false) {
        let paragraph;
        if (isVoiceMode) {
            thinkingIndicatorVoice.style.display = 'block';
        } else {
             const botMessageElement = displayMessage([], 'bot');
             paragraph = botMessageElement.querySelector('[data-stream-target="true"]');
        }
        
        let fullResponseText = "";
        try {
            const response = await fetch(OPENAI_PROXY_ENDPOINT, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ model: modelName, messages })
            });
            if (!response.ok) throw new Error(`Proxy error: ${response.statusText}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value);
                chunk.split('\n').forEach(line => {
                    if (line.startsWith('data: ')) {
                        const data = line.substring(6);
                        if (data === '[DONE]') return;
                        try {
                            const json = JSON.parse(data);
                            const content = json.choices[0]?.delta?.content || '';
                            if (content) {
                                fullResponseText += content;
                                if (!isVoiceMode && paragraph) {
                                   paragraph.innerHTML += content.replace(/\n/g, '<br>');
                                   chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'auto' });
                                }
                            }
                        } catch (e) { /* ignore */ }
                    }
                });
            }
            if(isVoiceMode) {
                botResponseText.textContent = fullResponseText;
            } else if (paragraph) {
                processAndAppendText(fullResponseText, paragraph);
            }
            return fullResponseText;
        } catch (error) {
            if(isVoiceMode){
                botResponseText.textContent = `Error: ${error.message}`;
            } else if (paragraph) {
                paragraph.textContent = `Error: ${error.message}`;
                paragraph.parentElement.classList.add('error-message');
            }
            throw error;
        } finally {
            if(isVoiceMode) thinkingIndicatorVoice.style.display = 'none';
        }
    }
    async function handleSendMessage(messageTextFromVoice = null) {
        const messageText = messageTextFromVoice ?? messageInput.value.trim();
        if (!messageText && !selectedImageData) return;
        
        mainContent.classList.remove('new-chat-active');
        const imageWasAttached = !!selectedImageData;
        isRequestInProgress = true; updateActionButtonsState();
        
        const userMessageParts = [];
        if (messageText) userMessageParts.push({ text: messageText });
        
        addMessageToHistory('user', userMessageParts, selectedImagePreviewUrl);
        
        if (!messageTextFromVoice) {
            displayMessage(userMessageParts, 'user', false, selectedImagePreviewUrl);
        }

        const currentPrompt = messageText;
        messageInput.value = '';
        removeSelectedImage();

        if (isImageGenerationModeActive) {
            await triggerStableDiffusionGeneration(currentPrompt);
        } else {
            const modelToUse = currentPrompt.toLowerCase().includes("code") || imageWasAttached ? GPT_4_1_MODEL : OPENAI_MODEL;
            
            const systemPrompt = getSystemPrompt(modelToUse);
            const historyForAPI = (chats[currentChatId]?.history || [])
                .slice(-10).map(msg => ({
                    role: msg.role === 'model' ? 'assistant' : 'user',
                    content: msg.parts.map(p => p.text).join(' ')
                }));
            const messagesForOpenAI = [{ role: "system", content: systemPrompt }, ...historyForAPI];
            
            try {
                const aiResponse = await sendMessageToOpenAI(messagesForOpenAI, modelToUse, !!messageTextFromVoice);
                addMessageToHistory('model', [{ text: aiResponse }]);
                return aiResponse; // Return response for voice mode loop
            } catch (error) {
                return null;
            } finally {
                isRequestInProgress = false;
                if(!messageTextFromVoice) updateActionButtonsState();
            }
        }
    }

    // --- Voice Mode & 3D Scene ---
    function createParticleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0, 
            canvas.width / 2, canvas.height / 2, canvas.width / 2
        );
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.4, 'rgba(255,255,255,0.2)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
        return new THREE.CanvasTexture(canvas);
    }
    
    function initVoiceScene() {
        voiceScene = new THREE.Scene();
        voiceCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        voiceRenderer = new THREE.WebGLRenderer({ alpha: true });
        voiceRenderer.setSize(window.innerWidth, window.innerHeight);
        voiceModeCanvasContainer.appendChild(voiceRenderer.domElement);
        voiceCamera.position.z = 5;

        particleTexture = createParticleTexture();

        const sphereGeometry = new THREE.BufferGeometry();
        const sphereParticlesCount = 3000;
        const posArray = new Float32Array(sphereParticlesCount * 3);
        for(let i = 0; i < sphereParticlesCount * 3; i++) {
            const phi = Math.acos((2 * Math.random()) - 1);
            const theta = Math.random() * 2 * Math.PI;
            const r = 2 + Math.random() * 0.2;
            posArray[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            posArray[i * 3 + 2] = r * Math.cos(phi);
        }
        sphereGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const sphereMaterial = new THREE.PointsMaterial({ 
            size: 0.05, 
            color: 0x8A2BE2,
            map: particleTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        sphereParticles = new THREE.Points(sphereGeometry, sphereMaterial);
        voiceScene.add(sphereParticles);
        
        window.addEventListener('resize', onVoiceWindowResize, false);
    }
    
    function onVoiceWindowResize() {
        if (!voiceRenderer) return;
        voiceCamera.aspect = window.innerWidth / window.innerHeight;
        voiceCamera.updateProjectionMatrix();
        voiceRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animateVoiceScene() {
        if (!voiceModeOverlay.classList.contains('visible')) return;
        requestAnimationFrame(animateVoiceScene);
        
        const time = Date.now() * 0.005;

        if (isListening && sphereParticles) {
            const scale = 1 + 0.05 * Math.sin(time * 2);
            sphereParticles.scale.set(scale, scale, scale);
        } else if (sphereParticles) {
            sphereParticles.scale.set(1, 1, 1);
        }

        if (sphereParticles) sphereParticles.rotation.y += 0.001;
        if (logoParticles) logoParticles.rotation.y -= 0.001;

        voiceRenderer.render(voiceScene, voiceCamera);
    }

    function createLogoParticles() {
        const loader = new THREE.TextureLoader();
        loader.load('graxybot.png', (texture) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = texture.image;
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, img.width, img.height);
            
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let y = 0; y < imageData.height; y+=2) {
                for (let x = 0; x < imageData.width; x+=2) {
                    const i = (y * imageData.width + x) * 4;
                    if (imageData.data[i+3] > 128) {
                        const posX = (x - imageData.width / 2) / 50;
                        const posY = (-y + imageData.height / 2) / 50;
                        positions.push(posX, posY, 0);
                    }
                }
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({ 
                size: 0.07, 
                color: 0x4f46e5,
                map: particleTexture,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            logoParticles = new THREE.Points(geometry, material);
            logoParticles.position.z = 2;
            voiceScene.add(logoParticles);
        });
    }

    function enterVoiceMode() {
        chatApp.style.transition = 'opacity 0.5s ease';
        chatApp.style.opacity = '0';
        
        voiceModeOverlay.classList.add('visible');
        
        if (!voiceScene) {
            initVoiceScene();
        }
        createLogoParticles();
        animateVoiceScene();

        setTimeout(() => {
            toggleSpeechRecognition();
        }, 500);
    }
    
    function exitVoiceMode() {
        chatApp.style.opacity = '1';
        voiceModeOverlay.classList.remove('visible');
        isListening = false;
        if(speechRecognition) speechRecognition.stop();
        if(logoParticles) voiceScene.remove(logoParticles);
        logoParticles = null;
    }

    // --- UI Toggles & Handlers ---
    function initializeSpeechRecognition() {
        const SpeechAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechAPI) { micButton.style.display = 'none'; return; }
        speechRecognition = new SpeechAPI();
        speechRecognition.onstart = () => { 
            isListening = true; 
            if(voiceModeOverlay.classList.contains('visible')){
                 botResponseText.textContent = '';
                 transcribedText.textContent = 'Listening...';
                 voiceMicBtn.classList.add('listening');
            } else {
                updateActionButtonsState(); 
                messageInput.placeholder = "Listening...";
            }
        };
        speechRecognition.onresult = (e) => { 
            const transcript = e.results[0][0].transcript;
            if(voiceModeOverlay.classList.contains('visible')){
                transcribedText.textContent = transcript;
            } else {
                 messageInput.value = transcript; 
            }
        };
        speechRecognition.onend = () => { 
            isListening = false;
            if (voiceModeOverlay.classList.contains('visible')) {
                voiceMicBtn.classList.remove('listening');
                const finalTranscript = transcribedText.textContent;
                if (finalTranscript && finalTranscript !== 'Listening...') {
                    (async () => {
                        await handleSendMessage(finalTranscript);
                        setTimeout(() => {
                            if (voiceModeOverlay.classList.contains('visible')) {
                                transcribedText.textContent = '';
                                botResponseText.textContent = '';
                                toggleSpeechRecognition();
                            }
                        }, 3000); // Increased delay to 3 seconds
                    })();
                } else if (voiceModeOverlay.classList.contains('visible')) {
                    setTimeout(toggleSpeechRecognition, 500);
                }
            } else {
                updateActionButtonsState(); 
                messageInput.placeholder = "Ask me anything..."; 
                if(messageInput.value) handleSendMessage(); 
            }
        };
        speechRecognition.onerror = (e) => { 
            console.error(e.error); 
            showToast(`Mic error: ${e.error}`, 'error'); 
            isListening = false;
            if (voiceModeOverlay.classList.contains('visible')) {
                voiceMicBtn.classList.remove('listening');
            }
            updateActionButtonsState();
        };
    }
    function toggleSpeechRecognition() {
        if(isListening) {
             speechRecognition.stop();
        } else {
             if (!speechRecognition) initializeSpeechRecognition();
             speechRecognition.start();
        }
    }
    function deactivateImageGenerationMode() {
        isImageGenerationModeActive = false;
        messageInput.placeholder = "Ask me anything...";
        updateActionButtonsState();
    }
    function handleCreateImageButtonClick() {
        isImageGenerationModeActive = !isImageGenerationModeActive;
        messageInput.placeholder = isImageGenerationModeActive ? "Enter image prompt..." : "Ask me anything...";
        updateActionButtonsState();
        messageInput.focus();
    }
    function showPersonalityModal() {
        userNameInput.value = userPersonality.name || '';
        responseStyleInput.value = userPersonality.responseStyle || '';
        personalityOverlay.classList.add('visible');
    }
    function hidePersonalityModal() {
        personalityOverlay.classList.remove('visible');
    }
    function handleSavePersonality() {
        userPersonality.name = userNameInput.value.trim() || null;
        userPersonality.responseStyle = responseStyleInput.value.trim() || '';
        savePersonalitySettings();
        showToast("Personality saved!", "success");
        hidePersonalityModal();
    }

    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        // Assign DOM elements
        loader = document.getElementById('loader');
        toastContainer = document.getElementById('toast-container');
        chatApp = document.getElementById('chat-app');
        sidebar = document.getElementById('sidebar');
        mainContent = document.getElementById('main-content');
        newChatBtn = document.getElementById('new-chat-btn');
        chatList = document.getElementById('chat-list');
        settingsButton = document.getElementById('settings-button');
        chatTitle = document.getElementById('chat-title');
        chatMessagesContainer = document.getElementById('chat-messages');
        messageInput = document.getElementById('message-input');
        sendButton = document.getElementById('send-button');
        createImageButton = document.getElementById('create-image-button');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        micButton = document.getElementById('mic-button');
        menuToggle = document.getElementById('menu-toggle');
        personalityOverlay = document.getElementById('personality-overlay');
        userNameInput = document.getElementById('user-name-input');
        responseStyleInput = document.getElementById('response-style-input');
        savePersonalityBtn = document.getElementById('save-personality-btn');
        closePersonalityModalBtn = document.getElementById('close-personality-modal-btn');
        voiceModeOverlay = document.getElementById('voice-mode-overlay');
        voiceModeCanvasContainer = document.getElementById('voice-mode-canvas-container');
        voiceMicBtn = document.getElementById('voice-mic-btn');
        voiceHangUpBtn = document.getElementById('voice-hang-up-btn');
        transcribedText = document.getElementById('transcribed-text');
        botResponseText = document.getElementById('bot-response-text');
        thinkingIndicatorVoice = document.getElementById('thinking-indicator-voice');
        
        // Load data and render UI
        loadData();
        renderChatList();
        if (currentChatId && chats[currentChatId]?.history.length > 0) {
            loadChat(currentChatId);
        } else {
            mainContent.classList.add('new-chat-active');
        }
        updateActionButtonsState();

        // Add Event Listeners
        newChatBtn.addEventListener('click', () => {
            sidebar.classList.remove('visible');
            handleNewChat(true);
        });
        settingsButton.addEventListener('click', showPersonalityModal);
        menuToggle.addEventListener('click', () => sidebar.classList.toggle('visible'));
        sendButton.addEventListener('click', ()=> handleSendMessage(null));
        messageInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { e.preventDefault(); handleSendMessage(null); } });
        messageInput.addEventListener('input', updateActionButtonsState);
        createImageButton.addEventListener('click', handleCreateImageButtonClick);
        imageUploadButton.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageSelection);
        removeImageButton.addEventListener('click', removeSelectedImage);
        micButton.addEventListener('click', enterVoiceMode);
        voiceMicBtn.addEventListener('click', toggleSpeechRecognition);
        voiceHangUpBtn.addEventListener('click', exitVoiceMode);
        closePersonalityModalBtn.addEventListener('click', hidePersonalityModal);
        savePersonalityBtn.addEventListener('click', handleSavePersonality);
        personalityOverlay.addEventListener('click', (e) => { if(e.target === personalityOverlay) hidePersonalityModal(); });
        
        loader.classList.remove('visible');
        messageInput.focus();
        console.log("Graxybot UI Initialized.");
    });
</script>
</body>
</html>
