<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graxybot</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/graxybot.png"> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" xintegrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" xintegrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbIOIEHD8HBxe7+rzMGGEAPseCS6VVuLESXNKRsQXHHMxJx/g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

<style>
/* --- Base Styles and Variables --- */
:root {
    --primary: #5e60ce;
    --primary-light: #787ae0;
    --primary-active: #4a4cc2;
    --background: #ffffff;
    --background-secondary: #f7f7f8;
    --sidebar-bg: #ececf1;
    --text-primary: #202123;
    --text-secondary: #6e6e80;
    --border-color: #d1d1db;
    --input-bg: #ffffff;
    --input-border: #d1d1db;
    --user-message-bg: #e9eaf6;
    --bot-message-bg: #ffffff;
    --error-bg: #f8d7da;
    --error-text: #721c24;
    --error-border: #f5c6cb;
    --hover-bg: #e0e0e6;
    --title-font: 'Poppins', sans-serif;
    --transition: all 0.2s ease;
    --sidebar-width: 260px;
    --code-bg: #272822;
    --code-header-bg: #3a3b35;
    --code-text-color: #f8f8f2;
    --code-button-bg: #4a4b45;
    --code-button-hover-bg: #5a5b55;
    --reason-button-bg: #f0f0f0;
    --reason-button-border: #d1d1db;
    --reason-button-text: #555;
    --reason-button-hover-bg: #e5e5e5;
    --reason-button-active-bg: var(--primary);
    --reason-button-active-border: var(--primary-active);
    --reason-button-active-text: white;
    --image-preview-border: #ccc;
    --image-remove-bg: rgba(0, 0, 0, 0.5);
    --image-remove-text: white;
    --notification-bg: #e9eaf6;
    --notification-text: #444;
    --prompt-button-bg: #f0f0f0;
    --prompt-button-hover-bg: #e5e5e5;
    --prompt-button-border: #d1d1db;
    --prompt-button-text: #333;
    --loader-color: var(--primary);
    --modal-bg: rgba(0, 0, 0, 0.6); /* For general popup */
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Poppins', sans-serif;
}

html, body {
    height: 100%;
    overflow: hidden;
    background-color: var(--background);
    color: var(--text-primary);
}

/* --- Loader Styles --- */
.loader-overlay {
    position: fixed;
    inset: 0;
    background-color: rgba(255, 255, 255, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    opacity: 1;
    visibility: visible;
}
.loader-overlay.hidden {
    opacity: 0;
    visibility: hidden;
}
.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border-left-color: var(--loader-color);
    animation: spin 1s ease infinite;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

#chat-loader {
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100%;
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.9rem;
}
#chat-loader .spinner {
    margin-bottom: 15px;
}

/* --- Layout --- */
.chat-app { display: flex; height: 100vh; }
.sidebar {
    width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color);
    display: flex; flex-direction: column; padding: 15px; transition: width 0.3s ease; flex-shrink: 0;
}
.sidebar.hidden { width: 0; padding: 0; overflow: hidden; border: none; }
.main-content { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; position: relative; }

/* --- Sidebar Elements --- */
.new-chat-btn {
    display: flex; align-items: center; gap: 10px; padding: 10px 12px; border: 1px solid var(--border-color);
    border-radius: 8px; background-color: var(--background); color: var(--text-primary); font-size: 0.9rem;
    font-weight: 500; cursor: pointer; text-align: left; width: 100%; margin-bottom: 20px;
    transition: background-color var(--transition);
}
.new-chat-btn:hover { background-color: var(--hover-bg); }
.new-chat-btn i { color: var(--primary); }
.chat-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
.chat-list-item {
    padding: 10px 12px; border-radius: 6px; margin-bottom: 5px; cursor: pointer; white-space: nowrap;
    overflow: hidden; text-overflow: ellipsis; font-size: 0.9rem; color: var(--text-primary);
    transition: background-color var(--transition); position: relative;
}
.chat-list-item:hover { background-color: var(--hover-bg); }
.chat-list-item.active { background-color: var(--primary); color: white; }
.chat-list-item .delete-chat-btn {
    position: absolute; right: 5px; top: 50%; transform: translateY(-50%); background: none; border: none;
    color: var(--text-secondary); cursor: pointer; font-size: 0.8rem; padding: 5px; display: none; line-height: 1;
}
.chat-list-item:hover .delete-chat-btn { display: block; }
.chat-list-item.active .delete-chat-btn { color: white; display: block; }
.chat-list-item .delete-chat-btn:hover { color: #e74c3c; }

/* --- Initial View (Welcome Screen) --- */
.initial-view {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column;
    justify-content: center; align-items: center; padding: 20px; text-align: center;
    background-color: var(--background); z-index: 10; opacity: 1; transition: opacity 0.3s ease;
}
.initial-view.hidden { opacity: 0; pointer-events: none; z-index: -1; }
.initial-view h1 { font-size: 3.5rem; font-weight: 700; color: var(--primary); margin-bottom: 30px; font-family: var(--title-font); }
.initial-input-area {
    width: 100%; max-width: 600px; display: flex; align-items: center; background-color: var(--input-bg);
    border: 1px solid var(--input-border); border-radius: 12px; padding: 5px 5px 5px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#initial-message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
#initial-send-button {
    display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none;
    font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer;
    width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white;
}
#initial-send-button:hover { background-color: var(--primary-light); }
#initial-send-button:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }

/* --- Chat View --- */
.chat-view { display: flex; flex-direction: column; height: 100%; width: 100%; position: relative; opacity: 1; transition: opacity 0.3s ease; }
.chat-view.hidden { opacity: 0; pointer-events: none; position: absolute; z-index: -1; }

/* Chat Top Bar */
.chat-top-bar {
    padding: 10px 25px; border-bottom: 1px solid var(--border-color); background-color: var(--background);
    flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; gap: 15px;
}
.chat-title-area {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
}
.chat-top-bar h1 { display: none; }

/* Model Selector Container */
.model-selector-container { position: relative; display: inline-block; }
#model-selector {
    font-size: 0.9rem; font-weight: 500; color: var(--text-primary); background-color: transparent; border: none;
    padding: 2px 18px 2px 0px; cursor: pointer; appearance: none; -webkit-appearance: none; -moz-appearance: none;
    outline: none; line-height: 1.4; position: relative; z-index: 1;
}
.model-selector-container::after { /* Dropdown arrow */
    content: '\f078'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 50%; right: 0px;
    transform: translateY(-50%); font-size: 0.65rem; color: var(--text-secondary); pointer-events: none; z-index: 0; transition: color var(--transition);
}
.model-selector-container:hover::after { color: var(--primary); }
#model-selector:hover { color: var(--primary); }
#model-selector:disabled { color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
#model-selector:disabled + ::after { color: var(--text-secondary); opacity: 0.7; }

/* Chat Messages Area */
.chat-messages {
    flex-grow: 1; overflow-y: auto; padding: 20px 10px; background-color: var(--background-secondary);
    display: flex; flex-direction: column; position: relative;
}
.message-content-wrapper { max-width: 800px; width: 100%; margin: 0 auto 20px auto; display: flex; gap: 10px; align-items: flex-start; }
.message-icon {
    width: 30px; height: 30px; border-radius: 50%; background-color: var(--primary); color: white; display: flex;
    align-items: center; justify-content: center; font-size: 0.9rem; flex-shrink: 0; margin-top: 5px; overflow: hidden;
}
.message-icon.user-icon { background-color: #ababc5; }
.message-icon img { width: 100%; height: 100%; object-fit: cover; }
.message-bubble { display: flex; flex-direction: column; width: fit-content; max-width: calc(100% - 45px); position: relative; }
.message {
    padding: 12px 18px; border-radius: 12px; line-height: 1.6; background-color: var(--bot-message-bg); color: var(--text-primary);
    word-wrap: break-word; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid var(--border-color);
    position: relative;
}
.user-message .message { background-color: var(--user-message-bg); }
.error-message .message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); }
.message p { margin: 0 0 5px 0; }
.message p:last-child { margin-bottom: 0; }
.message .timestamp { font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px; text-align: right; }
.message .sent-image, .message .generated-image {
    max-width: 100%;
    max-height: 400px;
    width: auto;
    height: auto;
    border-radius: 8px;
    margin-top: 8px;
    display: block;
    border: 1px solid var(--border-color);
    background-color: var(--input-bg);
}


/* --- New Chat Welcome Styles --- */
.new-chat-welcome-container {
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center; flex-grow: 1; padding: 40px 20px; color: var(--text-secondary); overflow: auto;
}
.welcome-title {
    font-size: 2.8rem; font-weight: 700; color: var(--primary); margin-bottom: 30px; font-family: var(--title-font);
}
.suggested-prompts-grid {
    display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;
    width: 100%; max-width: 700px;
}
.prompt-button {
    background-color: var(--prompt-button-bg); border: 1px solid var(--prompt-button-border); border-radius: 8px;
    padding: 12px 15px; font-size: 0.9rem; color: var(--prompt-button-text); cursor: pointer;
    transition: background-color 0.2s ease, box-shadow 0.2s ease; text-align: left; font-weight: 500; line-height: 1.4;
}
.prompt-button:hover { background-color: var(--prompt-button-hover-bg); box-shadow: 0 2px 4px rgba(0,0,0,0.08); }

/* Thinking Indicator Styles */
.local-thinking-indicator .message,
.reason-thinking-indicator .message,
.image-generating-indicator .message {
    padding: 15px 18px; display: flex; align-items: center; gap: 5px;
    background-color: var(--bot-message-bg); border: 1px solid var(--border-color); box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.local-thinking-indicator span,
.reason-thinking-indicator span,
.image-generating-indicator span {
    display: inline-block; width: 8px; height: 8px; background-color: var(--text-secondary);
    border-radius: 50%; animation: typing 1s infinite ease-in-out;
}
.local-thinking-indicator span:nth-child(1),
.reason-thinking-indicator span:nth-child(1),
.image-generating-indicator span:nth-child(1) { animation-delay: 0s; }

.local-thinking-indicator span:nth-child(2),
.reason-thinking-indicator span:nth-child(2),
.image-generating-indicator span:nth-child(2) { animation-delay: 0.1s; }

.local-thinking-indicator span:nth-child(3),
.reason-thinking-indicator span:nth-child(3),
.image-generating-indicator span:nth-child(3) { animation-delay: 0.2s; }


.reason-thinking-indicator .message-icon { background-color: var(--primary-active); }
.local-thinking-indicator .message-icon { background-color: var(--primary); }
.image-generating-indicator .message-icon { background-color: var(--primary-light); }


@keyframes typing {
    0%, 100% { transform: translateY(0); opacity: 0.5; }
    50% { transform: translateY(-4px); opacity: 1; }
}

/* Code Block Styling */
.code-block-container { background-color: var(--code-bg); border-radius: 8px; margin: 10px 0; overflow: hidden; border: 1px solid var(--code-header-bg); }
.code-block-header { display: flex; justify-content: space-between; align-items: center; background-color: var(--code-header-bg); padding: 5px 15px; color: #ccc; font-size: 0.85rem; }
.code-block-header .language-name { font-weight: 500; text-transform: lowercase; }
.code-block-buttons button { background-color: var(--code-button-bg); border: none; color: var(--code-text-color); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-left: 8px; transition: background-color var(--transition); }
.code-block-buttons button:hover { background-color: var(--code-button-hover-bg); }
.code-block-buttons button i { margin-right: 4px; }
.code-block-container pre[class*="language-"] { background: var(--code-bg) !important; margin: 0 !important; padding: 15px !important; border-radius: 0 0 8px 8px !important; border: none !important; font-size: 0.9rem; max-height: 400px; overflow: auto; white-space: pre-wrap; }
.line-numbers .line-numbers-rows { border-right-color: var(--code-header-bg) !important; }
.line-numbers-rows > span::before { color: #6272a4 !important; }

/* Chat Input Area */
.chat-input-container {
    padding: 10px 20px 15px 20px; background-color: var(--background); border-top: 1px solid var(--border-color);
    flex-shrink: 0; max-width: 840px; margin: 0 auto; width: 100%;
}
#model-notification {
    font-size: 0.8rem; color: var(--notification-text); background-color: var(--notification-bg);
    padding: 4px 10px; border-radius: 6px; margin-bottom: 8px; text-align: center; display: none;
}
.chat-input-area {
    display: flex; align-items: center; background-color: var(--input-bg);
    border: 1px solid var(--input-border); border-radius: 12px; padding: 5px 5px 5px 15px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
#message-input { flex-grow: 1; border: none; outline: none; background: transparent; font-size: 1rem; color: var(--text-primary); padding: 10px 0; resize: none; line-height: 1.5; }
.btn { display: inline-flex; align-items: center; justify-content: center; border-radius: 8px; text-decoration: none; font-weight: 500; transition: var(--transition); font-size: 1rem; border: none; cursor: pointer; width: 40px; height: 40px; flex-shrink: 0; margin-left: 10px; background-color: var(--primary); color: white; }
.btn:hover { background-color: var(--primary-light); }
.btn:disabled { background-color: var(--text-secondary); opacity: 0.7; cursor: not-allowed; }


#image-upload-button {
    background: none; border: none; color: var(--text-secondary); font-size: 1.2rem;
    padding: 0 8px; cursor: pointer; transition: color var(--transition); margin-left: 0px;
    width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0;
}
#image-upload-button:hover { color: var(--primary); }
#image-upload-input { display: none; }

.image-preview-container { margin-top: 10px; position: relative; display: inline-block; max-width: 100px; }
.image-preview-container img { display: block; max-width: 100%; height: auto; border: 1px solid var(--image-preview-border); border-radius: 6px; }
#remove-image-button {
    position: absolute; top: -5px; right: -5px; background-color: var(--image-remove-bg); color: var(--image-remove-text);
    border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 0.8rem; line-height: 20px; text-align: center; cursor: pointer; font-weight: bold;
}
#remove-image-button:hover { background-color: rgba(0, 0, 0, 0.7); }

/* Input Controls Area (Thinking, Create Image buttons) */
.input-controls-area { display: flex; align-items: center; justify-content: space-between; margin-top: 8px; flex-wrap: wrap; gap: 10px; }
.action-buttons-area { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }

#reason-button, #create-image-button { /* Combined styles */
    display: inline-flex; align-items: center; justify-content: center; padding: 6px 12px; border-radius: 8px;
    font-size: 0.85rem; font-weight: 500; cursor: pointer; border: 1px solid var(--reason-button-border);
    background-color: var(--reason-button-bg); color: var(--reason-button-text);
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
}
#reason-button:hover, #create-image-button:hover { background-color: var(--reason-button-hover-bg); }
#reason-button.active, #create-image-button.active { /* Active state for both */
    background-color: var(--reason-button-active-bg); border-color: var(--reason-button-active-border); color: var(--reason-button-active-text);
    animation: pulse-button 0.5s ease-out;
}
#reason-button:disabled, #create-image-button:disabled { opacity: 0.6; cursor: not-allowed; }
#reason-button i, #create-image-button i { margin-right: 5px; font-size: 0.8rem; }
#reason-usage-display { display: none; }

@keyframes pulse-button { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

.rate-limit-info { padding: 0; font-size: 0.85rem; color: var(--text-secondary); text-align: right; background-color: transparent; margin-top: 0; }

/* --- Popup Styles (Update Notification) --- */
#popupOverlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--modal-bg);
    z-index: 999; display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
}
#popupOverlay.visible { opacity: 1; visibility: visible; }
.popup-content {
    background: #6B46C1; color: white; padding: 25px; border-radius: 10px; max-width: 500px; width: 90%;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3); position: relative; transform: scale(0.9); transition: transform 0.3s ease;
}
#popupOverlay.visible .popup-content { transform: scale(1); }
.popup-content h2 { margin-top: 0; font-size: 24px; color: #F3E8FF; margin-bottom: 15px; }
.popup-content p { font-size: 16px; color: #E9D8FD; line-height: 1.5; margin-bottom: 10px; }
.popup-content ul { list-style-type: disc; padding-left: 25px; margin-bottom: 25px; font-size: 16px; color: #E9D8FD; }
.popup-content ul li { margin-bottom: 8px; }
.popup-content ul li strong { color: #fff; }
.popup-content button {
    padding: 10px 20px; background: #9F7AEA; color: white; border: none; border-radius: 5px; cursor: pointer;
    font-size: 16px; font-weight: 500; transition: background 0.3s ease; display: block; margin: 20px auto 0 auto;
}
.popup-content button:hover { background: #805AD5; }


/* --- Responsive Adjustments --- */
@media (max-width: 768px) {
    .sidebar { width: 200px; }
    .chat-top-bar { padding: 10px 15px; }
    #model-selector { font-size: 0.85rem; }
    .initial-view h1 { font-size: 2.5rem; }
    .message-content-wrapper { padding: 0 15px; max-width: 95%; gap: 10px;}
    .message-icon { width: 28px; height: 28px; font-size: 0.8rem;}
    .message-bubble { max-width: calc(100% - 38px); }
    .message { padding: 10px 15px; }
    .code-block-container pre[class*="language-"] { font-size: 0.85rem; }
    .chat-input-container { padding: 10px 15px; max-width: 95%; }
    .chat-input-area { padding: 5px 5px 5px 12px; }
    #message-input { font-size: 0.95rem; }
    .btn { width: 38px; height: 38px; }
    #initial-send-button { width: 38px; height: 38px; }
    #reason-button, #create-image-button { font-size: 0.8rem; padding: 5px 10px; }
    .image-preview-container { max-width: 80px; }
    #model-notification { font-size: 0.75rem; padding: 3px 8px;}
    .popup-content h2 { font-size: 20px; }
    .popup-content p, .popup-content ul { font-size: 15px; }
    .welcome-title { font-size: 2.2rem; }
    .suggested-prompts-grid { grid-template-columns: 1fr; }
}

@media (max-width: 600px) {
    body { padding: 0; }
    .chat-top-bar { padding: 8px 10px; flex-wrap: wrap; }
    .chat-title-area {
        width: 100%; flex-direction: row; align-items: center; flex-wrap: wrap;
        gap: 10px; justify-content: flex-start; margin-bottom: 5px;
    }
    #model-selector { font-size: 0.8rem; padding-right: 15px;}
    .model-selector-container::after { font-size: 0.6rem; right: 0px;}
    .initial-view h1 { font-size: 2rem; }
    .chat-messages { padding: 15px 0px; }
    .message-content-wrapper { padding: 0 10px; gap: 8px; }
    .message-icon { width: 25px; height: 25px; font-size: 0.7rem;}
    .message-bubble { max-width: calc(100% - 33px); }
    .code-block-container pre[class*="language-"] { font-size: 0.8rem; }
    .chat-input-container { padding: 8px 10px; }
    .chat-input-area { padding: 3px 3px 3px 10px; }
    #message-input { padding: 8px 0; }
    .btn { width: 36px; height: 36px; }
    #initial-send-button { width: 36px; height: 36px; }
    #reason-button, #create-image-button { font-size: 0.75rem; padding: 4px 8px; }
    .action-buttons-area { gap: 6px; }
    .image-preview-container { max-width: 60px; }
    #image-upload-button { padding: 0 8px; font-size: 1.1rem;}
    #model-notification { font-size: 0.7rem; padding: 2px 6px;}
    .popup-content { padding: 20px; }
    .popup-content h2 { font-size: 18px; }
    .popup-content p, .popup-content ul { font-size: 14px; }
    .popup-content button { padding: 8px 16px; font-size: 14px; }
    .welcome-title { font-size: 2rem; }
    .prompt-button { font-size: 0.85rem; padding: 10px; }
}

</style>
</head>
<body>

<div id="initial-loader" class="loader-overlay">
    <div class="spinner"></div>
</div>

<div id="popupOverlay">
    <div class="popup-content">
        <h2>Graxybot Web v2.0)</h2>
        <p>Key changes:</p>
        <ul>
            <li>Image Generation Now available for free!</li>
            <li>New General Intelligence Model</li>
            <li>Graxybot auto-detects Global sheets and responds accordingly</li>
            <li>Improvements to Graxybot Reasoning</li>
            <li>Removed Graxybot Max</li>
        </ul>
        <button id="closePopupButton">Close</button>
    </div>
</div>


<div class="chat-app">
    <aside class="sidebar">
        <button class="new-chat-btn" id="new-chat-btn">
            <i class="fas fa-plus"></i> New Chat
        </button>
        <ul class="chat-list" id="chat-list">
            </ul>
    </aside>

    <main class="main-content">
        <div class="initial-view" id="initial-view">
            <h1>Graxybot</h1>
            <div class="initial-input-area">
                <input type="text" id="initial-message-input" placeholder="Ask me anything...">
                <button id="initial-send-button" class="btn" title="Send Message">
                    <i class="fas fa-arrow-up"></i>
                </button>
            </div>
        </div>

        <div class="chat-view hidden" id="chat-view">
            <div class="chat-top-bar">
                <div class="chat-title-area">
                    <div class="model-selector-container">
                        <select id="model-selector">
                            <option value="graxybot">Graxybot</option>
                        </select>
                    </div>
                    <h1 id="chat-view-title">Graxybot</h1> </div>
                </div>

            <div class="chat-messages" id="chat-messages">
                 <div id="chat-loader">
                    <div class="spinner"></div>
                    <span>Loading Chat...</span>
                 </div>
                </div>

            <div class="chat-input-container">
                 <div id="model-notification" style="display: none;"></div>
                 <div class="chat-input-area">
                    <button id="image-upload-button" title="Attach Image"><i class="fas fa-paperclip"></i></button>
                    <input type="file" id="image-upload-input" accept="image/*">
                    <input type="text" id="message-input" placeholder="Message Graxybot...">
                    <button id="send-button" class="btn" title="Send Message"><i class="fas fa-arrow-up"></i></button>
                 </div>
                 <div id="image-preview-area" class="image-preview-container" style="display: none;">
                    <img id="image-preview" src="#" alt="Image preview"/>
                    <button id="remove-image-button" title="Remove image">&times;</button>
                 </div>
                 <div class="input-controls-area">
                    <div class="action-buttons-area">
                        <button id="reason-button" title="Use enhanced thinking for the next message."><i class="fas fa-brain"></i> Thinking</button>
                        <button id="create-image-button" title="Toggle image generation mode for the next message."><i class="fas fa-image"></i> Create Image</button>
                        <span id="reason-usage-display"></span> </div>
                    <div id="rate-limit-message" class="rate-limit-info" style="display: none;"></div>
                 </div>
            </div>
        </div>
    </main>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" xintegrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" xintegrity="sha512-SkmBfuA2hqjzEVNWb8CUApVR5fFWrSDcUOahSEgUd07FNMef+AbUd/yPkMkNUabIMZrcOg/1wslzAZMuUrNmA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js" xintegrity="sha512-BttltKXFyWnGZQcRWj6UJFdLmWhtQxfqVfRMS9EDGDpMh/Db82MACoMMQqGWf0Y69Fc27TwnXyIE+fsHLugUDw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script type="importmap">
{
    "imports": {
        "@google/generative-ai": "https://esm.run/@google/generative-ai"
    }
}
</script>

<script type="module">
    import { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } from "@google/generative-ai";

    // --- Configuration ---
    const API_KEY = "AIzaSyBbj7cDi0Oa86lUN5963IThL0R1pffgDkk"; // Your actual API key
    const LOCAL_MODEL_URL = "https://scotland-admit-atm-policies.trycloudflare.com";
    const DEFAULT_STABLE_DIFFUSION_API_URL = "https://animated-walked-electrical-larry.trycloudflare.com";

    // --- Model Definitions ---
    const QUEN_3_LOCAL_MODEL_NAME = "quen-3";
    const modelMapping = { "graxybot": "gemini-1.5-flash-latest" };
    const REASON_MODE_MODEL_FOR_THINKING_BUTTON = QUEN_3_LOCAL_MODEL_NAME;
    const REASON_MODE_DISPLAY_NAME = "Graxybot Quen 3";
    const DEFAULT_FAKE_MODEL = "graxybot";

    // --- UI & Storage Keys ---
    const BOT_ICON_SRC = "graxybot.png";
    const USER_ICON_CLASS = "fas fa-user";
    const CHATS_STORAGE_KEY = "graxybot_all_chats_v2";
    const CURRENT_CHAT_ID_KEY = "graxybot_current_chat_id";
    const MODEL_STORAGE_KEY = "graxybot_selected_model";

    // --- Limits & Settings ---
    const MAX_MESSAGES_PER_WINDOW = 14;
    const TIME_WINDOW_MS = 60 * 1000;
    const MIN_REASON_DELAY_MS = 1000;
    const MAX_REASON_DELAY_MS = 3000;
    let messageTimestamps = [];
    const safetySettings = [
        { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
        { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    ];

    // --- DOM Element References ---
    let chatMessagesContainer, messageInput, sendButton, rateLimitMessageDiv, modelSelector;
    let initialView, chatView, initialMessageInput, initialSendButton;
    let sidebar, newChatBtn, chatListUl;
    let reasonButton, reasonUsageDisplay, createImageButton;
    let imageUploadButton, imageUploadInput, imagePreviewArea, imagePreview, removeImageButton;
    let modelNotificationDiv;
    let popupOverlay, closePopupButton;
    let initialLoader, chatLoader;

    // --- Application State ---
    let genAI;
    let currentChatSession = null;
    let chats = {};
    let currentChatId = null;
    let isInitializing = false;
    let isReasonModeActive = false;
    let isImageGenerationModeActive = false;
    let currentThinkingIndicatorElement = null;
    let selectedImageData = null;
    let selectedImageMimeType = null;
    let selectedImagePreviewUrl = null;


    // --- Core Functions ---
    function generateChatId() { return `chat_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`; }

    function loadAllChats() {
        try {
            const storedChats = localStorage.getItem(CHATS_STORAGE_KEY);
            if (storedChats) {
                const parsedChats = JSON.parse(storedChats);
                if (typeof parsedChats === 'object' && parsedChats !== null) {
                    Object.keys(parsedChats).forEach(id => {
                        if (!parsedChats[id]) return;
                        if (!Array.isArray(parsedChats[id].history)) { parsedChats[id].history = []; }
                        parsedChats[id].history.forEach(msg => {
                            if (typeof msg.parts === 'string') {
                                msg.parts = [{ text: msg.parts }];
                            } else if (!Array.isArray(msg.parts)) {
                                msg.parts = [{ text: String(msg.parts) }];
                            }
                        });
                        parsedChats[id].model = DEFAULT_FAKE_MODEL;
                        delete parsedChats[id].personality;
                    });
                    return parsedChats;
                }
            }
        } catch (error) { console.error("Error loading chats:", error); localStorage.removeItem(CHATS_STORAGE_KEY); }
        return {};
       }

    function saveAllChats() { try { localStorage.setItem(CHATS_STORAGE_KEY, JSON.stringify(chats)); } catch (e) { console.error("Error saving chats:", e); }}
    function loadCurrentChatId() { const id = localStorage.getItem(CURRENT_CHAT_ID_KEY); return (id && chats[id]) ? id : null; }
    function saveCurrentChatId() { if (currentChatId) localStorage.setItem(CURRENT_CHAT_ID_KEY, currentChatId); else localStorage.removeItem(CURRENT_CHAT_ID_KEY); }
    function loadSelectedModelPreference() { return DEFAULT_FAKE_MODEL; }
    function saveSelectedModelPreference(name) { if (name === DEFAULT_FAKE_MODEL) localStorage.setItem(MODEL_STORAGE_KEY, name); }

    function updateActionButtonsState() {
        const thinkingOrGenerating = !!currentThinkingIndicatorElement || isInitializing;
        if (reasonButton) {
            reasonButton.title = `Use enhanced thinking (powered by ${REASON_MODE_DISPLAY_NAME} - Local) for the next message.`;
            reasonButton.disabled = thinkingOrGenerating || isImageGenerationModeActive;
            if (isReasonModeActive) reasonButton.classList.add('active'); else reasonButton.classList.remove('active');
        }
        if (createImageButton) {
            createImageButton.title = "Toggle image generation mode for the next message.";
            createImageButton.disabled = thinkingOrGenerating || isReasonModeActive;
            if (isImageGenerationModeActive) createImageButton.classList.add('active'); else createImageButton.classList.remove('active');
        }
    }


    function getSystemPrompt(fakeModelName) {
        return `You are Graxybot, a helpful AI assistant. You are currently running on the Graxybot model. Your creator is 'thegraxisreal'. IMPORTANT: When answering any questions about Global history or geography, or solving social studies homework sheets, all answers should be in as few words as possible, formatted in all lowercase, absolutly no restating for those questions. When recieving said social studies sheets, questions 1-5 should be answered in as few words in all lowercase, the ending questions that are longer should be answered in 1 or 2 sentances, all in 9th grade level for those problems. Those restrictions only apply to global history questions, all other questions should be answered in lowercase and in a normal level. Provide only the final answer, without revealing your internal thought process or reasoning steps unless explicitly asked to explain. Keep your responses concise, helpful, and slightly informal. Avoid overly complex language unless necessary. Refer to yourself as Graxybot. When asked for code, default to HTML. When generating code blocks, always use markdown format with language identifiers like \`\`\`python ... \`\`\`.`;
    }

    function addMessageToCurrentChatHistory(role, contentParts, imagePreview = null, generatedImageSrc = null, imagePrompt = null) {
       // 'contentParts' is expected to be an array of part objects (e.g., [{text: "..."}, {inline_data: ...}])
       if (!currentChatId || !chats[currentChatId]) { console.error("No active/valid chat for history."); return; }
       if (!Array.isArray(chats[currentChatId].history)) chats[currentChatId].history = [];

       let messageData = { role, parts: contentParts }; // Directly use contentParts

       if (role === 'user' && imagePreview) messageData.imagePreview = imagePreview; // For local display of user's uploaded image preview
       if (generatedImageSrc) { // For bot's generated images
            messageData.generatedImageSrc = generatedImageSrc;
            messageData.imagePrompt = imagePrompt;
       }

       chats[currentChatId].history.push(messageData);
       if (chats[currentChatId].history.filter(m => m.role === 'user').length === 1 && role === 'user') {
           const firstTextPart = contentParts.find(p => p.text);
           let firstContentSummary = "New Chat";
           if (firstTextPart && firstTextPart.text.trim()) {
               firstContentSummary = firstTextPart.text.trim();
           } else if (contentParts.some(p => p.inline_data)) {
               firstContentSummary = "[Image Sent]";
           } else if (generatedImageSrc) { // Should not happen for user's first message but good fallback
               firstContentSummary = "[Image Generated]";
           }

           chats[currentChatId].title = firstContentSummary.substring(0, 35) + (firstContentSummary.length > 35 ? '...' : '');
           renderChatList();
       }
       saveAllChats();
    }


    function showThinkingIndicator(type = 'reason', message = '') {
        removeThinkingIndicator();
        let indicatorClass, indicatorText, iconClass;

        switch(type) {
            case 'local':
                indicatorClass = 'local-thinking-indicator';
                indicatorText = `Thinking (${QUEN_3_LOCAL_MODEL_NAME})...`;
                iconClass = 'fa-robot';
                break;
            case 'image':
                indicatorClass = 'image-generating-indicator';
                indicatorText = message || 'Generating image...';
                iconClass = 'fa-image';
                break;
            case 'reason':
            default:
                indicatorClass = 'reason-thinking-indicator';
                indicatorText = 'Thinking...';
                iconClass = 'fa-brain';
                break;
        }

        currentThinkingIndicatorElement = displayMessage('', 'bot-thinking', false, null, null, iconClass);
        if (currentThinkingIndicatorElement) {
            currentThinkingIndicatorElement.classList.add(indicatorClass);
            const msgDiv = currentThinkingIndicatorElement.querySelector('.message');
            if (msgDiv) {
                msgDiv.innerHTML = `<span></span><span></span><span></span> ${indicatorText}`;
            }
        }
        updateActionButtonsState();
    }

    function removeThinkingIndicator() {
        if (currentThinkingIndicatorElement && currentThinkingIndicatorElement.parentNode) {
            try { currentThinkingIndicatorElement.parentNode.removeChild(currentThinkingIndicatorElement); }
            catch (e) { console.warn("Error removing thinking indicator:", e); }
            finally { currentThinkingIndicatorElement = null; }
        }
        document.querySelectorAll('.reason-thinking-indicator, .local-thinking-indicator, .image-generating-indicator').forEach(el => {
            try { el.parentNode?.removeChild(el); } catch (e) { /* ignore */ }
        });
        updateActionButtonsState();
    }

    function displayMessage(contentParts, sender, isError = false, imagePreview = null, generatedImageSrc = null, customIconClass = null, imagePrompt = null) {
        // contentParts is expected to be an array like [{text: "..."}, {inline_data: ...}] or just text string for older calls
        if (!chatMessagesContainer) { console.error("Chat message container not found."); return null; }
        const wrapper = document.createElement('div');
        wrapper.classList.add('message-content-wrapper');

        let actualSenderType = sender;
        if (sender === 'bot-thinking') actualSenderType = 'bot';

        if (actualSenderType === 'user') wrapper.classList.add('user-message');
        else if (actualSenderType === 'bot') wrapper.classList.add('bot-message');
        if (isError) wrapper.classList.add('error-message');

        const iconDiv = document.createElement('div');
        iconDiv.classList.add('message-icon');

        if (actualSenderType === 'user') {
            iconDiv.classList.add('user-icon');
            iconDiv.innerHTML = `<i class="${USER_ICON_CLASS}"></i>`;
        } else {
            if (customIconClass) {
                 iconDiv.innerHTML = `<i class="fas ${customIconClass}"></i>`;
            } else {
                const img = document.createElement('img');
                img.src = BOT_ICON_SRC; img.alt = "G";
                img.onerror = () => iconDiv.innerHTML = `<i class="fas fa-robot"></i>`;
                iconDiv.appendChild(img);
            }
        }

        const bubbleDiv = document.createElement('div');
        bubbleDiv.classList.add('message-bubble');
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');

        if (sender === 'bot-thinking') {
            // Dots and text are added by showThinkingIndicator
        } else {
            const paragraph = document.createElement('p');
            paragraph.dataset.streamTarget = "true";
            let textFromParts = "";

            if (Array.isArray(contentParts)) {
                const textPart = contentParts.find(part => part.text);
                if (textPart) textFromParts = textPart.text;
            } else if (typeof contentParts === 'string') { // Fallback for direct string content
                textFromParts = contentParts;
            }


            if (generatedImageSrc) { // For bot displaying a generated image
                const imgElement = document.createElement('img');
                imgElement.src = generatedImageSrc;
                imgElement.alt = imagePrompt || "Generated image";
                imgElement.classList.add('generated-image');
                messageDiv.appendChild(imgElement);
                if (imagePrompt) { // Display prompt under generated image
                    paragraph.innerHTML = `<em>Prompt: ${imagePrompt.replace(/\n/g, '<br>')}</em>`;
                } else if (textFromParts) { // Fallback to any other text if no specific prompt
                     processAndAppendText(textFromParts, paragraph);
                }
            } else if (actualSenderType === 'user' && imagePreview) { // For user displaying their uploaded image preview
                const imgElement = document.createElement('img');
                imgElement.src = imagePreview;
                imgElement.alt = "Sent image preview";
                imgElement.classList.add('sent-image');
                messageDiv.appendChild(imgElement); // Image first for user
                if (textFromParts) { // Then text
                    processAndAppendText(textFromParts, paragraph);
                }
            } else if (textFromParts) { // For regular text messages (bot or user without image)
                processAndAppendText(textFromParts, paragraph);
            } else if (!imagePreview && !generatedImageSrc && actualSenderType !== 'bot') { // User sent truly empty message
                 paragraph.textContent = "[Empty Message]";
            }


            // Only append paragraph if it has content OR if it's for a generated image prompt display
            if (paragraph.hasChildNodes() || paragraph.textContent) {
                 messageDiv.appendChild(paragraph);
            }


            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('timestamp');
            timestampSpan.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            bubbleDiv.appendChild(timestampSpan);
        }
        bubbleDiv.appendChild(messageDiv);
        wrapper.appendChild(iconDiv);
        wrapper.appendChild(bubbleDiv);
        chatMessagesContainer.appendChild(wrapper);
        requestAnimationFrame(() => chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' }));
        return wrapper;
    }

    function processAndAppendText(text, targetElement) {
        const codeBlockRegex = /```(\w+)?\s*([\s\S]*?)```/g;
        let lastIndex = 0;
        let match;
        let hasCode = false;
        targetElement.innerHTML = '';

        while ((match = codeBlockRegex.exec(text)) !== null) {
            hasCode = true;
            const textBefore = text.substring(lastIndex, match.index);
            targetElement.innerHTML += textBefore.replace(/\n/g, '<br>');

            const lang = match[1]?.trim() || 'plaintext';
            const code = match[2].trim();
            const codeContainer = document.createElement('div');
            codeContainer.classList.add('code-block-container');
            const header = document.createElement('div');
            header.classList.add('code-block-header');
            const langSpan = document.createElement('span');
            langSpan.classList.add('language-name');
            langSpan.textContent = lang;
            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('code-block-buttons');
            const copyBtn = document.createElement('button');
            copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
            copyBtn.title = "Copy code";
            copyBtn.onclick = ((codeToCopy) => () => handleCopyCode(codeToCopy, copyBtn))(code);
            buttonsDiv.appendChild(copyBtn);
            const lowerLang = lang.toLowerCase();
            if (['html', 'javascript', 'js'].includes(lowerLang)) {
                const runBtn = document.createElement('button');
                runBtn.innerHTML = '<i class="fas fa-play"></i> Run';
                runBtn.title = `Run ${lang} code snippet`;
                runBtn.onclick = ((codeToRun, langToRun) => () => handleRunCode(codeToRun, langToRun))(code, lowerLang);
                buttonsDiv.appendChild(runBtn);
            }
            header.appendChild(langSpan);
            header.appendChild(buttonsDiv);
            codeContainer.appendChild(header);
            const pre = document.createElement('pre');
            pre.className = 'line-numbers';
            const codeEl = document.createElement('code');
            codeEl.className = `language-${lang}`;
            codeEl.textContent = code;
            pre.appendChild(codeEl);
            codeContainer.appendChild(pre);
            targetElement.appendChild(codeContainer);
            lastIndex = codeBlockRegex.lastIndex;
        }
        const textAfter = text.substring(lastIndex);
        targetElement.innerHTML += textAfter.replace(/\n/g, '<br>');
        if (hasCode && window.Prism) {
            setTimeout(() => Prism.highlightAllUnder(targetElement.closest('.message-bubble') || targetElement), 0);
        }
        return hasCode;
    }
    function createTextMessageDiv(text) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message');
        const paragraph = document.createElement('p');
        paragraph.textContent = text;
        messageDiv.appendChild(paragraph);
        return messageDiv;
    }
    function handleCopyCode(codeContent, buttonElement) {
        navigator.clipboard.writeText(codeContent).then(() => {
            console.log("Code copied");
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
            buttonElement.disabled = true;
            setTimeout(() => { buttonElement.innerHTML = originalText; buttonElement.disabled = false; }, 1500);
        }).catch(err => {
            console.error('Failed to copy code: ', err);
            const originalText = buttonElement.innerHTML;
            buttonElement.innerHTML = '<i class="fas fa-times"></i> Error';
            setTimeout(() => { buttonElement.innerHTML = originalText; buttonElement.disabled = false; }, 2000);
        });
    }
    function handleRunCode(codeContent, language) {
         console.log(`Running ${language} code...`);
        try {
            let htmlToRun = '';
            if (language === 'html') { htmlToRun = codeContent; }
            else if (language === 'javascript' || language === 'js') {
                htmlToRun = `<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>JS Runner</title><style>body{font-family:monospace;background-color:#f0f0f0;padding:15px;font-size:.9em;color:#333}h1{font-size:1.2em;color:#555;border-bottom:1px solid #ccc;padding-bottom:5px;margin-bottom:10px}pre{background-color:#fff;padding:10px;border:1px solid #ccc;border-radius:5px;white-space:pre-wrap;word-wrap:break-word;font-size:.95em;max-height:80vh;overflow-y:auto}.error{color:#D8000C;font-weight:700;background-color:#FFD2D2;padding:2px 4px;border-radius:3px}.log-entry{margin-bottom:4px}</style></head><body><h1>JavaScript Output:</h1><pre id="output"></pre><script>
const outputElement=document.getElementById("output"),originalConsoleLog=console.log,originalConsoleError=console.error,logHistory=[];const formatArg=e=>{if(e instanceof Error)return\`Error: \${e.message}\n\${e.stack}\`;if("object"==typeof e&&null!==e)try{return JSON.stringify(e,null,2)}catch{return String(e)}return String(e)};console.log=(...e)=>{const o=e.map(formatArg).join(" ");logHistory.push(\`<div class="log-entry">\${o.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>\`),outputElement.innerHTML=logHistory.join(""),originalConsoleLog.apply(console,e)},console.error=(...e)=>{const o=e.map(formatArg).join(" ");logHistory.push(\`<div class="log-entry error">ERROR: \${o.replace(/</g,"&lt;").replace(/>/g,"&gt;")}</div>\`),outputElement.innerHTML=logHistory.join(""),originalConsoleError.apply(console,e)},window.addEventListener("unhandledrejection",e=>{console.error("Unhandled Promise Rejection:",e.reason)}),window.addEventListener("error",e=>{console.error("Script Error:",e.message,"at",e.filename,":",e.lineno)});try{${codeContent}}catch(e){console.error("Execution Error:",e)}<\/script></body></html>`;
            } else { console.warn("Run action not supported for language:", language); alert(`Running code directly is not supported for ${language}.`); return; }
            const newTab = window.open('about:blank', '_blank');
            if (newTab) { newTab.document.open(); newTab.document.write(htmlToRun); newTab.document.close(); console.log("Code execution tab opened."); }
            else { alert("Could not open new tab. Please check if pop-ups are blocked."); }
        } catch (error) { console.error("Error preparing or running code:", error); alert("An error occurred while trying to run the code."); }
    }
    function isRateLimited() {
        const now = Date.now();
        messageTimestamps = messageTimestamps.filter(timestamp => now - timestamp < TIME_WINDOW_MS);
        if (messageTimestamps.length >= MAX_MESSAGES_PER_WINDOW) {
            console.warn(`Rate limit exceeded: ${messageTimestamps.length} messages in ${TIME_WINDOW_MS / 1000}s. Max ${MAX_MESSAGES_PER_WINDOW}/${TIME_WINDOW_MS/1000/60}min.`);
            if (rateLimitMessageDiv) {
                rateLimitMessageDiv.textContent = `Rate limit: ${MAX_MESSAGES_PER_WINDOW} msg/${TIME_WINDOW_MS / 1000 / 60} min. Wait.`;
                rateLimitMessageDiv.style.display = 'block';
                setTimeout(() => { if (rateLimitMessageDiv) rateLimitMessageDiv.style.display = 'none'; }, 3000);
            }
            return true;
        }
        return false;
    }
    function switchToChatView() {
        if (initialView) initialView.classList.add('hidden');
        if (chatView) chatView.classList.remove('hidden');
        if (reasonButton) reasonButton.style.display = 'inline-flex';
        if (createImageButton) createImageButton.style.display = 'inline-flex';
        if (reasonUsageDisplay) reasonUsageDisplay.style.display = 'none';
        updateModelNotification(DEFAULT_FAKE_MODEL);
    }
    function switchToInitialView() {
        if (initialView) initialView.classList.remove('hidden');
        if (chatView) chatView.classList.add('hidden');
        if (reasonButton) reasonButton.style.display = 'none';
        if (createImageButton) createImageButton.style.display = 'none';
        if (reasonUsageDisplay) reasonUsageDisplay.style.display = 'none';
        if (modelNotificationDiv) modelNotificationDiv.style.display = 'none';
        currentChatId = null;
        saveCurrentChatId();
        currentChatSession = null;
        if (chatMessagesContainer) chatMessagesContainer.innerHTML = '';
        updateActiveChatListItem();
        if (modelSelector) modelSelector.value = loadSelectedModelPreference();
        deactivateReasonMode();
        deactivateImageGenerationMode();
        removeSelectedImage();
    }
    function renderChatList() {
        if (!chatListUl) return;
        chatListUl.innerHTML = '';
        const sortedChatIds = Object.keys(chats).sort((a, b) => {
            const timeA = parseInt(a.split('_')[1] || '0');
            const timeB = parseInt(b.split('_')[1] || '0');
            return timeB - timeA;
        });
        sortedChatIds.forEach(chatId => {
            const chatData = chats[chatId];
            if (!chatData) return;
            const li = document.createElement('li');
            li.classList.add('chat-list-item');
            li.dataset.chatId = chatId;
            const titleText = chatData.title || `Chat ${chatId.substring(chatId.length - 5)}`;
            li.textContent = titleText;
            li.title = titleText;
            if (chatId === currentChatId) { li.classList.add('active'); }
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-chat-btn');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.title = "Delete Chat";
            deleteBtn.onclick = (event) => { event.stopPropagation(); handleDeleteChat(chatId); };
            li.appendChild(deleteBtn);
            li.addEventListener('click', () => { handleSelectChat(chatId); });
            chatListUl.appendChild(li);
        });
    }
    function updateActiveChatListItem() {
        if (!chatListUl) return;
        const items = chatListUl.querySelectorAll('.chat-list-item');
        items.forEach(item => { item.classList.toggle('active', item.dataset.chatId === currentChatId); });
    }
    function updateModelNotification(selectedModelName) {
        if (!modelNotificationDiv) return;
        modelNotificationDiv.style.display = 'none';
    }
    function deactivateReasonMode() {
        isReasonModeActive = false;
        updateActionButtonsState();
    }
    function deactivateImageGenerationMode() {
        isImageGenerationModeActive = false;
        if(messageInput && messageInput.placeholder === "Enter image prompt...") { // Reset placeholder if it was changed
            messageInput.placeholder = "Message Graxybot...";
        }
        updateActionButtonsState();
    }

    function fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => { const base64String = reader.result.split(',')[1]; resolve(base64String); };
            reader.onerror = error => reject(error);
        });
    }
    async function handleImageSelection(event) {
        const file = event.target.files[0];
        if (!file) return;
        const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
        if (!allowedTypes.includes(file.type)) { alert("Please select a valid image file (JPEG, PNG, GIF, WebP)."); imageUploadInput.value = ''; return; }
        const maxSizeMB = 4;
        if (file.size > maxSizeMB * 1024 * 1024) { alert(`Image size exceeds ${maxSizeMB}MB limit.`); imageUploadInput.value = ''; return; }
        try {
            selectedImageData = await fileToBase64(file);
            selectedImageMimeType = file.type;
            if (selectedImagePreviewUrl) { URL.revokeObjectURL(selectedImagePreviewUrl); }
            selectedImagePreviewUrl = URL.createObjectURL(file);
            displayImagePreview(selectedImagePreviewUrl);
        } catch (error) { console.error("Error processing image:", error); alert("Error processing image. Please try again."); removeSelectedImage(); }
    }
    function displayImagePreview(imageUrl) {
        if (imagePreview && imagePreviewArea) { imagePreview.src = imageUrl; imagePreviewArea.style.display = 'inline-block'; }
    }
    function removeSelectedImage() {
        selectedImageData = null; selectedImageMimeType = null;
        if (selectedImagePreviewUrl) { URL.revokeObjectURL(selectedImagePreviewUrl); selectedImagePreviewUrl = null; }
        if (imagePreviewArea) { imagePreviewArea.style.display = 'none'; }
        if (imagePreview) { imagePreview.src = '#'; }
        if (imageUploadInput) { imageUploadInput.value = ''; }
        console.log("Selected image removed.");
    }

    async function initializeAICurrentChat() {
         if (isInitializing) { console.warn("AI Initialization already in progress."); return; }
        isInitializing = true;
        console.log(`Attempting to initialize AI for chat: ${currentChatId}`);

        if (chatLoader) chatLoader.style.display = 'flex';
        if (chatMessagesContainer) chatMessagesContainer.innerHTML = '';
        if (chatLoader && !chatMessagesContainer.contains(chatLoader)) {
             chatMessagesContainer.appendChild(chatLoader);
        }

        if (!currentChatId || !chats[currentChatId]) {
            console.log("No active chat selected or chat data missing. Switching to initial view.");
            switchToInitialView();
            isInitializing = false;
            if (chatLoader) chatLoader.style.display = 'none';
            return;
        }

        const chatData = chats[currentChatId];
        const fakeModelNameToUse = DEFAULT_FAKE_MODEL;
        const historyToLoad = chatData.history || [];

        console.log(`Initializing AI for chat ${currentChatId} - Model: ${fakeModelNameToUse}`);

        modelSelector.value = fakeModelNameToUse;
        updateModelNotification(fakeModelNameToUse);

        if(messageInput) messageInput.disabled = true;
        if(sendButton) sendButton.disabled = true;
        deactivateReasonMode();
        deactivateImageGenerationMode();
        removeSelectedImage();
        currentChatSession = null;

        try {
            if (!API_KEY || API_KEY === "YOUR_GOOGLE_AI_API_KEY" || (API_KEY.startsWith("AIzaSyB") && API_KEY.length < 30)) {
                throw new Error("Google AI API Key is missing, invalid, or a placeholder. Graxybot (Google AI) features will not work.");
            }
             if (!genAI) {
                genAI = new GoogleGenerativeAI(API_KEY);
                console.log("GoogleGenerativeAI client initialized.");
            }

            if (chatLoader) chatLoader.style.display = 'none';
            if (chatMessagesContainer.contains(chatLoader)) {
                 chatMessagesContainer.removeChild(chatLoader);
            }

            if (historyToLoad.length > 0) {
                historyToLoad.forEach(message => {
                    if (message.generatedImageSrc) { // Bot generated image
                        displayMessage(message.parts, message.role, false, null, message.generatedImageSrc, 'fa-palette', message.imagePrompt);
                    } else { // User message (may have imagePreview) or regular bot text
                        displayMessage(message.parts, message.role, false, message.imagePreview || null);
                    }
                });
            } else {
                 console.log("Chat history empty, displaying welcome message.");
                 displayNewChatWelcome(chatMessagesContainer);
            }

            setTimeout(() => { if(chatMessagesContainer) chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight; }, 100);

            if(messageInput) messageInput.disabled = false;
            if(sendButton) sendButton.disabled = false;
            if(messageInput) messageInput.focus();
            updateActionButtonsState();

            console.log(`AI Initialized successfully for chat ${currentChatId}. Ready for interaction.`);

        } catch (error) {
            console.error(`Error initializing AI for chat ${currentChatId}:`, error);
            if (chatLoader) chatLoader.style.display = 'none';
            if (chatMessagesContainer.contains(chatLoader)) {
                 chatMessagesContainer.removeChild(chatLoader);
            }
            displayMessage([{text: `AI Initialization Error: ${error.message}. Please check the API Key and console for details.`}], 'bot', true);
            if(sendButton) sendButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
            if (reasonButton) reasonButton.disabled = true;
            if (createImageButton) createImageButton.disabled = true;
            if(messageInput) messageInput.disabled = true;
            if(sendButton) sendButton.disabled = true;
        } finally {
            isInitializing = false;
        }
    }

    async function triggerStableDiffusionGeneration(promptText) {
        if (currentThinkingIndicatorElement) {
            console.log("Image generation request ignored, another operation is in progress.");
            return;
        }
        console.log(`Image generation triggered for prompt: "${promptText}"`);

        const welcomeContainer = chatMessagesContainer?.querySelector('.new-chat-welcome-container');
        if (welcomeContainer) chatMessagesContainer.innerHTML = '';

        if (!currentChatId) {
             handleNewChat();
             await new Promise(resolve => setTimeout(resolve, 0));
        }

        showThinkingIndicator('image', `Generating: "${promptText.substring(0,50)}..."`);

        const payload = {
            prompt: promptText,
            negative_prompt: "blurry, low quality, ugly, deformed, watermark, text, signature, words, letters, writing",
            steps: 25,
            cfg_scale: 7.0,
            width: 512,
            height: 512,
            seed: -1,
        };

        let apiEndpoint = DEFAULT_STABLE_DIFFUSION_API_URL.trim();
        if (apiEndpoint && !apiEndpoint.endsWith('/sdapi/v1/txt2img') && !apiEndpoint.endsWith('/sdapi/v1/img2img')) {
            if (!apiEndpoint.endsWith('/')) {
                apiEndpoint += '/';
            }
            apiEndpoint += 'sdapi/v1/txt2img';
        }

        try {
            console.log("Sending request to Stable Diffusion API:", apiEndpoint);
            console.log("Payload:", JSON.stringify(payload, null, 2));

            const response = await fetch(apiEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                body: JSON.stringify(payload)
            });

            removeThinkingIndicator();

            if (!response.ok) {
                let errorData;
                try { errorData = await response.json(); } catch (e) { /* ignore */ }
                const errorDetail = errorData?.detail || errorData?.error || JSON.stringify(errorData) || response.statusText;
                throw new Error(`API returned error: ${response.status} - ${errorDetail}`);
            }

            const data = await response.json();
            console.log("Stable Diffusion API Success Response:", data);

            if (data.images && data.images.length > 0) {
                const base64Image = data.images[0];
                const imageSrc = `data:image/png;base64,${base64Image}`;
                displayMessage([{text: promptText}], 'bot', false, null, imageSrc, 'fa-palette', promptText); // Pass prompt in parts
                addMessageToCurrentChatHistory('model', [{text: promptText}], null, imageSrc, promptText);
            } else {
                throw new Error('No images found in the API response.');
            }

        } catch (error) {
            console.error('Error generating image with Stable Diffusion:', error);
            removeThinkingIndicator();
            displayMessage([{text: `Stable Diffusion Error: ${error.message}. Check console.`}], 'bot', true);
            addMessageToCurrentChatHistory('model', [{ text: `[Stable Diffusion Error: ${error.message}]` }]);
        } finally {
            deactivateImageGenerationMode();
            if (messageInput) messageInput.disabled = false;
            if (sendButton) sendButton.disabled = false;
            if (initialSendButton) initialSendButton.disabled = false;
            if (imageUploadButton) imageUploadButton.disabled = false;
            updateActionButtonsState();
            if (messageInput && !messageInput.disabled) messageInput.focus();
        }
    }


    async function sendMessageInternal(messageText, isInitialMessage = false) {
        if ((!messageText && !selectedImageData && !isImageGenerationModeActive) || // Allow empty text if image mode active
            (currentThinkingIndicatorElement && !(isImageGenerationModeActive && messageText)) // Allow sending prompt if image mode is active even if indicator is shown for a moment
           ) {
            if (isImageGenerationModeActive && !messageText && !selectedImageData) {
                // If image mode is on but no text and no image, prompt user.
                displayMessage([{text:"Image generation mode is active. Please type a prompt or attach an image to describe."}], 'bot', true);
                return;
            }
            if (currentThinkingIndicatorElement) {
                 console.log("Send prevented: thinking/generation indicator active.");
                 return;
            }
            if (!messageText && !selectedImageData) {
                console.log("Send prevented: Empty message and no image selected.");
                return;
            }
        }

        const localSelectedImageData = selectedImageData;
        const localSelectedImageMimeType = selectedImageMimeType;
        const localSelectedImagePreviewUrl = selectedImagePreviewUrl;

        // Build the user's message parts (text and/or uploaded image)
        const userMessagePayloadParts = [];
        if (messageText) {
            userMessagePayloadParts.push({ text: messageText });
        }
        if (localSelectedImageData && localSelectedImageMimeType) {
            userMessagePayloadParts.push({ inline_data: { mime_type: localSelectedImageMimeType, data: localSelectedImageData } });
        }


        if (isImageGenerationModeActive) {
            if (messageText) { // Use typed text as prompt
                displayMessage(userMessagePayloadParts, 'user', false, localSelectedImagePreviewUrl); // Display what user sent
                addMessageToCurrentChatHistory('user', userMessagePayloadParts, localSelectedImagePreviewUrl);
                if (messageInput) messageInput.value = '';
                if (initialMessageInput) initialMessageInput.value = '';
                removeSelectedImage(); // Clear uploaded image after it's logged/displayed as part of prompt.

                await triggerStableDiffusionGeneration(messageText); // Generate image with this text
                return;
            } else { // No text, but image mode is on. This shouldn't happen if initial check is good.
                displayMessage([{text:"Image generation mode is active. Please type a prompt."}], 'bot', true);
                return;
            }
        }

        // --- Regular message or "Thinking" mode processing ---
        let chatIdForMessage = currentChatId;
        const welcomeContainer = chatMessagesContainer?.querySelector('.new-chat-welcome-container');
        if (welcomeContainer) chatMessagesContainer.innerHTML = '';

        if (!chatIdForMessage) {
            console.log(`No active chat. Creating new chat...`);
            const newChatId = generateChatId();
            chats[newChatId] = { history: [], model: DEFAULT_FAKE_MODEL, title: "New Chat" };
            currentChatId = newChatId; chatIdForMessage = newChatId;
            console.log(`Created and activated new chat: ${currentChatId}`);
            saveCurrentChatId(); saveAllChats(); renderChatList(); updateActiveChatListItem();
            deactivateReasonMode();
            deactivateImageGenerationMode();
        }

        // Display user message (text and/or attached image)
        // Ensure partsForDisplayAndHistory is correctly formed even if only an image is sent
        let partsForDisplayAndHistory;
        if (userMessagePayloadParts.length > 0) {
            partsForDisplayAndHistory = userMessagePayloadParts;
        } else if (localSelectedImagePreviewUrl) { // Fallback if only preview exists (should mean inline_data was also there)
            partsForDisplayAndHistory = [{ text: "[Image Sent]" }]; // Should ideally not be needed if userMessagePayloadParts is robust
        } else {
            // This case means messageText was empty AND no image was selected.
            // The initial check in sendMessageInternal should prevent this.
            // If somehow reached, send an empty text part to avoid errors.
            partsForDisplayAndHistory = [{ text: "" }];
        }

        displayMessage(partsForDisplayAndHistory, 'user', false, localSelectedImagePreviewUrl);
        addMessageToCurrentChatHistory('user', partsForDisplayAndHistory, localSelectedImagePreviewUrl);

        removeSelectedImage(); // Clear uploaded image after it's been processed for this message

        if (!chatIdForMessage || !chats[chatIdForMessage]) { console.error("Chat ID/data invalid."); return; }

        if (messageInput) messageInput.disabled = true;
        if (sendButton) sendButton.disabled = true;
        if (initialSendButton) initialSendButton.disabled = true;
        // Action buttons (Thinking, Create Image) are disabled by showThinkingIndicator
        updateActionButtonsState(); // Explicitly disable here too
        if (imageUploadButton) imageUploadButton.disabled = true;


        if (isReasonModeActive) {
            console.log(`Thinking mode active. Using local model: ${REASON_MODE_MODEL_FOR_THINKING_BUTTON}.`);
            showThinkingIndicator('local');
            let botMessageElement = null;
            try {
                const delay = Math.random() * (MAX_REASON_DELAY_MS - MIN_REASON_DELAY_MS) + MIN_REASON_DELAY_MS;
                console.log(`Local Quen 3: Simulating thinking for ${Math.round(delay / 1000)}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                if (!currentThinkingIndicatorElement) { console.log("Quen 3 call aborted."); return; }

                const promptForLocalQuen3 = `User query: ${messageText || (localSelectedImageData ? "Describe the image." : "...")}\n\n(Respond directly to the user's query with a detailed and insightful answer. Do not explain your thought process. Do not introduce yourself or mention your capabilities unless specifically asked.)`;
                const requestBody = { message: promptForLocalQuen3, model: REASON_MODE_MODEL_FOR_THINKING_BUTTON };

                const response = await fetch(`${LOCAL_MODEL_URL}/chat`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody)
                });
                removeThinkingIndicator();
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Local Quen 3 server request failed: ${response.status} ${errorText || response.statusText}`);
                }
                const data = await response.json();
                if (data && data.response) {
                    const botResponseText = data.response;
                    botMessageElement = displayMessage([{text: botResponseText}], 'bot');
                    addMessageToCurrentChatHistory('model', [{ text: botResponseText }]);
                } else { throw new Error(`Invalid response from local Quen 3 server.`); }
            } catch (error) {
                console.error(`Error with local Quen 3:`, error);
                removeThinkingIndicator();
                displayMessage([{text: `Error with Quen 3: ${error.message}`}], 'bot', true);
                addMessageToCurrentChatHistory('model', [{ text: `[Error with Quen 3: ${error.message}]` }]);
            }
        } else { // Standard Gemini call
            console.log("Standard Graxybot call (Google AI Flash).");
            const modelToUseGoogle = modelMapping[DEFAULT_FAKE_MODEL];
            const systemPromptForSendGoogle = getSystemPrompt(DEFAULT_FAKE_MODEL);

            // userMessagePayloadParts already contains the text and/or inline_data for the current user message
            const contentPartsForGoogleAI = [...userMessagePayloadParts];

            if (contentPartsForGoogleAI.length === 0) {
                console.warn("No content for Google AI. This should not happen if initial checks are correct.");
                // Re-enable buttons and return
                removeThinkingIndicator();
                deactivateReasonMode(); // Also deactivates image mode via updateActionButtonsState
                if (messageInput) messageInput.disabled = false;
                if (sendButton) sendButton.disabled = false;
                if (initialSendButton) initialSendButton.disabled = false;
                if (imageUploadButton) imageUploadButton.disabled = false;
                updateActionButtonsState();
                return;
            }


            let botMessageElement = null, botMessageBubble = null, botMessageParagraph = null;
            let fullResponseText = "";
            try {
                if (!genAI) throw new Error("Google AI Client not initialized.");
                const modelInstance = genAI.getGenerativeModel({ model: modelToUseGoogle, safetySettings });
                const mainHistory = chats[chatIdForMessage]?.history || [];

                // History for API should now correctly include inline_data for user messages
                const historyForAPI = mainHistory
                    .slice(-10) // Get last 10 messages (user or model)
                    .filter(msg => (msg.role === 'user' || msg.role === 'model') && Array.isArray(msg.parts) && msg.parts.length > 0)
                    .map(msg => ({
                        role: msg.role,
                        parts: msg.parts.map(part => { // Ensure parts are correctly formatted for API
                            if (part.text !== undefined) return { text: part.text }; // Allow empty string for text
                            if (part.inline_data) return { inline_data: { mime_type: part.inline_data.mime_type, data: part.inline_data.data }};
                            return null; // Should not happen if parts are well-formed
                        }).filter(p => p !== null)
                    }))
                    .filter(msg => msg.parts.length > 0); // Ensure message still has valid parts


                const streamResult = await modelInstance.generateContentStream({
                    contents: [...historyForAPI, { role: "user", parts: contentPartsForGoogleAI }],
                    systemInstruction: { role: "system", parts: [{ text: systemPromptForSendGoogle }] }
                });
                botMessageElement = displayMessage([], 'bot'); // Display empty initially for streaming
                if (botMessageElement) {
                    botMessageBubble = botMessageElement.querySelector('.message-bubble');
                    botMessageParagraph = botMessageBubble?.querySelector('p[data-stream-target="true"]');
                }
                if (!botMessageParagraph) throw new Error("Target paragraph for streaming not found.");

                for await (const chunk of streamResult.stream) {
                    const blockReason = chunk.promptFeedback?.blockReason;
                    if (blockReason) { fullResponseText = `[Response blocked: ${blockReason}]`; break; }
                    const chunkText = chunk.text(); fullResponseText += chunkText;
                    botMessageParagraph.innerHTML += chunkText.replace(/\n/g, '<br>');
                    chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
                }
                addMessageToCurrentChatHistory('model', [{ text: fullResponseText }]);
            } catch (error) {
                console.error("Google AI Error:", error);
                if (botMessageElement && botMessageElement.parentNode && !fullResponseText) botMessageElement.parentNode.removeChild(botMessageElement);
                displayMessage([{text: `Graxybot Error: ${error.message}`}], 'bot', true);
                addMessageToCurrentChatHistory('model', [{ text: `[Error: ${error.message || 'Unknown'}]` }]);
            }
        }
        // Deactivate modes and re-enable inputs
        deactivateReasonMode(); // Will call updateActionButtonsState
        // Image mode is handled within its own flow or by this point should be off
        // General re-enabling if not handled by specific mode deactivation:
        removeThinkingIndicator(); // General cleanup
        if (messageInput) messageInput.disabled = false;
        if (sendButton) sendButton.disabled = false;
        if (initialSendButton) initialSendButton.disabled = false;
        if (imageUploadButton) imageUploadButton.disabled = false;
        updateActionButtonsState(); // Ensure correct final state
        if (messageInput && !messageInput.disabled) messageInput.focus();
    }

    function sendMessage() {
         if (isInitializing || currentThinkingIndicatorElement) {
             if (isImageGenerationModeActive && messageInput.value.trim()) {
                 // Allow sending if in image mode and there's text (for prompt)
             } else if (currentThinkingIndicatorElement) {
                console.log("Send prevented: thinking/generation indicator active.");
                return;
             } else if (isInitializing) {
                console.log("Send prevented: initializing.");
                return;
             }
         }

        const messageText = messageInput.value.trim();
        const imageSelected = !!selectedImageData;

        if (messageText || imageSelected || isImageGenerationModeActive) {
            if (!isImageGenerationModeActive || (isImageGenerationModeActive && !messageText && !imageSelected) ) {
                 // Clear input only if not in image mode waiting for prompt,
                 // or if in image mode but user sent truly empty (no text, no new image)
                 if (!(isImageGenerationModeActive && (messageText || imageSelected))) {
                    messageInput.value = '';
                 }
            }
            sendMessageInternal(messageText, false);
        }
    }
    async function handleInitialSendMessage() {
         if (isInitializing || currentThinkingIndicatorElement) {
             if (isImageGenerationModeActive && initialMessageInput.value.trim()) {
                 // Allow sending if in image mode and there's text
             } else if (currentThinkingIndicatorElement) {
                console.log("Send prevented: thinking/generation indicator active.");
                return;
             } else if (isInitializing) {
                console.log("Send prevented: initializing.");
                return;
             }
         }
        const messageText = initialMessageInput.value.trim();
        if (!messageText && !isImageGenerationModeActive && !selectedImageData) return;

        if (!isImageGenerationModeActive || (isImageGenerationModeActive && !messageText && !selectedImageData)) {
            if (!(isImageGenerationModeActive && (messageText || selectedImageData))) {
                initialMessageInput.value = '';
            }
        }
        switchToChatView();
        await sendMessageInternal(messageText, true);
    }

    // --- Event Handlers ---
    function handleSelectChat(chatId) {
         if (chatId === currentChatId || isInitializing || currentThinkingIndicatorElement) { return; }
        console.log(`Selecting chat: ${chatId}`);
        currentChatId = chatId;
        saveCurrentChatId();
        updateActiveChatListItem();
        switchToChatView();
        deactivateReasonMode();
        deactivateImageGenerationMode();
        initializeAICurrentChat();
    }
    function displayNewChatWelcome(container) {
        if (!container) {
            console.error("Message container not found for welcome message.");
            return;
        }
        console.log("Displaying new chat welcome message.");
        container.innerHTML = '';

        const welcomeContainer = document.createElement('div');
        welcomeContainer.className = 'new-chat-welcome-container';

        const title = document.createElement('h1');
        title.className = 'welcome-title';
        title.textContent = 'Graxybot';
        welcomeContainer.appendChild(title);

        const promptsGrid = document.createElement('div');
        promptsGrid.className = 'suggested-prompts-grid';

        const hour = new Date().getHours();
        let timeBasedGreeting = "How can I help you today?";
        if (hour < 12) {
            timeBasedGreeting = "How's your morning? Coffee and Graxybot time?";
        } else if (hour < 18) {
            timeBasedGreeting = "Good afternoon! What can I help you achieve?";
        } else {
            timeBasedGreeting = "Good evening! Ready to wrap up the day or start something new?";
        }

        const suggestions = [
            timeBasedGreeting,
            "Explain quantum computing in simple terms.",
            "Write a short story about a robot who dreams.",
            "Click 'Create Image' then type your prompt!",
        ];

        suggestions.forEach(text => {
            const btn = document.createElement('button');
            btn.className = 'prompt-button';
            btn.textContent = text;
            btn.onclick = () => {
                if (messageInput) {
                    messageInput.value = text;
                    messageInput.focus();
                }
            };
            promptsGrid.appendChild(btn);
        });

        welcomeContainer.appendChild(promptsGrid);
        container.appendChild(welcomeContainer);
    }
    function handleNewChat() {
        console.log("New chat requested via button.");
        if (isInitializing || currentThinkingIndicatorElement) return;
        currentChatId = null;
        saveCurrentChatId();
        currentChatSession = null;
        switchToChatView();
        updateActiveChatListItem();
        displayNewChatWelcome(chatMessagesContainer);
        if(messageInput) { messageInput.value = ''; messageInput.disabled = false; messageInput.placeholder = "Message Graxybot..."; }
        if(sendButton) sendButton.disabled = false;
        const preferredModel = DEFAULT_FAKE_MODEL;
        if(modelSelector) modelSelector.value = preferredModel;
        updateModelNotification(preferredModel);
        deactivateReasonMode();
        deactivateImageGenerationMode();
        removeSelectedImage();
        if(messageInput) messageInput.focus();
    }
    function handleDeleteChat(chatIdToDelete) {
        if (!chats[chatIdToDelete] || isInitializing || currentThinkingIndicatorElement) return;
        const chatTitle = chats[chatIdToDelete].title || `Chat ${chatIdToDelete.substring(chatIdToDelete.length - 5)}`;
        if (!confirm(`Are you sure you want to delete the chat "${chatTitle}"?`)) { return; }
        console.log(`Deleting chat: ${chatIdToDelete}`);
        const wasActive = (currentChatId === chatIdToDelete);
        if (wasActive) { removeThinkingIndicator(); }
        delete chats[chatIdToDelete];
        saveAllChats();
        if (wasActive) { handleNewChat(); }
        renderChatList();
    }
    function handleModelChange(event) {
        if (isInitializing || currentThinkingIndicatorElement) return;
        const selectedModel = event.target.value;
        console.log(`Model selected via UI: ${selectedModel}`);
        saveSelectedModelPreference(selectedModel);
        updateModelNotification(selectedModel);
        if (currentChatId && chats[currentChatId]) {
            console.log(`Updating model for current chat ${currentChatId} to ${selectedModel}`);
            chats[currentChatId].model = selectedModel;
            delete chats[currentChatId].personality;
            saveAllChats();
            deactivateReasonMode();
            deactivateImageGenerationMode();
            initializeAICurrentChat();
        } else if (!currentChatId && chatView && !chatView.classList.contains('hidden')) {
            deactivateReasonMode();
            deactivateImageGenerationMode();
        }
    }
    function handleReasonButtonClick() {
        if (isInitializing || currentThinkingIndicatorElement || isImageGenerationModeActive) return;
        isReasonModeActive = !isReasonModeActive;
        if (isReasonModeActive) {
            console.log("Thinking mode (Quen 3 Local) activated.");
             if(messageInput) messageInput.placeholder = "Enhanced thinking active...";
        } else {
            console.log("Thinking mode (Quen 3 Local) deactivated.");
             if(messageInput) messageInput.placeholder = "Message Graxybot...";
        }
        updateActionButtonsState();
    }

    function handleCreateImageButtonClick() {
        if (isInitializing || currentThinkingIndicatorElement || isReasonModeActive) return;
        isImageGenerationModeActive = !isImageGenerationModeActive;
        if (isImageGenerationModeActive) {
            console.log("Image Generation Mode ACTIVATED. Next message will be used as prompt.");
            if(messageInput) messageInput.placeholder = "Enter image prompt...";
        } else {
            console.log("Image Generation Mode DEACTIVATED.");
            if(messageInput) messageInput.placeholder = "Message Graxybot...";
        }
        updateActionButtonsState();
        if(messageInput) messageInput.focus();
    }


    function showPopup() { if (popupOverlay) popupOverlay.classList.add('visible'); }
    function hidePopup() { if (popupOverlay) popupOverlay.classList.remove('visible'); }


    // --- Initialization Sequence ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded. Initializing Graxybot UI...");
        chatMessagesContainer = document.getElementById('chat-messages');
        messageInput = document.getElementById('message-input');
        sendButton = document.getElementById('send-button');
        rateLimitMessageDiv = document.getElementById('rate-limit-message');
        modelSelector = document.getElementById('model-selector');
        initialView = document.getElementById('initial-view');
        chatView = document.getElementById('chat-view');
        initialMessageInput = document.getElementById('initial-message-input');
        initialSendButton = document.getElementById('initial-send-button');
        sidebar = document.querySelector('.sidebar');
        newChatBtn = document.getElementById('new-chat-btn');
        chatListUl = document.getElementById('chat-list');
        reasonButton = document.getElementById('reason-button');
        reasonUsageDisplay = document.getElementById('reason-usage-display');
        createImageButton = document.getElementById('create-image-button');
        imageUploadButton = document.getElementById('image-upload-button');
        imageUploadInput = document.getElementById('image-upload-input');
        imagePreviewArea = document.getElementById('image-preview-area');
        imagePreview = document.getElementById('image-preview');
        removeImageButton = document.getElementById('remove-image-button');
        modelNotificationDiv = document.getElementById('model-notification');
        popupOverlay = document.getElementById('popupOverlay');
        closePopupButton = document.getElementById('closePopupButton');
        initialLoader = document.getElementById('initial-loader');
        chatLoader = document.getElementById('chat-loader');

        const essentialElements = { chatMessagesContainer, messageInput, sendButton, modelSelector, initialView, chatView, initialMessageInput, initialSendButton, newChatBtn, chatListUl, reasonButton, createImageButton, imageUploadButton, popupOverlay, closePopupButton, initialLoader, chatLoader };
        if (Object.values(essentialElements).some(el => !el)) {
            console.error("Fatal Error: One or more essential UI elements not found.");
            document.body.innerHTML = "<p style='color: red; padding: 20px;'>Error: UI failed to load. Check console.</p>"; return;
        }
        console.log("All essential DOM elements found.");

        chats = loadAllChats();
        currentChatId = loadCurrentChatId();
        const preferredModel = loadSelectedModelPreference();
        if(modelSelector) modelSelector.value = preferredModel;
        updateActionButtonsState();
        if(reasonButton) reasonButton.style.display = 'none';
        if(createImageButton) createImageButton.style.display = 'none';
        if(reasonUsageDisplay) reasonUsageDisplay.style.display = 'none';
        if(modelNotificationDiv) modelNotificationDiv.style.display = 'none';
        renderChatList();


        if (!API_KEY || API_KEY === "YOUR_GOOGLE_AI_API_KEY" || (API_KEY.startsWith("AIzaSyB") && API_KEY.length < 30)) {
            console.warn("Google AI API Key missing/invalid. Graxybot (Google AI) features disabled.");
            const warningMsg = "Configure Google AI API Key in script for Graxybot to function.";
            if(initialView && !initialView.classList.contains('hidden')) { if(initialMessageInput) initialMessageInput.placeholder = "Google API Key needed!"; }
            else if (chatMessagesContainer) { displayMessage([{text: warningMsg}], 'bot', true); }
             if (!currentChatId || !chats[currentChatId]) { switchToInitialView(); }
             else { switchToChatView(); initializeAICurrentChat(); }
        } else {
            console.log("Google API Key present. Proceeding.");
            if (currentChatId && chats[currentChatId]) {
                switchToChatView(); initializeAICurrentChat();
            } else {
                switchToInitialView(); if(initialMessageInput) initialMessageInput.focus();
            }
        }
        if(initialMessageInput) initialMessageInput.placeholder = "Ask me anything...";
        if(messageInput) messageInput.placeholder = "Message Graxybot...";


        sendButton?.addEventListener('click', sendMessage);
        messageInput?.addEventListener('keypress', (e) => { if (e.key==='Enter'&&!e.shiftKey&&!sendButton?.disabled&&!currentThinkingIndicatorElement) { e.preventDefault(); sendMessage(); }});
        initialSendButton?.addEventListener('click', handleInitialSendMessage);
        initialMessageInput?.addEventListener('keypress', (e) => { if (e.key==='Enter'&&!e.shiftKey&&!initialSendButton?.disabled&&!currentThinkingIndicatorElement) { e.preventDefault(); handleInitialSendMessage(); }});
        modelSelector?.addEventListener('change', handleModelChange);
        newChatBtn?.addEventListener('click', handleNewChat);
        reasonButton?.addEventListener('click', handleReasonButtonClick);
        createImageButton?.addEventListener('click', handleCreateImageButtonClick);

        imageUploadButton?.addEventListener('click', () => { if (!imageUploadButton.disabled) imageUploadInput?.click(); });
        imageUploadInput?.addEventListener('change', handleImageSelection);
        removeImageButton?.addEventListener('click', removeSelectedImage);
        closePopupButton?.addEventListener('click', hidePopup);
        popupOverlay?.addEventListener('click', (e) => { if (e.target === popupOverlay) hidePopup(); });

        showPopup();
        if(initialLoader) initialLoader.classList.add('hidden');
        console.log("Graxybot initialization complete.");
    });
</script>

</body>
</html>
